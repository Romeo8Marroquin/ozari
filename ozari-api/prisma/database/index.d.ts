
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BlacklistType
 * 
 */
export type BlacklistType = $Result.DefaultSelection<Prisma.$BlacklistTypePayload>
/**
 * Model Blacklist
 * 
 */
export type Blacklist = $Result.DefaultSelection<Prisma.$BlacklistPayload>
/**
 * Model UserPhoneType
 * 
 */
export type UserPhoneType = $Result.DefaultSelection<Prisma.$UserPhoneTypePayload>
/**
 * Model UserPhone
 * 
 */
export type UserPhone = $Result.DefaultSelection<Prisma.$UserPhonePayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model ProductBusinessType
 * 
 */
export type ProductBusinessType = $Result.DefaultSelection<Prisma.$ProductBusinessTypePayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductDetailType
 * 
 */
export type ProductDetailType = $Result.DefaultSelection<Prisma.$ProductDetailTypePayload>
/**
 * Model ProductDetail
 * 
 */
export type ProductDetail = $Result.DefaultSelection<Prisma.$ProductDetailPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model CountryDepartment
 * 
 */
export type CountryDepartment = $Result.DefaultSelection<Prisma.$CountryDepartmentPayload>
/**
 * Model Municipality
 * 
 */
export type Municipality = $Result.DefaultSelection<Prisma.$MunicipalityPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model ServiceStatus
 * 
 */
export type ServiceStatus = $Result.DefaultSelection<Prisma.$ServiceStatusPayload>
/**
 * Model PaymentStatus
 * 
 */
export type PaymentStatus = $Result.DefaultSelection<Prisma.$PaymentStatusPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceDetail
 * 
 */
export type ServiceDetail = $Result.DefaultSelection<Prisma.$ServiceDetailPayload>
/**
 * Model ServiceExtra
 * 
 */
export type ServiceExtra = $Result.DefaultSelection<Prisma.$ServiceExtraPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserRoles
 * const userRoles = await prisma.userRole.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserRoles
   * const userRoles = await prisma.userRole.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blacklistType`: Exposes CRUD operations for the **BlacklistType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlacklistTypes
    * const blacklistTypes = await prisma.blacklistType.findMany()
    * ```
    */
  get blacklistType(): Prisma.BlacklistTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blacklist`: Exposes CRUD operations for the **Blacklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blacklists
    * const blacklists = await prisma.blacklist.findMany()
    * ```
    */
  get blacklist(): Prisma.BlacklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPhoneType`: Exposes CRUD operations for the **UserPhoneType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhoneTypes
    * const userPhoneTypes = await prisma.userPhoneType.findMany()
    * ```
    */
  get userPhoneType(): Prisma.UserPhoneTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPhone`: Exposes CRUD operations for the **UserPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhones
    * const userPhones = await prisma.userPhone.findMany()
    * ```
    */
  get userPhone(): Prisma.UserPhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productBusinessType`: Exposes CRUD operations for the **ProductBusinessType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductBusinessTypes
    * const productBusinessTypes = await prisma.productBusinessType.findMany()
    * ```
    */
  get productBusinessType(): Prisma.ProductBusinessTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productDetailType`: Exposes CRUD operations for the **ProductDetailType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductDetailTypes
    * const productDetailTypes = await prisma.productDetailType.findMany()
    * ```
    */
  get productDetailType(): Prisma.ProductDetailTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productDetail`: Exposes CRUD operations for the **ProductDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductDetails
    * const productDetails = await prisma.productDetail.findMany()
    * ```
    */
  get productDetail(): Prisma.ProductDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countryDepartment`: Exposes CRUD operations for the **CountryDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountryDepartments
    * const countryDepartments = await prisma.countryDepartment.findMany()
    * ```
    */
  get countryDepartment(): Prisma.CountryDepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.municipality`: Exposes CRUD operations for the **Municipality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipalities
    * const municipalities = await prisma.municipality.findMany()
    * ```
    */
  get municipality(): Prisma.MunicipalityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceStatus`: Exposes CRUD operations for the **ServiceStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceStatuses
    * const serviceStatuses = await prisma.serviceStatus.findMany()
    * ```
    */
  get serviceStatus(): Prisma.ServiceStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentStatus`: Exposes CRUD operations for the **PaymentStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentStatuses
    * const paymentStatuses = await prisma.paymentStatus.findMany()
    * ```
    */
  get paymentStatus(): Prisma.PaymentStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceDetail`: Exposes CRUD operations for the **ServiceDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceDetails
    * const serviceDetails = await prisma.serviceDetail.findMany()
    * ```
    */
  get serviceDetail(): Prisma.ServiceDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceExtra`: Exposes CRUD operations for the **ServiceExtra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceExtras
    * const serviceExtras = await prisma.serviceExtra.findMany()
    * ```
    */
  get serviceExtra(): Prisma.ServiceExtraDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserRole: 'UserRole',
    User: 'User',
    BlacklistType: 'BlacklistType',
    Blacklist: 'Blacklist',
    UserPhoneType: 'UserPhoneType',
    UserPhone: 'UserPhone',
    Currency: 'Currency',
    ProductBusinessType: 'ProductBusinessType',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    ProductDetailType: 'ProductDetailType',
    ProductDetail: 'ProductDetail',
    Country: 'Country',
    CountryDepartment: 'CountryDepartment',
    Municipality: 'Municipality',
    Zone: 'Zone',
    Address: 'Address',
    ServiceStatus: 'ServiceStatus',
    PaymentStatus: 'PaymentStatus',
    Service: 'Service',
    ServiceDetail: 'ServiceDetail',
    ServiceExtra: 'ServiceExtra'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "userRole" | "user" | "blacklistType" | "blacklist" | "userPhoneType" | "userPhone" | "currency" | "productBusinessType" | "productCategory" | "product" | "productDetailType" | "productDetail" | "country" | "countryDepartment" | "municipality" | "zone" | "address" | "serviceStatus" | "paymentStatus" | "service" | "serviceDetail" | "serviceExtra"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BlacklistType: {
        payload: Prisma.$BlacklistTypePayload<ExtArgs>
        fields: Prisma.BlacklistTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlacklistTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlacklistTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>
          }
          findFirst: {
            args: Prisma.BlacklistTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlacklistTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>
          }
          findMany: {
            args: Prisma.BlacklistTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>[]
          }
          create: {
            args: Prisma.BlacklistTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>
          }
          createMany: {
            args: Prisma.BlacklistTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlacklistTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>[]
          }
          delete: {
            args: Prisma.BlacklistTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>
          }
          update: {
            args: Prisma.BlacklistTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>
          }
          deleteMany: {
            args: Prisma.BlacklistTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlacklistTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlacklistTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>[]
          }
          upsert: {
            args: Prisma.BlacklistTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistTypePayload>
          }
          aggregate: {
            args: Prisma.BlacklistTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlacklistType>
          }
          groupBy: {
            args: Prisma.BlacklistTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlacklistTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlacklistTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BlacklistTypeCountAggregateOutputType> | number
          }
        }
      }
      Blacklist: {
        payload: Prisma.$BlacklistPayload<ExtArgs>
        fields: Prisma.BlacklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlacklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlacklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          findFirst: {
            args: Prisma.BlacklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlacklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          findMany: {
            args: Prisma.BlacklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>[]
          }
          create: {
            args: Prisma.BlacklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          createMany: {
            args: Prisma.BlacklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlacklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>[]
          }
          delete: {
            args: Prisma.BlacklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          update: {
            args: Prisma.BlacklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          deleteMany: {
            args: Prisma.BlacklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlacklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlacklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>[]
          }
          upsert: {
            args: Prisma.BlacklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistPayload>
          }
          aggregate: {
            args: Prisma.BlacklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlacklist>
          }
          groupBy: {
            args: Prisma.BlacklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlacklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlacklistCountArgs<ExtArgs>
            result: $Utils.Optional<BlacklistCountAggregateOutputType> | number
          }
        }
      }
      UserPhoneType: {
        payload: Prisma.$UserPhoneTypePayload<ExtArgs>
        fields: Prisma.UserPhoneTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhoneTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhoneTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>
          }
          findFirst: {
            args: Prisma.UserPhoneTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhoneTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>
          }
          findMany: {
            args: Prisma.UserPhoneTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>[]
          }
          create: {
            args: Prisma.UserPhoneTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>
          }
          createMany: {
            args: Prisma.UserPhoneTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPhoneTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>[]
          }
          delete: {
            args: Prisma.UserPhoneTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>
          }
          update: {
            args: Prisma.UserPhoneTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>
          }
          deleteMany: {
            args: Prisma.UserPhoneTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhoneTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPhoneTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>[]
          }
          upsert: {
            args: Prisma.UserPhoneTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhoneTypePayload>
          }
          aggregate: {
            args: Prisma.UserPhoneTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhoneType>
          }
          groupBy: {
            args: Prisma.UserPhoneTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPhoneTypeCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneTypeCountAggregateOutputType> | number
          }
        }
      }
      UserPhone: {
        payload: Prisma.$UserPhonePayload<ExtArgs>
        fields: Prisma.UserPhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          findFirst: {
            args: Prisma.UserPhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          findMany: {
            args: Prisma.UserPhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          create: {
            args: Prisma.UserPhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          createMany: {
            args: Prisma.UserPhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPhoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          delete: {
            args: Prisma.UserPhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          update: {
            args: Prisma.UserPhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          deleteMany: {
            args: Prisma.UserPhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPhoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>[]
          }
          upsert: {
            args: Prisma.UserPhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPhonePayload>
          }
          aggregate: {
            args: Prisma.UserPhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPhone>
          }
          groupBy: {
            args: Prisma.UserPhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPhoneCountArgs<ExtArgs>
            result: $Utils.Optional<UserPhoneCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      ProductBusinessType: {
        payload: Prisma.$ProductBusinessTypePayload<ExtArgs>
        fields: Prisma.ProductBusinessTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductBusinessTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductBusinessTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>
          }
          findFirst: {
            args: Prisma.ProductBusinessTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductBusinessTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>
          }
          findMany: {
            args: Prisma.ProductBusinessTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>[]
          }
          create: {
            args: Prisma.ProductBusinessTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>
          }
          createMany: {
            args: Prisma.ProductBusinessTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductBusinessTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>[]
          }
          delete: {
            args: Prisma.ProductBusinessTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>
          }
          update: {
            args: Prisma.ProductBusinessTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>
          }
          deleteMany: {
            args: Prisma.ProductBusinessTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductBusinessTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductBusinessTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>[]
          }
          upsert: {
            args: Prisma.ProductBusinessTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBusinessTypePayload>
          }
          aggregate: {
            args: Prisma.ProductBusinessTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductBusinessType>
          }
          groupBy: {
            args: Prisma.ProductBusinessTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductBusinessTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductBusinessTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductBusinessTypeCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductDetailType: {
        payload: Prisma.$ProductDetailTypePayload<ExtArgs>
        fields: Prisma.ProductDetailTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductDetailTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductDetailTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>
          }
          findFirst: {
            args: Prisma.ProductDetailTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductDetailTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>
          }
          findMany: {
            args: Prisma.ProductDetailTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>[]
          }
          create: {
            args: Prisma.ProductDetailTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>
          }
          createMany: {
            args: Prisma.ProductDetailTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductDetailTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>[]
          }
          delete: {
            args: Prisma.ProductDetailTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>
          }
          update: {
            args: Prisma.ProductDetailTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>
          }
          deleteMany: {
            args: Prisma.ProductDetailTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductDetailTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductDetailTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>[]
          }
          upsert: {
            args: Prisma.ProductDetailTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailTypePayload>
          }
          aggregate: {
            args: Prisma.ProductDetailTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductDetailType>
          }
          groupBy: {
            args: Prisma.ProductDetailTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductDetailTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductDetailTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductDetailTypeCountAggregateOutputType> | number
          }
        }
      }
      ProductDetail: {
        payload: Prisma.$ProductDetailPayload<ExtArgs>
        fields: Prisma.ProductDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          findFirst: {
            args: Prisma.ProductDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          findMany: {
            args: Prisma.ProductDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>[]
          }
          create: {
            args: Prisma.ProductDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          createMany: {
            args: Prisma.ProductDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>[]
          }
          delete: {
            args: Prisma.ProductDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          update: {
            args: Prisma.ProductDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          deleteMany: {
            args: Prisma.ProductDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>[]
          }
          upsert: {
            args: Prisma.ProductDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDetailPayload>
          }
          aggregate: {
            args: Prisma.ProductDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductDetail>
          }
          groupBy: {
            args: Prisma.ProductDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ProductDetailCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      CountryDepartment: {
        payload: Prisma.$CountryDepartmentPayload<ExtArgs>
        fields: Prisma.CountryDepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryDepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryDepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>
          }
          findFirst: {
            args: Prisma.CountryDepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryDepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>
          }
          findMany: {
            args: Prisma.CountryDepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>[]
          }
          create: {
            args: Prisma.CountryDepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>
          }
          createMany: {
            args: Prisma.CountryDepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryDepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>[]
          }
          delete: {
            args: Prisma.CountryDepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>
          }
          update: {
            args: Prisma.CountryDepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>
          }
          deleteMany: {
            args: Prisma.CountryDepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryDepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryDepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>[]
          }
          upsert: {
            args: Prisma.CountryDepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryDepartmentPayload>
          }
          aggregate: {
            args: Prisma.CountryDepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountryDepartment>
          }
          groupBy: {
            args: Prisma.CountryDepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryDepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryDepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<CountryDepartmentCountAggregateOutputType> | number
          }
        }
      }
      Municipality: {
        payload: Prisma.$MunicipalityPayload<ExtArgs>
        fields: Prisma.MunicipalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MunicipalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MunicipalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findFirst: {
            args: Prisma.MunicipalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MunicipalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          findMany: {
            args: Prisma.MunicipalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          create: {
            args: Prisma.MunicipalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          createMany: {
            args: Prisma.MunicipalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MunicipalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          delete: {
            args: Prisma.MunicipalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          update: {
            args: Prisma.MunicipalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          deleteMany: {
            args: Prisma.MunicipalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MunicipalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MunicipalityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>[]
          }
          upsert: {
            args: Prisma.MunicipalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MunicipalityPayload>
          }
          aggregate: {
            args: Prisma.MunicipalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipality>
          }
          groupBy: {
            args: Prisma.MunicipalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MunicipalityCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipalityCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      ServiceStatus: {
        payload: Prisma.$ServiceStatusPayload<ExtArgs>
        fields: Prisma.ServiceStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>
          }
          findFirst: {
            args: Prisma.ServiceStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>
          }
          findMany: {
            args: Prisma.ServiceStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>[]
          }
          create: {
            args: Prisma.ServiceStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>
          }
          createMany: {
            args: Prisma.ServiceStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>[]
          }
          delete: {
            args: Prisma.ServiceStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>
          }
          update: {
            args: Prisma.ServiceStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>
          }
          deleteMany: {
            args: Prisma.ServiceStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>[]
          }
          upsert: {
            args: Prisma.ServiceStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceStatusPayload>
          }
          aggregate: {
            args: Prisma.ServiceStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceStatus>
          }
          groupBy: {
            args: Prisma.ServiceStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceStatusCountAggregateOutputType> | number
          }
        }
      }
      PaymentStatus: {
        payload: Prisma.$PaymentStatusPayload<ExtArgs>
        fields: Prisma.PaymentStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>
          }
          findFirst: {
            args: Prisma.PaymentStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>
          }
          findMany: {
            args: Prisma.PaymentStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>[]
          }
          create: {
            args: Prisma.PaymentStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>
          }
          createMany: {
            args: Prisma.PaymentStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>[]
          }
          delete: {
            args: Prisma.PaymentStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>
          }
          update: {
            args: Prisma.PaymentStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>
          }
          deleteMany: {
            args: Prisma.PaymentStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>[]
          }
          upsert: {
            args: Prisma.PaymentStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStatusPayload>
          }
          aggregate: {
            args: Prisma.PaymentStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentStatus>
          }
          groupBy: {
            args: Prisma.PaymentStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentStatusCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentStatusCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceDetail: {
        payload: Prisma.$ServiceDetailPayload<ExtArgs>
        fields: Prisma.ServiceDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>
          }
          findFirst: {
            args: Prisma.ServiceDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>
          }
          findMany: {
            args: Prisma.ServiceDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>[]
          }
          create: {
            args: Prisma.ServiceDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>
          }
          createMany: {
            args: Prisma.ServiceDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>[]
          }
          delete: {
            args: Prisma.ServiceDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>
          }
          update: {
            args: Prisma.ServiceDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>
          }
          deleteMany: {
            args: Prisma.ServiceDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>[]
          }
          upsert: {
            args: Prisma.ServiceDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceDetailPayload>
          }
          aggregate: {
            args: Prisma.ServiceDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceDetail>
          }
          groupBy: {
            args: Prisma.ServiceDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceDetailCountAggregateOutputType> | number
          }
        }
      }
      ServiceExtra: {
        payload: Prisma.$ServiceExtraPayload<ExtArgs>
        fields: Prisma.ServiceExtraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceExtraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceExtraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>
          }
          findFirst: {
            args: Prisma.ServiceExtraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceExtraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>
          }
          findMany: {
            args: Prisma.ServiceExtraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>[]
          }
          create: {
            args: Prisma.ServiceExtraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>
          }
          createMany: {
            args: Prisma.ServiceExtraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceExtraCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>[]
          }
          delete: {
            args: Prisma.ServiceExtraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>
          }
          update: {
            args: Prisma.ServiceExtraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>
          }
          deleteMany: {
            args: Prisma.ServiceExtraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceExtraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceExtraUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>[]
          }
          upsert: {
            args: Prisma.ServiceExtraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceExtraPayload>
          }
          aggregate: {
            args: Prisma.ServiceExtraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceExtra>
          }
          groupBy: {
            args: Prisma.ServiceExtraGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceExtraGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceExtraCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceExtraCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    userRole?: UserRoleOmit
    user?: UserOmit
    blacklistType?: BlacklistTypeOmit
    blacklist?: BlacklistOmit
    userPhoneType?: UserPhoneTypeOmit
    userPhone?: UserPhoneOmit
    currency?: CurrencyOmit
    productBusinessType?: ProductBusinessTypeOmit
    productCategory?: ProductCategoryOmit
    product?: ProductOmit
    productDetailType?: ProductDetailTypeOmit
    productDetail?: ProductDetailOmit
    country?: CountryOmit
    countryDepartment?: CountryDepartmentOmit
    municipality?: MunicipalityOmit
    zone?: ZoneOmit
    address?: AddressOmit
    serviceStatus?: ServiceStatusOmit
    paymentStatus?: PaymentStatusOmit
    service?: ServiceOmit
    serviceDetail?: ServiceDetailOmit
    serviceExtra?: ServiceExtraOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserRoleCountOutputType
   */

  export type UserRoleCountOutputType = {
    users: number
  }

  export type UserRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserRoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleCountOutputType
     */
    select?: UserRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    blacklists: number
    userPhones: number
    addresses: number
    services: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blacklists?: boolean | UserCountOutputTypeCountBlacklistsArgs
    userPhones?: boolean | UserCountOutputTypeCountUserPhonesArgs
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    services?: boolean | UserCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type BlacklistTypeCountOutputType
   */

  export type BlacklistTypeCountOutputType = {
    blacklists: number
  }

  export type BlacklistTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blacklists?: boolean | BlacklistTypeCountOutputTypeCountBlacklistsArgs
  }

  // Custom InputTypes
  /**
   * BlacklistTypeCountOutputType without action
   */
  export type BlacklistTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistTypeCountOutputType
     */
    select?: BlacklistTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlacklistTypeCountOutputType without action
   */
  export type BlacklistTypeCountOutputTypeCountBlacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistWhereInput
  }


  /**
   * Count Type UserPhoneTypeCountOutputType
   */

  export type UserPhoneTypeCountOutputType = {
    userPhones: number
  }

  export type UserPhoneTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPhones?: boolean | UserPhoneTypeCountOutputTypeCountUserPhonesArgs
  }

  // Custom InputTypes
  /**
   * UserPhoneTypeCountOutputType without action
   */
  export type UserPhoneTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneTypeCountOutputType
     */
    select?: UserPhoneTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPhoneTypeCountOutputType without action
   */
  export type UserPhoneTypeCountOutputTypeCountUserPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneWhereInput
  }


  /**
   * Count Type UserPhoneCountOutputType
   */

  export type UserPhoneCountOutputType = {
    services: number
  }

  export type UserPhoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | UserPhoneCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * UserPhoneCountOutputType without action
   */
  export type UserPhoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneCountOutputType
     */
    select?: UserPhoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPhoneCountOutputType without action
   */
  export type UserPhoneCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    products: number
    services: number
    serviceDetails: number
    serviceExtras: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CurrencyCountOutputTypeCountProductsArgs
    services?: boolean | CurrencyCountOutputTypeCountServicesArgs
    serviceDetails?: boolean | CurrencyCountOutputTypeCountServiceDetailsArgs
    serviceExtras?: boolean | CurrencyCountOutputTypeCountServiceExtrasArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountServiceDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceDetailWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountServiceExtrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceExtraWhereInput
  }


  /**
   * Count Type ProductBusinessTypeCountOutputType
   */

  export type ProductBusinessTypeCountOutputType = {
    products: number
  }

  export type ProductBusinessTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductBusinessTypeCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductBusinessTypeCountOutputType without action
   */
  export type ProductBusinessTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessTypeCountOutputType
     */
    select?: ProductBusinessTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductBusinessTypeCountOutputType without action
   */
  export type ProductBusinessTypeCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    productDetails: number
    serviceDetails: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productDetails?: boolean | ProductCountOutputTypeCountProductDetailsArgs
    serviceDetails?: boolean | ProductCountOutputTypeCountServiceDetailsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDetailWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountServiceDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceDetailWhereInput
  }


  /**
   * Count Type ProductDetailTypeCountOutputType
   */

  export type ProductDetailTypeCountOutputType = {
    productDetails: number
  }

  export type ProductDetailTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productDetails?: boolean | ProductDetailTypeCountOutputTypeCountProductDetailsArgs
  }

  // Custom InputTypes
  /**
   * ProductDetailTypeCountOutputType without action
   */
  export type ProductDetailTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailTypeCountOutputType
     */
    select?: ProductDetailTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductDetailTypeCountOutputType without action
   */
  export type ProductDetailTypeCountOutputTypeCountProductDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDetailWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    departments: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | CountryCountOutputTypeCountDepartmentsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryDepartmentWhereInput
  }


  /**
   * Count Type CountryDepartmentCountOutputType
   */

  export type CountryDepartmentCountOutputType = {
    municipalities: number
  }

  export type CountryDepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipalities?: boolean | CountryDepartmentCountOutputTypeCountMunicipalitiesArgs
  }

  // Custom InputTypes
  /**
   * CountryDepartmentCountOutputType without action
   */
  export type CountryDepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartmentCountOutputType
     */
    select?: CountryDepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryDepartmentCountOutputType without action
   */
  export type CountryDepartmentCountOutputTypeCountMunicipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
  }


  /**
   * Count Type MunicipalityCountOutputType
   */

  export type MunicipalityCountOutputType = {
    zones: number
  }

  export type MunicipalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | MunicipalityCountOutputTypeCountZonesArgs
  }

  // Custom InputTypes
  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipalityCountOutputType
     */
    select?: MunicipalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipalityCountOutputType without action
   */
  export type MunicipalityCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    addresses: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | ZoneCountOutputTypeCountAddressesArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    services: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | AddressCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceStatusCountOutputType
   */

  export type ServiceStatusCountOutputType = {
    services: number
  }

  export type ServiceStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceStatusCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * ServiceStatusCountOutputType without action
   */
  export type ServiceStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatusCountOutputType
     */
    select?: ServiceStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceStatusCountOutputType without action
   */
  export type ServiceStatusCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type PaymentStatusCountOutputType
   */

  export type PaymentStatusCountOutputType = {
    services: number
  }

  export type PaymentStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | PaymentStatusCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * PaymentStatusCountOutputType without action
   */
  export type PaymentStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatusCountOutputType
     */
    select?: PaymentStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentStatusCountOutputType without action
   */
  export type PaymentStatusCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    serviceDetails: number
    serviceExtras: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceDetails?: boolean | ServiceCountOutputTypeCountServiceDetailsArgs
    serviceExtras?: boolean | ServiceCountOutputTypeCountServiceExtrasArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceDetailWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceExtrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceExtraWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    id: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    id: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    id?: true
  }

  export type UserRoleSumAggregateInputType = {
    id?: true
  }

  export type UserRoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    users?: boolean | UserRole$usersArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserRole$usersArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserRole$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'Int'>
    readonly name: FieldRef<"UserRole", 'String'>
    readonly description: FieldRef<"UserRole", 'String'>
    readonly isActive: FieldRef<"UserRole", 'Boolean'>
    readonly updatedAt: FieldRef<"UserRole", 'DateTime'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole.users
   */
  export type UserRole$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    fullNameKms: string | null
    emailSha: string | null
    emailKms: string | null
    roleId: number | null
    passwordSha: string | null
    passwordKms: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    fullNameKms: string | null
    emailSha: string | null
    emailKms: string | null
    roleId: number | null
    passwordSha: string | null
    passwordKms: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullNameKms: number
    emailSha: number
    emailKms: number
    roleId: number
    passwordSha: number
    passwordKms: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    fullNameKms?: true
    emailSha?: true
    emailKms?: true
    roleId?: true
    passwordSha?: true
    passwordKms?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullNameKms?: true
    emailSha?: true
    emailKms?: true
    roleId?: true
    passwordSha?: true
    passwordKms?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullNameKms?: true
    emailSha?: true
    emailKms?: true
    roleId?: true
    passwordSha?: true
    passwordKms?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    fullNameKms: string | null
    emailSha: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullNameKms?: boolean
    emailSha?: boolean
    emailKms?: boolean
    roleId?: boolean
    passwordSha?: boolean
    passwordKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    role?: boolean | UserRoleDefaultArgs<ExtArgs>
    blacklists?: boolean | User$blacklistsArgs<ExtArgs>
    userPhones?: boolean | User$userPhonesArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullNameKms?: boolean
    emailSha?: boolean
    emailKms?: boolean
    roleId?: boolean
    passwordSha?: boolean
    passwordKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    role?: boolean | UserRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullNameKms?: boolean
    emailSha?: boolean
    emailKms?: boolean
    roleId?: boolean
    passwordSha?: boolean
    passwordKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    role?: boolean | UserRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    fullNameKms?: boolean
    emailSha?: boolean
    emailKms?: boolean
    roleId?: boolean
    passwordSha?: boolean
    passwordKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullNameKms" | "emailSha" | "emailKms" | "roleId" | "passwordSha" | "passwordKms" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | UserRoleDefaultArgs<ExtArgs>
    blacklists?: boolean | User$blacklistsArgs<ExtArgs>
    userPhones?: boolean | User$userPhonesArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    services?: boolean | User$servicesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | UserRoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | UserRoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$UserRolePayload<ExtArgs>
      blacklists: Prisma.$BlacklistPayload<ExtArgs>[]
      userPhones: Prisma.$UserPhonePayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullNameKms: string | null
      emailSha: string | null
      emailKms: string
      roleId: number
      passwordSha: string
      passwordKms: string
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends UserRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserRoleDefaultArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blacklists<T extends User$blacklistsArgs<ExtArgs> = {}>(args?: Subset<T, User$blacklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPhones<T extends User$userPhonesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPhonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends User$servicesArgs<ExtArgs> = {}>(args?: Subset<T, User$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly fullNameKms: FieldRef<"User", 'String'>
    readonly emailSha: FieldRef<"User", 'String'>
    readonly emailKms: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly passwordSha: FieldRef<"User", 'String'>
    readonly passwordKms: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.blacklists
   */
  export type User$blacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    where?: BlacklistWhereInput
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    cursor?: BlacklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * User.userPhones
   */
  export type User$userPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    where?: UserPhoneWhereInput
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    cursor?: UserPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * User.services
   */
  export type User$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model BlacklistType
   */

  export type AggregateBlacklistType = {
    _count: BlacklistTypeCountAggregateOutputType | null
    _avg: BlacklistTypeAvgAggregateOutputType | null
    _sum: BlacklistTypeSumAggregateOutputType | null
    _min: BlacklistTypeMinAggregateOutputType | null
    _max: BlacklistTypeMaxAggregateOutputType | null
  }

  export type BlacklistTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type BlacklistTypeSumAggregateOutputType = {
    id: number | null
  }

  export type BlacklistTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BlacklistTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BlacklistTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type BlacklistTypeAvgAggregateInputType = {
    id?: true
  }

  export type BlacklistTypeSumAggregateInputType = {
    id?: true
  }

  export type BlacklistTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BlacklistTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BlacklistTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BlacklistTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistType to aggregate.
     */
    where?: BlacklistTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistTypes to fetch.
     */
    orderBy?: BlacklistTypeOrderByWithRelationInput | BlacklistTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlacklistTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlacklistTypes
    **/
    _count?: true | BlacklistTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlacklistTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlacklistTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistTypeMaxAggregateInputType
  }

  export type GetBlacklistTypeAggregateType<T extends BlacklistTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklistType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklistType[P]>
      : GetScalarType<T[P], AggregateBlacklistType[P]>
  }




  export type BlacklistTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistTypeWhereInput
    orderBy?: BlacklistTypeOrderByWithAggregationInput | BlacklistTypeOrderByWithAggregationInput[]
    by: BlacklistTypeScalarFieldEnum[] | BlacklistTypeScalarFieldEnum
    having?: BlacklistTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistTypeCountAggregateInputType | true
    _avg?: BlacklistTypeAvgAggregateInputType
    _sum?: BlacklistTypeSumAggregateInputType
    _min?: BlacklistTypeMinAggregateInputType
    _max?: BlacklistTypeMaxAggregateInputType
  }

  export type BlacklistTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: BlacklistTypeCountAggregateOutputType | null
    _avg: BlacklistTypeAvgAggregateOutputType | null
    _sum: BlacklistTypeSumAggregateOutputType | null
    _min: BlacklistTypeMinAggregateOutputType | null
    _max: BlacklistTypeMaxAggregateOutputType | null
  }

  type GetBlacklistTypeGroupByPayload<T extends BlacklistTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistTypeGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    blacklists?: boolean | BlacklistType$blacklistsArgs<ExtArgs>
    _count?: boolean | BlacklistTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklistType"]>

  export type BlacklistTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blacklistType"]>

  export type BlacklistTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["blacklistType"]>

  export type BlacklistTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type BlacklistTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["blacklistType"]>
  export type BlacklistTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blacklists?: boolean | BlacklistType$blacklistsArgs<ExtArgs>
    _count?: boolean | BlacklistTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlacklistTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlacklistTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlacklistTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlacklistType"
    objects: {
      blacklists: Prisma.$BlacklistPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["blacklistType"]>
    composites: {}
  }

  type BlacklistTypeGetPayload<S extends boolean | null | undefined | BlacklistTypeDefaultArgs> = $Result.GetResult<Prisma.$BlacklistTypePayload, S>

  type BlacklistTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlacklistTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlacklistTypeCountAggregateInputType | true
    }

  export interface BlacklistTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlacklistType'], meta: { name: 'BlacklistType' } }
    /**
     * Find zero or one BlacklistType that matches the filter.
     * @param {BlacklistTypeFindUniqueArgs} args - Arguments to find a BlacklistType
     * @example
     * // Get one BlacklistType
     * const blacklistType = await prisma.blacklistType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlacklistTypeFindUniqueArgs>(args: SelectSubset<T, BlacklistTypeFindUniqueArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlacklistType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlacklistTypeFindUniqueOrThrowArgs} args - Arguments to find a BlacklistType
     * @example
     * // Get one BlacklistType
     * const blacklistType = await prisma.blacklistType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlacklistTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BlacklistTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlacklistType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeFindFirstArgs} args - Arguments to find a BlacklistType
     * @example
     * // Get one BlacklistType
     * const blacklistType = await prisma.blacklistType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlacklistTypeFindFirstArgs>(args?: SelectSubset<T, BlacklistTypeFindFirstArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlacklistType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeFindFirstOrThrowArgs} args - Arguments to find a BlacklistType
     * @example
     * // Get one BlacklistType
     * const blacklistType = await prisma.blacklistType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlacklistTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BlacklistTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlacklistTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlacklistTypes
     * const blacklistTypes = await prisma.blacklistType.findMany()
     * 
     * // Get first 10 BlacklistTypes
     * const blacklistTypes = await prisma.blacklistType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistTypeWithIdOnly = await prisma.blacklistType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlacklistTypeFindManyArgs>(args?: SelectSubset<T, BlacklistTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlacklistType.
     * @param {BlacklistTypeCreateArgs} args - Arguments to create a BlacklistType.
     * @example
     * // Create one BlacklistType
     * const BlacklistType = await prisma.blacklistType.create({
     *   data: {
     *     // ... data to create a BlacklistType
     *   }
     * })
     * 
     */
    create<T extends BlacklistTypeCreateArgs>(args: SelectSubset<T, BlacklistTypeCreateArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlacklistTypes.
     * @param {BlacklistTypeCreateManyArgs} args - Arguments to create many BlacklistTypes.
     * @example
     * // Create many BlacklistTypes
     * const blacklistType = await prisma.blacklistType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlacklistTypeCreateManyArgs>(args?: SelectSubset<T, BlacklistTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlacklistTypes and returns the data saved in the database.
     * @param {BlacklistTypeCreateManyAndReturnArgs} args - Arguments to create many BlacklistTypes.
     * @example
     * // Create many BlacklistTypes
     * const blacklistType = await prisma.blacklistType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlacklistTypes and only return the `id`
     * const blacklistTypeWithIdOnly = await prisma.blacklistType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlacklistTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BlacklistTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlacklistType.
     * @param {BlacklistTypeDeleteArgs} args - Arguments to delete one BlacklistType.
     * @example
     * // Delete one BlacklistType
     * const BlacklistType = await prisma.blacklistType.delete({
     *   where: {
     *     // ... filter to delete one BlacklistType
     *   }
     * })
     * 
     */
    delete<T extends BlacklistTypeDeleteArgs>(args: SelectSubset<T, BlacklistTypeDeleteArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlacklistType.
     * @param {BlacklistTypeUpdateArgs} args - Arguments to update one BlacklistType.
     * @example
     * // Update one BlacklistType
     * const blacklistType = await prisma.blacklistType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlacklistTypeUpdateArgs>(args: SelectSubset<T, BlacklistTypeUpdateArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlacklistTypes.
     * @param {BlacklistTypeDeleteManyArgs} args - Arguments to filter BlacklistTypes to delete.
     * @example
     * // Delete a few BlacklistTypes
     * const { count } = await prisma.blacklistType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlacklistTypeDeleteManyArgs>(args?: SelectSubset<T, BlacklistTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlacklistTypes
     * const blacklistType = await prisma.blacklistType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlacklistTypeUpdateManyArgs>(args: SelectSubset<T, BlacklistTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistTypes and returns the data updated in the database.
     * @param {BlacklistTypeUpdateManyAndReturnArgs} args - Arguments to update many BlacklistTypes.
     * @example
     * // Update many BlacklistTypes
     * const blacklistType = await prisma.blacklistType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlacklistTypes and only return the `id`
     * const blacklistTypeWithIdOnly = await prisma.blacklistType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlacklistTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, BlacklistTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlacklistType.
     * @param {BlacklistTypeUpsertArgs} args - Arguments to update or create a BlacklistType.
     * @example
     * // Update or create a BlacklistType
     * const blacklistType = await prisma.blacklistType.upsert({
     *   create: {
     *     // ... data to create a BlacklistType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlacklistType we want to update
     *   }
     * })
     */
    upsert<T extends BlacklistTypeUpsertArgs>(args: SelectSubset<T, BlacklistTypeUpsertArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlacklistTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeCountArgs} args - Arguments to filter BlacklistTypes to count.
     * @example
     * // Count the number of BlacklistTypes
     * const count = await prisma.blacklistType.count({
     *   where: {
     *     // ... the filter for the BlacklistTypes we want to count
     *   }
     * })
    **/
    count<T extends BlacklistTypeCountArgs>(
      args?: Subset<T, BlacklistTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlacklistType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistTypeAggregateArgs>(args: Subset<T, BlacklistTypeAggregateArgs>): Prisma.PrismaPromise<GetBlacklistTypeAggregateType<T>>

    /**
     * Group by BlacklistType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistTypeGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlacklistType model
   */
  readonly fields: BlacklistTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlacklistType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlacklistTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blacklists<T extends BlacklistType$blacklistsArgs<ExtArgs> = {}>(args?: Subset<T, BlacklistType$blacklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlacklistType model
   */ 
  interface BlacklistTypeFieldRefs {
    readonly id: FieldRef<"BlacklistType", 'Int'>
    readonly name: FieldRef<"BlacklistType", 'String'>
    readonly description: FieldRef<"BlacklistType", 'String'>
    readonly isActive: FieldRef<"BlacklistType", 'Boolean'>
    readonly updatedAt: FieldRef<"BlacklistType", 'DateTime'>
    readonly createdAt: FieldRef<"BlacklistType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlacklistType findUnique
   */
  export type BlacklistTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistType to fetch.
     */
    where: BlacklistTypeWhereUniqueInput
  }

  /**
   * BlacklistType findUniqueOrThrow
   */
  export type BlacklistTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistType to fetch.
     */
    where: BlacklistTypeWhereUniqueInput
  }

  /**
   * BlacklistType findFirst
   */
  export type BlacklistTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistType to fetch.
     */
    where?: BlacklistTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistTypes to fetch.
     */
    orderBy?: BlacklistTypeOrderByWithRelationInput | BlacklistTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistTypes.
     */
    cursor?: BlacklistTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistTypes.
     */
    distinct?: BlacklistTypeScalarFieldEnum | BlacklistTypeScalarFieldEnum[]
  }

  /**
   * BlacklistType findFirstOrThrow
   */
  export type BlacklistTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistType to fetch.
     */
    where?: BlacklistTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistTypes to fetch.
     */
    orderBy?: BlacklistTypeOrderByWithRelationInput | BlacklistTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistTypes.
     */
    cursor?: BlacklistTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistTypes.
     */
    distinct?: BlacklistTypeScalarFieldEnum | BlacklistTypeScalarFieldEnum[]
  }

  /**
   * BlacklistType findMany
   */
  export type BlacklistTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * Filter, which BlacklistTypes to fetch.
     */
    where?: BlacklistTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistTypes to fetch.
     */
    orderBy?: BlacklistTypeOrderByWithRelationInput | BlacklistTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlacklistTypes.
     */
    cursor?: BlacklistTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistTypes.
     */
    skip?: number
    distinct?: BlacklistTypeScalarFieldEnum | BlacklistTypeScalarFieldEnum[]
  }

  /**
   * BlacklistType create
   */
  export type BlacklistTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BlacklistType.
     */
    data: XOR<BlacklistTypeCreateInput, BlacklistTypeUncheckedCreateInput>
  }

  /**
   * BlacklistType createMany
   */
  export type BlacklistTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlacklistTypes.
     */
    data: BlacklistTypeCreateManyInput | BlacklistTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlacklistType createManyAndReturn
   */
  export type BlacklistTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * The data used to create many BlacklistTypes.
     */
    data: BlacklistTypeCreateManyInput | BlacklistTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlacklistType update
   */
  export type BlacklistTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BlacklistType.
     */
    data: XOR<BlacklistTypeUpdateInput, BlacklistTypeUncheckedUpdateInput>
    /**
     * Choose, which BlacklistType to update.
     */
    where: BlacklistTypeWhereUniqueInput
  }

  /**
   * BlacklistType updateMany
   */
  export type BlacklistTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlacklistTypes.
     */
    data: XOR<BlacklistTypeUpdateManyMutationInput, BlacklistTypeUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistTypes to update
     */
    where?: BlacklistTypeWhereInput
    /**
     * Limit how many BlacklistTypes to update.
     */
    limit?: number
  }

  /**
   * BlacklistType updateManyAndReturn
   */
  export type BlacklistTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * The data used to update BlacklistTypes.
     */
    data: XOR<BlacklistTypeUpdateManyMutationInput, BlacklistTypeUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistTypes to update
     */
    where?: BlacklistTypeWhereInput
    /**
     * Limit how many BlacklistTypes to update.
     */
    limit?: number
  }

  /**
   * BlacklistType upsert
   */
  export type BlacklistTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BlacklistType to update in case it exists.
     */
    where: BlacklistTypeWhereUniqueInput
    /**
     * In case the BlacklistType found by the `where` argument doesn't exist, create a new BlacklistType with this data.
     */
    create: XOR<BlacklistTypeCreateInput, BlacklistTypeUncheckedCreateInput>
    /**
     * In case the BlacklistType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlacklistTypeUpdateInput, BlacklistTypeUncheckedUpdateInput>
  }

  /**
   * BlacklistType delete
   */
  export type BlacklistTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
    /**
     * Filter which BlacklistType to delete.
     */
    where: BlacklistTypeWhereUniqueInput
  }

  /**
   * BlacklistType deleteMany
   */
  export type BlacklistTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistTypes to delete
     */
    where?: BlacklistTypeWhereInput
    /**
     * Limit how many BlacklistTypes to delete.
     */
    limit?: number
  }

  /**
   * BlacklistType.blacklists
   */
  export type BlacklistType$blacklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    where?: BlacklistWhereInput
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    cursor?: BlacklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * BlacklistType without action
   */
  export type BlacklistTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistType
     */
    select?: BlacklistTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistType
     */
    omit?: BlacklistTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistTypeInclude<ExtArgs> | null
  }


  /**
   * Model Blacklist
   */

  export type AggregateBlacklist = {
    _count: BlacklistCountAggregateOutputType | null
    _avg: BlacklistAvgAggregateOutputType | null
    _sum: BlacklistSumAggregateOutputType | null
    _min: BlacklistMinAggregateOutputType | null
    _max: BlacklistMaxAggregateOutputType | null
  }

  export type BlacklistAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    blacklistTypeId: number | null
  }

  export type BlacklistSumAggregateOutputType = {
    id: number | null
    userId: number | null
    blacklistTypeId: number | null
  }

  export type BlacklistMinAggregateOutputType = {
    id: number | null
    userId: number | null
    blacklistTypeId: number | null
    reason: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BlacklistMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    blacklistTypeId: number | null
    reason: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type BlacklistCountAggregateOutputType = {
    id: number
    userId: number
    blacklistTypeId: number
    reason: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type BlacklistAvgAggregateInputType = {
    id?: true
    userId?: true
    blacklistTypeId?: true
  }

  export type BlacklistSumAggregateInputType = {
    id?: true
    userId?: true
    blacklistTypeId?: true
  }

  export type BlacklistMinAggregateInputType = {
    id?: true
    userId?: true
    blacklistTypeId?: true
    reason?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BlacklistMaxAggregateInputType = {
    id?: true
    userId?: true
    blacklistTypeId?: true
    reason?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type BlacklistCountAggregateInputType = {
    id?: true
    userId?: true
    blacklistTypeId?: true
    reason?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BlacklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blacklist to aggregate.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blacklists
    **/
    _count?: true | BlacklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlacklistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlacklistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistMaxAggregateInputType
  }

  export type GetBlacklistAggregateType<T extends BlacklistAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklist[P]>
      : GetScalarType<T[P], AggregateBlacklist[P]>
  }




  export type BlacklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistWhereInput
    orderBy?: BlacklistOrderByWithAggregationInput | BlacklistOrderByWithAggregationInput[]
    by: BlacklistScalarFieldEnum[] | BlacklistScalarFieldEnum
    having?: BlacklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistCountAggregateInputType | true
    _avg?: BlacklistAvgAggregateInputType
    _sum?: BlacklistSumAggregateInputType
    _min?: BlacklistMinAggregateInputType
    _max?: BlacklistMaxAggregateInputType
  }

  export type BlacklistGroupByOutputType = {
    id: number
    userId: number
    blacklistTypeId: number
    reason: string
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: BlacklistCountAggregateOutputType | null
    _avg: BlacklistAvgAggregateOutputType | null
    _sum: BlacklistSumAggregateOutputType | null
    _min: BlacklistMinAggregateOutputType | null
    _max: BlacklistMaxAggregateOutputType | null
  }

  type GetBlacklistGroupByPayload<T extends BlacklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blacklistTypeId?: boolean
    reason?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blacklistType?: boolean | BlacklistTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklist"]>

  export type BlacklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blacklistTypeId?: boolean
    reason?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blacklistType?: boolean | BlacklistTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklist"]>

  export type BlacklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    blacklistTypeId?: boolean
    reason?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    blacklistType?: boolean | BlacklistTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blacklist"]>

  export type BlacklistSelectScalar = {
    id?: boolean
    userId?: boolean
    blacklistTypeId?: boolean
    reason?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type BlacklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "blacklistTypeId" | "reason" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["blacklist"]>
  export type BlacklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blacklistType?: boolean | BlacklistTypeDefaultArgs<ExtArgs>
  }
  export type BlacklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blacklistType?: boolean | BlacklistTypeDefaultArgs<ExtArgs>
  }
  export type BlacklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    blacklistType?: boolean | BlacklistTypeDefaultArgs<ExtArgs>
  }

  export type $BlacklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blacklist"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      blacklistType: Prisma.$BlacklistTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      blacklistTypeId: number
      reason: string
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["blacklist"]>
    composites: {}
  }

  type BlacklistGetPayload<S extends boolean | null | undefined | BlacklistDefaultArgs> = $Result.GetResult<Prisma.$BlacklistPayload, S>

  type BlacklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlacklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlacklistCountAggregateInputType | true
    }

  export interface BlacklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blacklist'], meta: { name: 'Blacklist' } }
    /**
     * Find zero or one Blacklist that matches the filter.
     * @param {BlacklistFindUniqueArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlacklistFindUniqueArgs>(args: SelectSubset<T, BlacklistFindUniqueArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blacklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlacklistFindUniqueOrThrowArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlacklistFindUniqueOrThrowArgs>(args: SelectSubset<T, BlacklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blacklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindFirstArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlacklistFindFirstArgs>(args?: SelectSubset<T, BlacklistFindFirstArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blacklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindFirstOrThrowArgs} args - Arguments to find a Blacklist
     * @example
     * // Get one Blacklist
     * const blacklist = await prisma.blacklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlacklistFindFirstOrThrowArgs>(args?: SelectSubset<T, BlacklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blacklists
     * const blacklists = await prisma.blacklist.findMany()
     * 
     * // Get first 10 Blacklists
     * const blacklists = await prisma.blacklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlacklistFindManyArgs>(args?: SelectSubset<T, BlacklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blacklist.
     * @param {BlacklistCreateArgs} args - Arguments to create a Blacklist.
     * @example
     * // Create one Blacklist
     * const Blacklist = await prisma.blacklist.create({
     *   data: {
     *     // ... data to create a Blacklist
     *   }
     * })
     * 
     */
    create<T extends BlacklistCreateArgs>(args: SelectSubset<T, BlacklistCreateArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blacklists.
     * @param {BlacklistCreateManyArgs} args - Arguments to create many Blacklists.
     * @example
     * // Create many Blacklists
     * const blacklist = await prisma.blacklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlacklistCreateManyArgs>(args?: SelectSubset<T, BlacklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blacklists and returns the data saved in the database.
     * @param {BlacklistCreateManyAndReturnArgs} args - Arguments to create many Blacklists.
     * @example
     * // Create many Blacklists
     * const blacklist = await prisma.blacklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blacklists and only return the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlacklistCreateManyAndReturnArgs>(args?: SelectSubset<T, BlacklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blacklist.
     * @param {BlacklistDeleteArgs} args - Arguments to delete one Blacklist.
     * @example
     * // Delete one Blacklist
     * const Blacklist = await prisma.blacklist.delete({
     *   where: {
     *     // ... filter to delete one Blacklist
     *   }
     * })
     * 
     */
    delete<T extends BlacklistDeleteArgs>(args: SelectSubset<T, BlacklistDeleteArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blacklist.
     * @param {BlacklistUpdateArgs} args - Arguments to update one Blacklist.
     * @example
     * // Update one Blacklist
     * const blacklist = await prisma.blacklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlacklistUpdateArgs>(args: SelectSubset<T, BlacklistUpdateArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blacklists.
     * @param {BlacklistDeleteManyArgs} args - Arguments to filter Blacklists to delete.
     * @example
     * // Delete a few Blacklists
     * const { count } = await prisma.blacklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlacklistDeleteManyArgs>(args?: SelectSubset<T, BlacklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blacklists
     * const blacklist = await prisma.blacklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlacklistUpdateManyArgs>(args: SelectSubset<T, BlacklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blacklists and returns the data updated in the database.
     * @param {BlacklistUpdateManyAndReturnArgs} args - Arguments to update many Blacklists.
     * @example
     * // Update many Blacklists
     * const blacklist = await prisma.blacklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blacklists and only return the `id`
     * const blacklistWithIdOnly = await prisma.blacklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlacklistUpdateManyAndReturnArgs>(args: SelectSubset<T, BlacklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blacklist.
     * @param {BlacklistUpsertArgs} args - Arguments to update or create a Blacklist.
     * @example
     * // Update or create a Blacklist
     * const blacklist = await prisma.blacklist.upsert({
     *   create: {
     *     // ... data to create a Blacklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blacklist we want to update
     *   }
     * })
     */
    upsert<T extends BlacklistUpsertArgs>(args: SelectSubset<T, BlacklistUpsertArgs<ExtArgs>>): Prisma__BlacklistClient<$Result.GetResult<Prisma.$BlacklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistCountArgs} args - Arguments to filter Blacklists to count.
     * @example
     * // Count the number of Blacklists
     * const count = await prisma.blacklist.count({
     *   where: {
     *     // ... the filter for the Blacklists we want to count
     *   }
     * })
    **/
    count<T extends BlacklistCountArgs>(
      args?: Subset<T, BlacklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistAggregateArgs>(args: Subset<T, BlacklistAggregateArgs>): Prisma.PrismaPromise<GetBlacklistAggregateType<T>>

    /**
     * Group by Blacklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blacklist model
   */
  readonly fields: BlacklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blacklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlacklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blacklistType<T extends BlacklistTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlacklistTypeDefaultArgs<ExtArgs>>): Prisma__BlacklistTypeClient<$Result.GetResult<Prisma.$BlacklistTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blacklist model
   */ 
  interface BlacklistFieldRefs {
    readonly id: FieldRef<"Blacklist", 'Int'>
    readonly userId: FieldRef<"Blacklist", 'Int'>
    readonly blacklistTypeId: FieldRef<"Blacklist", 'Int'>
    readonly reason: FieldRef<"Blacklist", 'String'>
    readonly isActive: FieldRef<"Blacklist", 'Boolean'>
    readonly updatedAt: FieldRef<"Blacklist", 'DateTime'>
    readonly createdAt: FieldRef<"Blacklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blacklist findUnique
   */
  export type BlacklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where: BlacklistWhereUniqueInput
  }

  /**
   * Blacklist findUniqueOrThrow
   */
  export type BlacklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where: BlacklistWhereUniqueInput
  }

  /**
   * Blacklist findFirst
   */
  export type BlacklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blacklists.
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blacklists.
     */
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * Blacklist findFirstOrThrow
   */
  export type BlacklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklist to fetch.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blacklists.
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blacklists.
     */
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * Blacklist findMany
   */
  export type BlacklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter, which Blacklists to fetch.
     */
    where?: BlacklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blacklists to fetch.
     */
    orderBy?: BlacklistOrderByWithRelationInput | BlacklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blacklists.
     */
    cursor?: BlacklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blacklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blacklists.
     */
    skip?: number
    distinct?: BlacklistScalarFieldEnum | BlacklistScalarFieldEnum[]
  }

  /**
   * Blacklist create
   */
  export type BlacklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * The data needed to create a Blacklist.
     */
    data: XOR<BlacklistCreateInput, BlacklistUncheckedCreateInput>
  }

  /**
   * Blacklist createMany
   */
  export type BlacklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blacklists.
     */
    data: BlacklistCreateManyInput | BlacklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Blacklist createManyAndReturn
   */
  export type BlacklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * The data used to create many Blacklists.
     */
    data: BlacklistCreateManyInput | BlacklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blacklist update
   */
  export type BlacklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * The data needed to update a Blacklist.
     */
    data: XOR<BlacklistUpdateInput, BlacklistUncheckedUpdateInput>
    /**
     * Choose, which Blacklist to update.
     */
    where: BlacklistWhereUniqueInput
  }

  /**
   * Blacklist updateMany
   */
  export type BlacklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blacklists.
     */
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyInput>
    /**
     * Filter which Blacklists to update
     */
    where?: BlacklistWhereInput
    /**
     * Limit how many Blacklists to update.
     */
    limit?: number
  }

  /**
   * Blacklist updateManyAndReturn
   */
  export type BlacklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * The data used to update Blacklists.
     */
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyInput>
    /**
     * Filter which Blacklists to update
     */
    where?: BlacklistWhereInput
    /**
     * Limit how many Blacklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Blacklist upsert
   */
  export type BlacklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * The filter to search for the Blacklist to update in case it exists.
     */
    where: BlacklistWhereUniqueInput
    /**
     * In case the Blacklist found by the `where` argument doesn't exist, create a new Blacklist with this data.
     */
    create: XOR<BlacklistCreateInput, BlacklistUncheckedCreateInput>
    /**
     * In case the Blacklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlacklistUpdateInput, BlacklistUncheckedUpdateInput>
  }

  /**
   * Blacklist delete
   */
  export type BlacklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
    /**
     * Filter which Blacklist to delete.
     */
    where: BlacklistWhereUniqueInput
  }

  /**
   * Blacklist deleteMany
   */
  export type BlacklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blacklists to delete
     */
    where?: BlacklistWhereInput
    /**
     * Limit how many Blacklists to delete.
     */
    limit?: number
  }

  /**
   * Blacklist without action
   */
  export type BlacklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blacklist
     */
    select?: BlacklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blacklist
     */
    omit?: BlacklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlacklistInclude<ExtArgs> | null
  }


  /**
   * Model UserPhoneType
   */

  export type AggregateUserPhoneType = {
    _count: UserPhoneTypeCountAggregateOutputType | null
    _avg: UserPhoneTypeAvgAggregateOutputType | null
    _sum: UserPhoneTypeSumAggregateOutputType | null
    _min: UserPhoneTypeMinAggregateOutputType | null
    _max: UserPhoneTypeMaxAggregateOutputType | null
  }

  export type UserPhoneTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type UserPhoneTypeSumAggregateOutputType = {
    id: number | null
  }

  export type UserPhoneTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserPhoneTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserPhoneTypeCountAggregateOutputType = {
    id: number
    type: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type UserPhoneTypeAvgAggregateInputType = {
    id?: true
  }

  export type UserPhoneTypeSumAggregateInputType = {
    id?: true
  }

  export type UserPhoneTypeMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserPhoneTypeMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserPhoneTypeCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserPhoneTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhoneType to aggregate.
     */
    where?: UserPhoneTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhoneTypes to fetch.
     */
    orderBy?: UserPhoneTypeOrderByWithRelationInput | UserPhoneTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhoneTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhoneTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhoneTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhoneTypes
    **/
    _count?: true | UserPhoneTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhoneTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhoneTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhoneTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhoneTypeMaxAggregateInputType
  }

  export type GetUserPhoneTypeAggregateType<T extends UserPhoneTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhoneType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhoneType[P]>
      : GetScalarType<T[P], AggregateUserPhoneType[P]>
  }




  export type UserPhoneTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneTypeWhereInput
    orderBy?: UserPhoneTypeOrderByWithAggregationInput | UserPhoneTypeOrderByWithAggregationInput[]
    by: UserPhoneTypeScalarFieldEnum[] | UserPhoneTypeScalarFieldEnum
    having?: UserPhoneTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhoneTypeCountAggregateInputType | true
    _avg?: UserPhoneTypeAvgAggregateInputType
    _sum?: UserPhoneTypeSumAggregateInputType
    _min?: UserPhoneTypeMinAggregateInputType
    _max?: UserPhoneTypeMaxAggregateInputType
  }

  export type UserPhoneTypeGroupByOutputType = {
    id: number
    type: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: UserPhoneTypeCountAggregateOutputType | null
    _avg: UserPhoneTypeAvgAggregateOutputType | null
    _sum: UserPhoneTypeSumAggregateOutputType | null
    _min: UserPhoneTypeMinAggregateOutputType | null
    _max: UserPhoneTypeMaxAggregateOutputType | null
  }

  type GetUserPhoneTypeGroupByPayload<T extends UserPhoneTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhoneTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhoneTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhoneTypeGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhoneTypeGroupByOutputType[P]>
        }
      >
    >


  export type UserPhoneTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    userPhones?: boolean | UserPhoneType$userPhonesArgs<ExtArgs>
    _count?: boolean | UserPhoneTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhoneType"]>

  export type UserPhoneTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userPhoneType"]>

  export type UserPhoneTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userPhoneType"]>

  export type UserPhoneTypeSelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type UserPhoneTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["userPhoneType"]>
  export type UserPhoneTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPhones?: boolean | UserPhoneType$userPhonesArgs<ExtArgs>
    _count?: boolean | UserPhoneTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserPhoneTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserPhoneTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPhoneTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhoneType"
    objects: {
      userPhones: Prisma.$UserPhonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userPhoneType"]>
    composites: {}
  }

  type UserPhoneTypeGetPayload<S extends boolean | null | undefined | UserPhoneTypeDefaultArgs> = $Result.GetResult<Prisma.$UserPhoneTypePayload, S>

  type UserPhoneTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPhoneTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPhoneTypeCountAggregateInputType | true
    }

  export interface UserPhoneTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhoneType'], meta: { name: 'UserPhoneType' } }
    /**
     * Find zero or one UserPhoneType that matches the filter.
     * @param {UserPhoneTypeFindUniqueArgs} args - Arguments to find a UserPhoneType
     * @example
     * // Get one UserPhoneType
     * const userPhoneType = await prisma.userPhoneType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhoneTypeFindUniqueArgs>(args: SelectSubset<T, UserPhoneTypeFindUniqueArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPhoneType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPhoneTypeFindUniqueOrThrowArgs} args - Arguments to find a UserPhoneType
     * @example
     * // Get one UserPhoneType
     * const userPhoneType = await prisma.userPhoneType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhoneTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhoneTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhoneType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeFindFirstArgs} args - Arguments to find a UserPhoneType
     * @example
     * // Get one UserPhoneType
     * const userPhoneType = await prisma.userPhoneType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhoneTypeFindFirstArgs>(args?: SelectSubset<T, UserPhoneTypeFindFirstArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhoneType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeFindFirstOrThrowArgs} args - Arguments to find a UserPhoneType
     * @example
     * // Get one UserPhoneType
     * const userPhoneType = await prisma.userPhoneType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhoneTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhoneTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhoneTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhoneTypes
     * const userPhoneTypes = await prisma.userPhoneType.findMany()
     * 
     * // Get first 10 UserPhoneTypes
     * const userPhoneTypes = await prisma.userPhoneType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhoneTypeWithIdOnly = await prisma.userPhoneType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhoneTypeFindManyArgs>(args?: SelectSubset<T, UserPhoneTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPhoneType.
     * @param {UserPhoneTypeCreateArgs} args - Arguments to create a UserPhoneType.
     * @example
     * // Create one UserPhoneType
     * const UserPhoneType = await prisma.userPhoneType.create({
     *   data: {
     *     // ... data to create a UserPhoneType
     *   }
     * })
     * 
     */
    create<T extends UserPhoneTypeCreateArgs>(args: SelectSubset<T, UserPhoneTypeCreateArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPhoneTypes.
     * @param {UserPhoneTypeCreateManyArgs} args - Arguments to create many UserPhoneTypes.
     * @example
     * // Create many UserPhoneTypes
     * const userPhoneType = await prisma.userPhoneType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhoneTypeCreateManyArgs>(args?: SelectSubset<T, UserPhoneTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPhoneTypes and returns the data saved in the database.
     * @param {UserPhoneTypeCreateManyAndReturnArgs} args - Arguments to create many UserPhoneTypes.
     * @example
     * // Create many UserPhoneTypes
     * const userPhoneType = await prisma.userPhoneType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPhoneTypes and only return the `id`
     * const userPhoneTypeWithIdOnly = await prisma.userPhoneType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPhoneTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPhoneTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPhoneType.
     * @param {UserPhoneTypeDeleteArgs} args - Arguments to delete one UserPhoneType.
     * @example
     * // Delete one UserPhoneType
     * const UserPhoneType = await prisma.userPhoneType.delete({
     *   where: {
     *     // ... filter to delete one UserPhoneType
     *   }
     * })
     * 
     */
    delete<T extends UserPhoneTypeDeleteArgs>(args: SelectSubset<T, UserPhoneTypeDeleteArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPhoneType.
     * @param {UserPhoneTypeUpdateArgs} args - Arguments to update one UserPhoneType.
     * @example
     * // Update one UserPhoneType
     * const userPhoneType = await prisma.userPhoneType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhoneTypeUpdateArgs>(args: SelectSubset<T, UserPhoneTypeUpdateArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPhoneTypes.
     * @param {UserPhoneTypeDeleteManyArgs} args - Arguments to filter UserPhoneTypes to delete.
     * @example
     * // Delete a few UserPhoneTypes
     * const { count } = await prisma.userPhoneType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhoneTypeDeleteManyArgs>(args?: SelectSubset<T, UserPhoneTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhoneTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhoneTypes
     * const userPhoneType = await prisma.userPhoneType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhoneTypeUpdateManyArgs>(args: SelectSubset<T, UserPhoneTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhoneTypes and returns the data updated in the database.
     * @param {UserPhoneTypeUpdateManyAndReturnArgs} args - Arguments to update many UserPhoneTypes.
     * @example
     * // Update many UserPhoneTypes
     * const userPhoneType = await prisma.userPhoneType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPhoneTypes and only return the `id`
     * const userPhoneTypeWithIdOnly = await prisma.userPhoneType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPhoneTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPhoneTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPhoneType.
     * @param {UserPhoneTypeUpsertArgs} args - Arguments to update or create a UserPhoneType.
     * @example
     * // Update or create a UserPhoneType
     * const userPhoneType = await prisma.userPhoneType.upsert({
     *   create: {
     *     // ... data to create a UserPhoneType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhoneType we want to update
     *   }
     * })
     */
    upsert<T extends UserPhoneTypeUpsertArgs>(args: SelectSubset<T, UserPhoneTypeUpsertArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPhoneTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeCountArgs} args - Arguments to filter UserPhoneTypes to count.
     * @example
     * // Count the number of UserPhoneTypes
     * const count = await prisma.userPhoneType.count({
     *   where: {
     *     // ... the filter for the UserPhoneTypes we want to count
     *   }
     * })
    **/
    count<T extends UserPhoneTypeCountArgs>(
      args?: Subset<T, UserPhoneTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhoneTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhoneType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhoneTypeAggregateArgs>(args: Subset<T, UserPhoneTypeAggregateArgs>): Prisma.PrismaPromise<GetUserPhoneTypeAggregateType<T>>

    /**
     * Group by UserPhoneType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhoneTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhoneTypeGroupByArgs['orderBy'] }
        : { orderBy?: UserPhoneTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhoneTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhoneTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhoneType model
   */
  readonly fields: UserPhoneTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhoneType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhoneTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userPhones<T extends UserPhoneType$userPhonesArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoneType$userPhonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhoneType model
   */ 
  interface UserPhoneTypeFieldRefs {
    readonly id: FieldRef<"UserPhoneType", 'Int'>
    readonly type: FieldRef<"UserPhoneType", 'String'>
    readonly description: FieldRef<"UserPhoneType", 'String'>
    readonly isActive: FieldRef<"UserPhoneType", 'Boolean'>
    readonly updatedAt: FieldRef<"UserPhoneType", 'DateTime'>
    readonly createdAt: FieldRef<"UserPhoneType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhoneType findUnique
   */
  export type UserPhoneTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoneType to fetch.
     */
    where: UserPhoneTypeWhereUniqueInput
  }

  /**
   * UserPhoneType findUniqueOrThrow
   */
  export type UserPhoneTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoneType to fetch.
     */
    where: UserPhoneTypeWhereUniqueInput
  }

  /**
   * UserPhoneType findFirst
   */
  export type UserPhoneTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoneType to fetch.
     */
    where?: UserPhoneTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhoneTypes to fetch.
     */
    orderBy?: UserPhoneTypeOrderByWithRelationInput | UserPhoneTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhoneTypes.
     */
    cursor?: UserPhoneTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhoneTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhoneTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhoneTypes.
     */
    distinct?: UserPhoneTypeScalarFieldEnum | UserPhoneTypeScalarFieldEnum[]
  }

  /**
   * UserPhoneType findFirstOrThrow
   */
  export type UserPhoneTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoneType to fetch.
     */
    where?: UserPhoneTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhoneTypes to fetch.
     */
    orderBy?: UserPhoneTypeOrderByWithRelationInput | UserPhoneTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhoneTypes.
     */
    cursor?: UserPhoneTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhoneTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhoneTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhoneTypes.
     */
    distinct?: UserPhoneTypeScalarFieldEnum | UserPhoneTypeScalarFieldEnum[]
  }

  /**
   * UserPhoneType findMany
   */
  export type UserPhoneTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * Filter, which UserPhoneTypes to fetch.
     */
    where?: UserPhoneTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhoneTypes to fetch.
     */
    orderBy?: UserPhoneTypeOrderByWithRelationInput | UserPhoneTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhoneTypes.
     */
    cursor?: UserPhoneTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhoneTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhoneTypes.
     */
    skip?: number
    distinct?: UserPhoneTypeScalarFieldEnum | UserPhoneTypeScalarFieldEnum[]
  }

  /**
   * UserPhoneType create
   */
  export type UserPhoneTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhoneType.
     */
    data: XOR<UserPhoneTypeCreateInput, UserPhoneTypeUncheckedCreateInput>
  }

  /**
   * UserPhoneType createMany
   */
  export type UserPhoneTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhoneTypes.
     */
    data: UserPhoneTypeCreateManyInput | UserPhoneTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPhoneType createManyAndReturn
   */
  export type UserPhoneTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * The data used to create many UserPhoneTypes.
     */
    data: UserPhoneTypeCreateManyInput | UserPhoneTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPhoneType update
   */
  export type UserPhoneTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhoneType.
     */
    data: XOR<UserPhoneTypeUpdateInput, UserPhoneTypeUncheckedUpdateInput>
    /**
     * Choose, which UserPhoneType to update.
     */
    where: UserPhoneTypeWhereUniqueInput
  }

  /**
   * UserPhoneType updateMany
   */
  export type UserPhoneTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhoneTypes.
     */
    data: XOR<UserPhoneTypeUpdateManyMutationInput, UserPhoneTypeUncheckedUpdateManyInput>
    /**
     * Filter which UserPhoneTypes to update
     */
    where?: UserPhoneTypeWhereInput
    /**
     * Limit how many UserPhoneTypes to update.
     */
    limit?: number
  }

  /**
   * UserPhoneType updateManyAndReturn
   */
  export type UserPhoneTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * The data used to update UserPhoneTypes.
     */
    data: XOR<UserPhoneTypeUpdateManyMutationInput, UserPhoneTypeUncheckedUpdateManyInput>
    /**
     * Filter which UserPhoneTypes to update
     */
    where?: UserPhoneTypeWhereInput
    /**
     * Limit how many UserPhoneTypes to update.
     */
    limit?: number
  }

  /**
   * UserPhoneType upsert
   */
  export type UserPhoneTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhoneType to update in case it exists.
     */
    where: UserPhoneTypeWhereUniqueInput
    /**
     * In case the UserPhoneType found by the `where` argument doesn't exist, create a new UserPhoneType with this data.
     */
    create: XOR<UserPhoneTypeCreateInput, UserPhoneTypeUncheckedCreateInput>
    /**
     * In case the UserPhoneType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhoneTypeUpdateInput, UserPhoneTypeUncheckedUpdateInput>
  }

  /**
   * UserPhoneType delete
   */
  export type UserPhoneTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
    /**
     * Filter which UserPhoneType to delete.
     */
    where: UserPhoneTypeWhereUniqueInput
  }

  /**
   * UserPhoneType deleteMany
   */
  export type UserPhoneTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhoneTypes to delete
     */
    where?: UserPhoneTypeWhereInput
    /**
     * Limit how many UserPhoneTypes to delete.
     */
    limit?: number
  }

  /**
   * UserPhoneType.userPhones
   */
  export type UserPhoneType$userPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    where?: UserPhoneWhereInput
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    cursor?: UserPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhoneType without action
   */
  export type UserPhoneTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhoneType
     */
    select?: UserPhoneTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhoneType
     */
    omit?: UserPhoneTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneTypeInclude<ExtArgs> | null
  }


  /**
   * Model UserPhone
   */

  export type AggregateUserPhone = {
    _count: UserPhoneCountAggregateOutputType | null
    _avg: UserPhoneAvgAggregateOutputType | null
    _sum: UserPhoneSumAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  export type UserPhoneAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    userPhoneTypeId: number | null
  }

  export type UserPhoneSumAggregateOutputType = {
    id: number | null
    userId: number | null
    userPhoneTypeId: number | null
  }

  export type UserPhoneMinAggregateOutputType = {
    id: number | null
    userId: number | null
    userPhoneTypeId: number | null
    phoneNumberKms: string | null
    isPrincipal: boolean | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserPhoneMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    userPhoneTypeId: number | null
    phoneNumberKms: string | null
    isPrincipal: boolean | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserPhoneCountAggregateOutputType = {
    id: number
    userId: number
    userPhoneTypeId: number
    phoneNumberKms: number
    isPrincipal: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type UserPhoneAvgAggregateInputType = {
    id?: true
    userId?: true
    userPhoneTypeId?: true
  }

  export type UserPhoneSumAggregateInputType = {
    id?: true
    userId?: true
    userPhoneTypeId?: true
  }

  export type UserPhoneMinAggregateInputType = {
    id?: true
    userId?: true
    userPhoneTypeId?: true
    phoneNumberKms?: true
    isPrincipal?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserPhoneMaxAggregateInputType = {
    id?: true
    userId?: true
    userPhoneTypeId?: true
    phoneNumberKms?: true
    isPrincipal?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserPhoneCountAggregateInputType = {
    id?: true
    userId?: true
    userPhoneTypeId?: true
    phoneNumberKms?: true
    isPrincipal?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserPhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhone to aggregate.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhones
    **/
    _count?: true | UserPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPhoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPhoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhoneMaxAggregateInputType
  }

  export type GetUserPhoneAggregateType<T extends UserPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhone[P]>
      : GetScalarType<T[P], AggregateUserPhone[P]>
  }




  export type UserPhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPhoneWhereInput
    orderBy?: UserPhoneOrderByWithAggregationInput | UserPhoneOrderByWithAggregationInput[]
    by: UserPhoneScalarFieldEnum[] | UserPhoneScalarFieldEnum
    having?: UserPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhoneCountAggregateInputType | true
    _avg?: UserPhoneAvgAggregateInputType
    _sum?: UserPhoneSumAggregateInputType
    _min?: UserPhoneMinAggregateInputType
    _max?: UserPhoneMaxAggregateInputType
  }

  export type UserPhoneGroupByOutputType = {
    id: number
    userId: number
    userPhoneTypeId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: UserPhoneCountAggregateOutputType | null
    _avg: UserPhoneAvgAggregateOutputType | null
    _sum: UserPhoneSumAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  type GetUserPhoneGroupByPayload<T extends UserPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
        }
      >
    >


  export type UserPhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userPhoneTypeId?: boolean
    phoneNumberKms?: boolean
    isPrincipal?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    phoneType?: boolean | UserPhoneTypeDefaultArgs<ExtArgs>
    services?: boolean | UserPhone$servicesArgs<ExtArgs>
    _count?: boolean | UserPhoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userPhoneTypeId?: boolean
    phoneNumberKms?: boolean
    isPrincipal?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    phoneType?: boolean | UserPhoneTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userPhoneTypeId?: boolean
    phoneNumberKms?: boolean
    isPrincipal?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    phoneType?: boolean | UserPhoneTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPhone"]>

  export type UserPhoneSelectScalar = {
    id?: boolean
    userId?: boolean
    userPhoneTypeId?: boolean
    phoneNumberKms?: boolean
    isPrincipal?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type UserPhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userPhoneTypeId" | "phoneNumberKms" | "isPrincipal" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["userPhone"]>
  export type UserPhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    phoneType?: boolean | UserPhoneTypeDefaultArgs<ExtArgs>
    services?: boolean | UserPhone$servicesArgs<ExtArgs>
    _count?: boolean | UserPhoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserPhoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    phoneType?: boolean | UserPhoneTypeDefaultArgs<ExtArgs>
  }
  export type UserPhoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    phoneType?: boolean | UserPhoneTypeDefaultArgs<ExtArgs>
  }

  export type $UserPhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPhone"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      phoneType: Prisma.$UserPhoneTypePayload<ExtArgs>
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      userPhoneTypeId: number
      phoneNumberKms: string
      isPrincipal: boolean
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["userPhone"]>
    composites: {}
  }

  type UserPhoneGetPayload<S extends boolean | null | undefined | UserPhoneDefaultArgs> = $Result.GetResult<Prisma.$UserPhonePayload, S>

  type UserPhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPhoneCountAggregateInputType | true
    }

  export interface UserPhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPhone'], meta: { name: 'UserPhone' } }
    /**
     * Find zero or one UserPhone that matches the filter.
     * @param {UserPhoneFindUniqueArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPhoneFindUniqueArgs>(args: SelectSubset<T, UserPhoneFindUniqueArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPhoneFindUniqueOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPhoneFindFirstArgs>(args?: SelectSubset<T, UserPhoneFindFirstArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhones
     * const userPhones = await prisma.userPhone.findMany()
     * 
     * // Get first 10 UserPhones
     * const userPhones = await prisma.userPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPhoneFindManyArgs>(args?: SelectSubset<T, UserPhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPhone.
     * @param {UserPhoneCreateArgs} args - Arguments to create a UserPhone.
     * @example
     * // Create one UserPhone
     * const UserPhone = await prisma.userPhone.create({
     *   data: {
     *     // ... data to create a UserPhone
     *   }
     * })
     * 
     */
    create<T extends UserPhoneCreateArgs>(args: SelectSubset<T, UserPhoneCreateArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPhones.
     * @param {UserPhoneCreateManyArgs} args - Arguments to create many UserPhones.
     * @example
     * // Create many UserPhones
     * const userPhone = await prisma.userPhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPhoneCreateManyArgs>(args?: SelectSubset<T, UserPhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPhones and returns the data saved in the database.
     * @param {UserPhoneCreateManyAndReturnArgs} args - Arguments to create many UserPhones.
     * @example
     * // Create many UserPhones
     * const userPhone = await prisma.userPhone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPhones and only return the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPhoneCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPhoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPhone.
     * @param {UserPhoneDeleteArgs} args - Arguments to delete one UserPhone.
     * @example
     * // Delete one UserPhone
     * const UserPhone = await prisma.userPhone.delete({
     *   where: {
     *     // ... filter to delete one UserPhone
     *   }
     * })
     * 
     */
    delete<T extends UserPhoneDeleteArgs>(args: SelectSubset<T, UserPhoneDeleteArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPhone.
     * @param {UserPhoneUpdateArgs} args - Arguments to update one UserPhone.
     * @example
     * // Update one UserPhone
     * const userPhone = await prisma.userPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPhoneUpdateArgs>(args: SelectSubset<T, UserPhoneUpdateArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPhones.
     * @param {UserPhoneDeleteManyArgs} args - Arguments to filter UserPhones to delete.
     * @example
     * // Delete a few UserPhones
     * const { count } = await prisma.userPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPhoneDeleteManyArgs>(args?: SelectSubset<T, UserPhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPhoneUpdateManyArgs>(args: SelectSubset<T, UserPhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones and returns the data updated in the database.
     * @param {UserPhoneUpdateManyAndReturnArgs} args - Arguments to update many UserPhones.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPhones and only return the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPhoneUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPhoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPhone.
     * @param {UserPhoneUpsertArgs} args - Arguments to update or create a UserPhone.
     * @example
     * // Update or create a UserPhone
     * const userPhone = await prisma.userPhone.upsert({
     *   create: {
     *     // ... data to create a UserPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhone we want to update
     *   }
     * })
     */
    upsert<T extends UserPhoneUpsertArgs>(args: SelectSubset<T, UserPhoneUpsertArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneCountArgs} args - Arguments to filter UserPhones to count.
     * @example
     * // Count the number of UserPhones
     * const count = await prisma.userPhone.count({
     *   where: {
     *     // ... the filter for the UserPhones we want to count
     *   }
     * })
    **/
    count<T extends UserPhoneCountArgs>(
      args?: Subset<T, UserPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhoneAggregateArgs>(args: Subset<T, UserPhoneAggregateArgs>): Prisma.PrismaPromise<GetUserPhoneAggregateType<T>>

    /**
     * Group by UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhoneGroupByArgs['orderBy'] }
        : { orderBy?: UserPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPhone model
   */
  readonly fields: UserPhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    phoneType<T extends UserPhoneTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoneTypeDefaultArgs<ExtArgs>>): Prisma__UserPhoneTypeClient<$Result.GetResult<Prisma.$UserPhoneTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends UserPhone$servicesArgs<ExtArgs> = {}>(args?: Subset<T, UserPhone$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPhone model
   */ 
  interface UserPhoneFieldRefs {
    readonly id: FieldRef<"UserPhone", 'Int'>
    readonly userId: FieldRef<"UserPhone", 'Int'>
    readonly userPhoneTypeId: FieldRef<"UserPhone", 'Int'>
    readonly phoneNumberKms: FieldRef<"UserPhone", 'String'>
    readonly isPrincipal: FieldRef<"UserPhone", 'Boolean'>
    readonly isActive: FieldRef<"UserPhone", 'Boolean'>
    readonly updatedAt: FieldRef<"UserPhone", 'DateTime'>
    readonly createdAt: FieldRef<"UserPhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPhone findUnique
   */
  export type UserPhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findUniqueOrThrow
   */
  export type UserPhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findFirst
   */
  export type UserPhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone findFirstOrThrow
   */
  export type UserPhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone findMany
   */
  export type UserPhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter, which UserPhones to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: UserPhoneOrderByWithRelationInput | UserPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    distinct?: UserPhoneScalarFieldEnum | UserPhoneScalarFieldEnum[]
  }

  /**
   * UserPhone create
   */
  export type UserPhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPhone.
     */
    data: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
  }

  /**
   * UserPhone createMany
   */
  export type UserPhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPhones.
     */
    data: UserPhoneCreateManyInput | UserPhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPhone createManyAndReturn
   */
  export type UserPhoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * The data used to create many UserPhones.
     */
    data: UserPhoneCreateManyInput | UserPhoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhone update
   */
  export type UserPhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPhone.
     */
    data: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
    /**
     * Choose, which UserPhone to update.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone updateMany
   */
  export type UserPhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to update.
     */
    limit?: number
  }

  /**
   * UserPhone updateManyAndReturn
   */
  export type UserPhoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPhone upsert
   */
  export type UserPhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPhone to update in case it exists.
     */
    where: UserPhoneWhereUniqueInput
    /**
     * In case the UserPhone found by the `where` argument doesn't exist, create a new UserPhone with this data.
     */
    create: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
    /**
     * In case the UserPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
  }

  /**
   * UserPhone delete
   */
  export type UserPhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
    /**
     * Filter which UserPhone to delete.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone deleteMany
   */
  export type UserPhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPhones to delete
     */
    where?: UserPhoneWhereInput
    /**
     * Limit how many UserPhones to delete.
     */
    limit?: number
  }

  /**
   * UserPhone.services
   */
  export type UserPhone$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * UserPhone without action
   */
  export type UserPhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPhone
     */
    omit?: UserPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPhoneInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    id: number | null
  }

  export type CurrencySumAggregateOutputType = {
    id: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    symbol: string | null
    iso4217Code: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    symbol: string | null
    iso4217Code: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    symbol: number
    iso4217Code: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    id?: true
  }

  export type CurrencySumAggregateInputType = {
    id?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    symbol?: true
    iso4217Code?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    symbol?: true
    iso4217Code?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    symbol?: true
    iso4217Code?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: number
    name: string
    description: string | null
    symbol: string
    iso4217Code: string
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    iso4217Code?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    products?: boolean | Currency$productsArgs<ExtArgs>
    services?: boolean | Currency$servicesArgs<ExtArgs>
    serviceDetails?: boolean | Currency$serviceDetailsArgs<ExtArgs>
    serviceExtras?: boolean | Currency$serviceExtrasArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    iso4217Code?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    iso4217Code?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    symbol?: boolean
    iso4217Code?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "symbol" | "iso4217Code" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Currency$productsArgs<ExtArgs>
    services?: boolean | Currency$servicesArgs<ExtArgs>
    serviceDetails?: boolean | Currency$serviceDetailsArgs<ExtArgs>
    serviceExtras?: boolean | Currency$serviceExtrasArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      serviceDetails: Prisma.$ServiceDetailPayload<ExtArgs>[]
      serviceExtras: Prisma.$ServiceExtraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      symbol: string
      iso4217Code: string
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Currency$productsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Currency$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Currency$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceDetails<T extends Currency$serviceDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$serviceDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceExtras<T extends Currency$serviceExtrasArgs<ExtArgs> = {}>(args?: Subset<T, Currency$serviceExtrasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */ 
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'Int'>
    readonly name: FieldRef<"Currency", 'String'>
    readonly description: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly iso4217Code: FieldRef<"Currency", 'String'>
    readonly isActive: FieldRef<"Currency", 'Boolean'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.products
   */
  export type Currency$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Currency.services
   */
  export type Currency$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Currency.serviceDetails
   */
  export type Currency$serviceDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    where?: ServiceDetailWhereInput
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    cursor?: ServiceDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceDetailScalarFieldEnum | ServiceDetailScalarFieldEnum[]
  }

  /**
   * Currency.serviceExtras
   */
  export type Currency$serviceExtrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    where?: ServiceExtraWhereInput
    orderBy?: ServiceExtraOrderByWithRelationInput | ServiceExtraOrderByWithRelationInput[]
    cursor?: ServiceExtraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceExtraScalarFieldEnum | ServiceExtraScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model ProductBusinessType
   */

  export type AggregateProductBusinessType = {
    _count: ProductBusinessTypeCountAggregateOutputType | null
    _avg: ProductBusinessTypeAvgAggregateOutputType | null
    _sum: ProductBusinessTypeSumAggregateOutputType | null
    _min: ProductBusinessTypeMinAggregateOutputType | null
    _max: ProductBusinessTypeMaxAggregateOutputType | null
  }

  export type ProductBusinessTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductBusinessTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ProductBusinessTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductBusinessTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductBusinessTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProductBusinessTypeAvgAggregateInputType = {
    id?: true
  }

  export type ProductBusinessTypeSumAggregateInputType = {
    id?: true
  }

  export type ProductBusinessTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductBusinessTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductBusinessTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProductBusinessTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBusinessType to aggregate.
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBusinessTypes to fetch.
     */
    orderBy?: ProductBusinessTypeOrderByWithRelationInput | ProductBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductBusinessTypes
    **/
    _count?: true | ProductBusinessTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductBusinessTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductBusinessTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductBusinessTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductBusinessTypeMaxAggregateInputType
  }

  export type GetProductBusinessTypeAggregateType<T extends ProductBusinessTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductBusinessType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductBusinessType[P]>
      : GetScalarType<T[P], AggregateProductBusinessType[P]>
  }




  export type ProductBusinessTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBusinessTypeWhereInput
    orderBy?: ProductBusinessTypeOrderByWithAggregationInput | ProductBusinessTypeOrderByWithAggregationInput[]
    by: ProductBusinessTypeScalarFieldEnum[] | ProductBusinessTypeScalarFieldEnum
    having?: ProductBusinessTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductBusinessTypeCountAggregateInputType | true
    _avg?: ProductBusinessTypeAvgAggregateInputType
    _sum?: ProductBusinessTypeSumAggregateInputType
    _min?: ProductBusinessTypeMinAggregateInputType
    _max?: ProductBusinessTypeMaxAggregateInputType
  }

  export type ProductBusinessTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ProductBusinessTypeCountAggregateOutputType | null
    _avg: ProductBusinessTypeAvgAggregateOutputType | null
    _sum: ProductBusinessTypeSumAggregateOutputType | null
    _min: ProductBusinessTypeMinAggregateOutputType | null
    _max: ProductBusinessTypeMaxAggregateOutputType | null
  }

  type GetProductBusinessTypeGroupByPayload<T extends ProductBusinessTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductBusinessTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductBusinessTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductBusinessTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductBusinessTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProductBusinessTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    products?: boolean | ProductBusinessType$productsArgs<ExtArgs>
    _count?: boolean | ProductBusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBusinessType"]>

  export type ProductBusinessTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productBusinessType"]>

  export type ProductBusinessTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productBusinessType"]>

  export type ProductBusinessTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ProductBusinessTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["productBusinessType"]>
  export type ProductBusinessTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductBusinessType$productsArgs<ExtArgs>
    _count?: boolean | ProductBusinessTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductBusinessTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductBusinessTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductBusinessTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductBusinessType"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["productBusinessType"]>
    composites: {}
  }

  type ProductBusinessTypeGetPayload<S extends boolean | null | undefined | ProductBusinessTypeDefaultArgs> = $Result.GetResult<Prisma.$ProductBusinessTypePayload, S>

  type ProductBusinessTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductBusinessTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductBusinessTypeCountAggregateInputType | true
    }

  export interface ProductBusinessTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductBusinessType'], meta: { name: 'ProductBusinessType' } }
    /**
     * Find zero or one ProductBusinessType that matches the filter.
     * @param {ProductBusinessTypeFindUniqueArgs} args - Arguments to find a ProductBusinessType
     * @example
     * // Get one ProductBusinessType
     * const productBusinessType = await prisma.productBusinessType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductBusinessTypeFindUniqueArgs>(args: SelectSubset<T, ProductBusinessTypeFindUniqueArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductBusinessType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductBusinessTypeFindUniqueOrThrowArgs} args - Arguments to find a ProductBusinessType
     * @example
     * // Get one ProductBusinessType
     * const productBusinessType = await prisma.productBusinessType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductBusinessTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductBusinessTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBusinessType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeFindFirstArgs} args - Arguments to find a ProductBusinessType
     * @example
     * // Get one ProductBusinessType
     * const productBusinessType = await prisma.productBusinessType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductBusinessTypeFindFirstArgs>(args?: SelectSubset<T, ProductBusinessTypeFindFirstArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBusinessType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeFindFirstOrThrowArgs} args - Arguments to find a ProductBusinessType
     * @example
     * // Get one ProductBusinessType
     * const productBusinessType = await prisma.productBusinessType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductBusinessTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductBusinessTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductBusinessTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductBusinessTypes
     * const productBusinessTypes = await prisma.productBusinessType.findMany()
     * 
     * // Get first 10 ProductBusinessTypes
     * const productBusinessTypes = await prisma.productBusinessType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productBusinessTypeWithIdOnly = await prisma.productBusinessType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductBusinessTypeFindManyArgs>(args?: SelectSubset<T, ProductBusinessTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductBusinessType.
     * @param {ProductBusinessTypeCreateArgs} args - Arguments to create a ProductBusinessType.
     * @example
     * // Create one ProductBusinessType
     * const ProductBusinessType = await prisma.productBusinessType.create({
     *   data: {
     *     // ... data to create a ProductBusinessType
     *   }
     * })
     * 
     */
    create<T extends ProductBusinessTypeCreateArgs>(args: SelectSubset<T, ProductBusinessTypeCreateArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductBusinessTypes.
     * @param {ProductBusinessTypeCreateManyArgs} args - Arguments to create many ProductBusinessTypes.
     * @example
     * // Create many ProductBusinessTypes
     * const productBusinessType = await prisma.productBusinessType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductBusinessTypeCreateManyArgs>(args?: SelectSubset<T, ProductBusinessTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductBusinessTypes and returns the data saved in the database.
     * @param {ProductBusinessTypeCreateManyAndReturnArgs} args - Arguments to create many ProductBusinessTypes.
     * @example
     * // Create many ProductBusinessTypes
     * const productBusinessType = await prisma.productBusinessType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductBusinessTypes and only return the `id`
     * const productBusinessTypeWithIdOnly = await prisma.productBusinessType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductBusinessTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductBusinessTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductBusinessType.
     * @param {ProductBusinessTypeDeleteArgs} args - Arguments to delete one ProductBusinessType.
     * @example
     * // Delete one ProductBusinessType
     * const ProductBusinessType = await prisma.productBusinessType.delete({
     *   where: {
     *     // ... filter to delete one ProductBusinessType
     *   }
     * })
     * 
     */
    delete<T extends ProductBusinessTypeDeleteArgs>(args: SelectSubset<T, ProductBusinessTypeDeleteArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductBusinessType.
     * @param {ProductBusinessTypeUpdateArgs} args - Arguments to update one ProductBusinessType.
     * @example
     * // Update one ProductBusinessType
     * const productBusinessType = await prisma.productBusinessType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductBusinessTypeUpdateArgs>(args: SelectSubset<T, ProductBusinessTypeUpdateArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductBusinessTypes.
     * @param {ProductBusinessTypeDeleteManyArgs} args - Arguments to filter ProductBusinessTypes to delete.
     * @example
     * // Delete a few ProductBusinessTypes
     * const { count } = await prisma.productBusinessType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductBusinessTypeDeleteManyArgs>(args?: SelectSubset<T, ProductBusinessTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductBusinessTypes
     * const productBusinessType = await prisma.productBusinessType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductBusinessTypeUpdateManyArgs>(args: SelectSubset<T, ProductBusinessTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBusinessTypes and returns the data updated in the database.
     * @param {ProductBusinessTypeUpdateManyAndReturnArgs} args - Arguments to update many ProductBusinessTypes.
     * @example
     * // Update many ProductBusinessTypes
     * const productBusinessType = await prisma.productBusinessType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductBusinessTypes and only return the `id`
     * const productBusinessTypeWithIdOnly = await prisma.productBusinessType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductBusinessTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductBusinessTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductBusinessType.
     * @param {ProductBusinessTypeUpsertArgs} args - Arguments to update or create a ProductBusinessType.
     * @example
     * // Update or create a ProductBusinessType
     * const productBusinessType = await prisma.productBusinessType.upsert({
     *   create: {
     *     // ... data to create a ProductBusinessType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductBusinessType we want to update
     *   }
     * })
     */
    upsert<T extends ProductBusinessTypeUpsertArgs>(args: SelectSubset<T, ProductBusinessTypeUpsertArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductBusinessTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeCountArgs} args - Arguments to filter ProductBusinessTypes to count.
     * @example
     * // Count the number of ProductBusinessTypes
     * const count = await prisma.productBusinessType.count({
     *   where: {
     *     // ... the filter for the ProductBusinessTypes we want to count
     *   }
     * })
    **/
    count<T extends ProductBusinessTypeCountArgs>(
      args?: Subset<T, ProductBusinessTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductBusinessTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductBusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductBusinessTypeAggregateArgs>(args: Subset<T, ProductBusinessTypeAggregateArgs>): Prisma.PrismaPromise<GetProductBusinessTypeAggregateType<T>>

    /**
     * Group by ProductBusinessType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBusinessTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductBusinessTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductBusinessTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProductBusinessTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductBusinessTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductBusinessTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductBusinessType model
   */
  readonly fields: ProductBusinessTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductBusinessType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductBusinessTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductBusinessType$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductBusinessType$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductBusinessType model
   */ 
  interface ProductBusinessTypeFieldRefs {
    readonly id: FieldRef<"ProductBusinessType", 'Int'>
    readonly name: FieldRef<"ProductBusinessType", 'String'>
    readonly description: FieldRef<"ProductBusinessType", 'String'>
    readonly isActive: FieldRef<"ProductBusinessType", 'Boolean'>
    readonly updatedAt: FieldRef<"ProductBusinessType", 'DateTime'>
    readonly createdAt: FieldRef<"ProductBusinessType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductBusinessType findUnique
   */
  export type ProductBusinessTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductBusinessType to fetch.
     */
    where: ProductBusinessTypeWhereUniqueInput
  }

  /**
   * ProductBusinessType findUniqueOrThrow
   */
  export type ProductBusinessTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductBusinessType to fetch.
     */
    where: ProductBusinessTypeWhereUniqueInput
  }

  /**
   * ProductBusinessType findFirst
   */
  export type ProductBusinessTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductBusinessType to fetch.
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBusinessTypes to fetch.
     */
    orderBy?: ProductBusinessTypeOrderByWithRelationInput | ProductBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBusinessTypes.
     */
    cursor?: ProductBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBusinessTypes.
     */
    distinct?: ProductBusinessTypeScalarFieldEnum | ProductBusinessTypeScalarFieldEnum[]
  }

  /**
   * ProductBusinessType findFirstOrThrow
   */
  export type ProductBusinessTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductBusinessType to fetch.
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBusinessTypes to fetch.
     */
    orderBy?: ProductBusinessTypeOrderByWithRelationInput | ProductBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBusinessTypes.
     */
    cursor?: ProductBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBusinessTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBusinessTypes.
     */
    distinct?: ProductBusinessTypeScalarFieldEnum | ProductBusinessTypeScalarFieldEnum[]
  }

  /**
   * ProductBusinessType findMany
   */
  export type ProductBusinessTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductBusinessTypes to fetch.
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBusinessTypes to fetch.
     */
    orderBy?: ProductBusinessTypeOrderByWithRelationInput | ProductBusinessTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductBusinessTypes.
     */
    cursor?: ProductBusinessTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBusinessTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBusinessTypes.
     */
    skip?: number
    distinct?: ProductBusinessTypeScalarFieldEnum | ProductBusinessTypeScalarFieldEnum[]
  }

  /**
   * ProductBusinessType create
   */
  export type ProductBusinessTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductBusinessType.
     */
    data: XOR<ProductBusinessTypeCreateInput, ProductBusinessTypeUncheckedCreateInput>
  }

  /**
   * ProductBusinessType createMany
   */
  export type ProductBusinessTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductBusinessTypes.
     */
    data: ProductBusinessTypeCreateManyInput | ProductBusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductBusinessType createManyAndReturn
   */
  export type ProductBusinessTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ProductBusinessTypes.
     */
    data: ProductBusinessTypeCreateManyInput | ProductBusinessTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductBusinessType update
   */
  export type ProductBusinessTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductBusinessType.
     */
    data: XOR<ProductBusinessTypeUpdateInput, ProductBusinessTypeUncheckedUpdateInput>
    /**
     * Choose, which ProductBusinessType to update.
     */
    where: ProductBusinessTypeWhereUniqueInput
  }

  /**
   * ProductBusinessType updateMany
   */
  export type ProductBusinessTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductBusinessTypes.
     */
    data: XOR<ProductBusinessTypeUpdateManyMutationInput, ProductBusinessTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductBusinessTypes to update
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * Limit how many ProductBusinessTypes to update.
     */
    limit?: number
  }

  /**
   * ProductBusinessType updateManyAndReturn
   */
  export type ProductBusinessTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * The data used to update ProductBusinessTypes.
     */
    data: XOR<ProductBusinessTypeUpdateManyMutationInput, ProductBusinessTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductBusinessTypes to update
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * Limit how many ProductBusinessTypes to update.
     */
    limit?: number
  }

  /**
   * ProductBusinessType upsert
   */
  export type ProductBusinessTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductBusinessType to update in case it exists.
     */
    where: ProductBusinessTypeWhereUniqueInput
    /**
     * In case the ProductBusinessType found by the `where` argument doesn't exist, create a new ProductBusinessType with this data.
     */
    create: XOR<ProductBusinessTypeCreateInput, ProductBusinessTypeUncheckedCreateInput>
    /**
     * In case the ProductBusinessType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductBusinessTypeUpdateInput, ProductBusinessTypeUncheckedUpdateInput>
  }

  /**
   * ProductBusinessType delete
   */
  export type ProductBusinessTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
    /**
     * Filter which ProductBusinessType to delete.
     */
    where: ProductBusinessTypeWhereUniqueInput
  }

  /**
   * ProductBusinessType deleteMany
   */
  export type ProductBusinessTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBusinessTypes to delete
     */
    where?: ProductBusinessTypeWhereInput
    /**
     * Limit how many ProductBusinessTypes to delete.
     */
    limit?: number
  }

  /**
   * ProductBusinessType.products
   */
  export type ProductBusinessType$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductBusinessType without action
   */
  export type ProductBusinessTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBusinessType
     */
    select?: ProductBusinessTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBusinessType
     */
    omit?: ProductBusinessTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBusinessTypeInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductCategorySumAggregateOutputType = {
    id: number | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProductCategoryAvgAggregateInputType = {
    id?: true
  }

  export type ProductCategorySumAggregateInputType = {
    id?: true
  }

  export type ProductCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _avg?: ProductCategoryAvgAggregateInputType
    _sum?: ProductCategorySumAggregateInputType
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _avg: ProductCategoryAvgAggregateOutputType | null
    _sum: ProductCategorySumAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */ 
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'Int'>
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    productBusinessTypeId: number | null
    productCategoryId: number | null
    rentPrice: Decimal | null
    sellPrice: Decimal | null
    currencyId: number | null
    quantity: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    productBusinessTypeId: number | null
    productCategoryId: number | null
    rentPrice: Decimal | null
    sellPrice: Decimal | null
    currencyId: number | null
    quantity: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    productBusinessTypeId: number | null
    productCategoryId: number | null
    rentPrice: Decimal | null
    sellPrice: Decimal | null
    currencyId: number | null
    quantity: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    imageUrl: string | null
    productBusinessTypeId: number | null
    productCategoryId: number | null
    rentPrice: Decimal | null
    sellPrice: Decimal | null
    currencyId: number | null
    quantity: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice: number
    sellPrice: number
    currencyId: number
    quantity: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    productBusinessTypeId?: true
    productCategoryId?: true
    rentPrice?: true
    sellPrice?: true
    currencyId?: true
    quantity?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    productBusinessTypeId?: true
    productCategoryId?: true
    rentPrice?: true
    sellPrice?: true
    currencyId?: true
    quantity?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    productBusinessTypeId?: true
    productCategoryId?: true
    rentPrice?: true
    sellPrice?: true
    currencyId?: true
    quantity?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    productBusinessTypeId?: true
    productCategoryId?: true
    rentPrice?: true
    sellPrice?: true
    currencyId?: true
    quantity?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    productBusinessTypeId?: true
    productCategoryId?: true
    rentPrice?: true
    sellPrice?: true
    currencyId?: true
    quantity?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string | null
    imageUrl: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice: Decimal | null
    sellPrice: Decimal | null
    currencyId: number
    quantity: number
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    productBusinessTypeId?: boolean
    productCategoryId?: boolean
    rentPrice?: boolean
    sellPrice?: boolean
    currencyId?: boolean
    quantity?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    businessType?: boolean | ProductBusinessTypeDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    productDetails?: boolean | Product$productDetailsArgs<ExtArgs>
    serviceDetails?: boolean | Product$serviceDetailsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    productBusinessTypeId?: boolean
    productCategoryId?: boolean
    rentPrice?: boolean
    sellPrice?: boolean
    currencyId?: boolean
    quantity?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    businessType?: boolean | ProductBusinessTypeDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    productBusinessTypeId?: boolean
    productCategoryId?: boolean
    rentPrice?: boolean
    sellPrice?: boolean
    currencyId?: boolean
    quantity?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    businessType?: boolean | ProductBusinessTypeDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    productBusinessTypeId?: boolean
    productCategoryId?: boolean
    rentPrice?: boolean
    sellPrice?: boolean
    currencyId?: boolean
    quantity?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "imageUrl" | "productBusinessTypeId" | "productCategoryId" | "rentPrice" | "sellPrice" | "currencyId" | "quantity" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | ProductBusinessTypeDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    productDetails?: boolean | Product$productDetailsArgs<ExtArgs>
    serviceDetails?: boolean | Product$serviceDetailsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | ProductBusinessTypeDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessType?: boolean | ProductBusinessTypeDefaultArgs<ExtArgs>
    category?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      businessType: Prisma.$ProductBusinessTypePayload<ExtArgs>
      category: Prisma.$ProductCategoryPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
      productDetails: Prisma.$ProductDetailPayload<ExtArgs>[]
      serviceDetails: Prisma.$ServiceDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      imageUrl: string | null
      productBusinessTypeId: number
      productCategoryId: number
      rentPrice: Prisma.Decimal | null
      sellPrice: Prisma.Decimal | null
      currencyId: number
      quantity: number
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessType<T extends ProductBusinessTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductBusinessTypeDefaultArgs<ExtArgs>>): Prisma__ProductBusinessTypeClient<$Result.GetResult<Prisma.$ProductBusinessTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productDetails<T extends Product$productDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceDetails<T extends Product$serviceDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Product$serviceDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly productBusinessTypeId: FieldRef<"Product", 'Int'>
    readonly productCategoryId: FieldRef<"Product", 'Int'>
    readonly rentPrice: FieldRef<"Product", 'Decimal'>
    readonly sellPrice: FieldRef<"Product", 'Decimal'>
    readonly currencyId: FieldRef<"Product", 'Int'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.productDetails
   */
  export type Product$productDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    where?: ProductDetailWhereInput
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    cursor?: ProductDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }

  /**
   * Product.serviceDetails
   */
  export type Product$serviceDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    where?: ServiceDetailWhereInput
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    cursor?: ServiceDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceDetailScalarFieldEnum | ServiceDetailScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductDetailType
   */

  export type AggregateProductDetailType = {
    _count: ProductDetailTypeCountAggregateOutputType | null
    _avg: ProductDetailTypeAvgAggregateOutputType | null
    _sum: ProductDetailTypeSumAggregateOutputType | null
    _min: ProductDetailTypeMinAggregateOutputType | null
    _max: ProductDetailTypeMaxAggregateOutputType | null
  }

  export type ProductDetailTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type ProductDetailTypeSumAggregateOutputType = {
    id: number | null
  }

  export type ProductDetailTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductDetailTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductDetailTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProductDetailTypeAvgAggregateInputType = {
    id?: true
  }

  export type ProductDetailTypeSumAggregateInputType = {
    id?: true
  }

  export type ProductDetailTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductDetailTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductDetailTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProductDetailTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDetailType to aggregate.
     */
    where?: ProductDetailTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetailTypes to fetch.
     */
    orderBy?: ProductDetailTypeOrderByWithRelationInput | ProductDetailTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductDetailTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetailTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetailTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductDetailTypes
    **/
    _count?: true | ProductDetailTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductDetailTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductDetailTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductDetailTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductDetailTypeMaxAggregateInputType
  }

  export type GetProductDetailTypeAggregateType<T extends ProductDetailTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductDetailType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductDetailType[P]>
      : GetScalarType<T[P], AggregateProductDetailType[P]>
  }




  export type ProductDetailTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDetailTypeWhereInput
    orderBy?: ProductDetailTypeOrderByWithAggregationInput | ProductDetailTypeOrderByWithAggregationInput[]
    by: ProductDetailTypeScalarFieldEnum[] | ProductDetailTypeScalarFieldEnum
    having?: ProductDetailTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductDetailTypeCountAggregateInputType | true
    _avg?: ProductDetailTypeAvgAggregateInputType
    _sum?: ProductDetailTypeSumAggregateInputType
    _min?: ProductDetailTypeMinAggregateInputType
    _max?: ProductDetailTypeMaxAggregateInputType
  }

  export type ProductDetailTypeGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ProductDetailTypeCountAggregateOutputType | null
    _avg: ProductDetailTypeAvgAggregateOutputType | null
    _sum: ProductDetailTypeSumAggregateOutputType | null
    _min: ProductDetailTypeMinAggregateOutputType | null
    _max: ProductDetailTypeMaxAggregateOutputType | null
  }

  type GetProductDetailTypeGroupByPayload<T extends ProductDetailTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductDetailTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductDetailTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductDetailTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductDetailTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProductDetailTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    productDetails?: boolean | ProductDetailType$productDetailsArgs<ExtArgs>
    _count?: boolean | ProductDetailTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productDetailType"]>

  export type ProductDetailTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productDetailType"]>

  export type ProductDetailTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["productDetailType"]>

  export type ProductDetailTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ProductDetailTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["productDetailType"]>
  export type ProductDetailTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productDetails?: boolean | ProductDetailType$productDetailsArgs<ExtArgs>
    _count?: boolean | ProductDetailTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductDetailTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductDetailTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductDetailTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductDetailType"
    objects: {
      productDetails: Prisma.$ProductDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["productDetailType"]>
    composites: {}
  }

  type ProductDetailTypeGetPayload<S extends boolean | null | undefined | ProductDetailTypeDefaultArgs> = $Result.GetResult<Prisma.$ProductDetailTypePayload, S>

  type ProductDetailTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductDetailTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductDetailTypeCountAggregateInputType | true
    }

  export interface ProductDetailTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductDetailType'], meta: { name: 'ProductDetailType' } }
    /**
     * Find zero or one ProductDetailType that matches the filter.
     * @param {ProductDetailTypeFindUniqueArgs} args - Arguments to find a ProductDetailType
     * @example
     * // Get one ProductDetailType
     * const productDetailType = await prisma.productDetailType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductDetailTypeFindUniqueArgs>(args: SelectSubset<T, ProductDetailTypeFindUniqueArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductDetailType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductDetailTypeFindUniqueOrThrowArgs} args - Arguments to find a ProductDetailType
     * @example
     * // Get one ProductDetailType
     * const productDetailType = await prisma.productDetailType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductDetailTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductDetailTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductDetailType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeFindFirstArgs} args - Arguments to find a ProductDetailType
     * @example
     * // Get one ProductDetailType
     * const productDetailType = await prisma.productDetailType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductDetailTypeFindFirstArgs>(args?: SelectSubset<T, ProductDetailTypeFindFirstArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductDetailType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeFindFirstOrThrowArgs} args - Arguments to find a ProductDetailType
     * @example
     * // Get one ProductDetailType
     * const productDetailType = await prisma.productDetailType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductDetailTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductDetailTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductDetailTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductDetailTypes
     * const productDetailTypes = await prisma.productDetailType.findMany()
     * 
     * // Get first 10 ProductDetailTypes
     * const productDetailTypes = await prisma.productDetailType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productDetailTypeWithIdOnly = await prisma.productDetailType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductDetailTypeFindManyArgs>(args?: SelectSubset<T, ProductDetailTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductDetailType.
     * @param {ProductDetailTypeCreateArgs} args - Arguments to create a ProductDetailType.
     * @example
     * // Create one ProductDetailType
     * const ProductDetailType = await prisma.productDetailType.create({
     *   data: {
     *     // ... data to create a ProductDetailType
     *   }
     * })
     * 
     */
    create<T extends ProductDetailTypeCreateArgs>(args: SelectSubset<T, ProductDetailTypeCreateArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductDetailTypes.
     * @param {ProductDetailTypeCreateManyArgs} args - Arguments to create many ProductDetailTypes.
     * @example
     * // Create many ProductDetailTypes
     * const productDetailType = await prisma.productDetailType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductDetailTypeCreateManyArgs>(args?: SelectSubset<T, ProductDetailTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductDetailTypes and returns the data saved in the database.
     * @param {ProductDetailTypeCreateManyAndReturnArgs} args - Arguments to create many ProductDetailTypes.
     * @example
     * // Create many ProductDetailTypes
     * const productDetailType = await prisma.productDetailType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductDetailTypes and only return the `id`
     * const productDetailTypeWithIdOnly = await prisma.productDetailType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductDetailTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductDetailTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductDetailType.
     * @param {ProductDetailTypeDeleteArgs} args - Arguments to delete one ProductDetailType.
     * @example
     * // Delete one ProductDetailType
     * const ProductDetailType = await prisma.productDetailType.delete({
     *   where: {
     *     // ... filter to delete one ProductDetailType
     *   }
     * })
     * 
     */
    delete<T extends ProductDetailTypeDeleteArgs>(args: SelectSubset<T, ProductDetailTypeDeleteArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductDetailType.
     * @param {ProductDetailTypeUpdateArgs} args - Arguments to update one ProductDetailType.
     * @example
     * // Update one ProductDetailType
     * const productDetailType = await prisma.productDetailType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductDetailTypeUpdateArgs>(args: SelectSubset<T, ProductDetailTypeUpdateArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductDetailTypes.
     * @param {ProductDetailTypeDeleteManyArgs} args - Arguments to filter ProductDetailTypes to delete.
     * @example
     * // Delete a few ProductDetailTypes
     * const { count } = await prisma.productDetailType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDetailTypeDeleteManyArgs>(args?: SelectSubset<T, ProductDetailTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductDetailTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductDetailTypes
     * const productDetailType = await prisma.productDetailType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductDetailTypeUpdateManyArgs>(args: SelectSubset<T, ProductDetailTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductDetailTypes and returns the data updated in the database.
     * @param {ProductDetailTypeUpdateManyAndReturnArgs} args - Arguments to update many ProductDetailTypes.
     * @example
     * // Update many ProductDetailTypes
     * const productDetailType = await prisma.productDetailType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductDetailTypes and only return the `id`
     * const productDetailTypeWithIdOnly = await prisma.productDetailType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductDetailTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductDetailTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductDetailType.
     * @param {ProductDetailTypeUpsertArgs} args - Arguments to update or create a ProductDetailType.
     * @example
     * // Update or create a ProductDetailType
     * const productDetailType = await prisma.productDetailType.upsert({
     *   create: {
     *     // ... data to create a ProductDetailType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductDetailType we want to update
     *   }
     * })
     */
    upsert<T extends ProductDetailTypeUpsertArgs>(args: SelectSubset<T, ProductDetailTypeUpsertArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductDetailTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeCountArgs} args - Arguments to filter ProductDetailTypes to count.
     * @example
     * // Count the number of ProductDetailTypes
     * const count = await prisma.productDetailType.count({
     *   where: {
     *     // ... the filter for the ProductDetailTypes we want to count
     *   }
     * })
    **/
    count<T extends ProductDetailTypeCountArgs>(
      args?: Subset<T, ProductDetailTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductDetailTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductDetailType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductDetailTypeAggregateArgs>(args: Subset<T, ProductDetailTypeAggregateArgs>): Prisma.PrismaPromise<GetProductDetailTypeAggregateType<T>>

    /**
     * Group by ProductDetailType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductDetailTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductDetailTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProductDetailTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductDetailTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductDetailTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductDetailType model
   */
  readonly fields: ProductDetailTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductDetailType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductDetailTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productDetails<T extends ProductDetailType$productDetailsArgs<ExtArgs> = {}>(args?: Subset<T, ProductDetailType$productDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductDetailType model
   */ 
  interface ProductDetailTypeFieldRefs {
    readonly id: FieldRef<"ProductDetailType", 'Int'>
    readonly name: FieldRef<"ProductDetailType", 'String'>
    readonly description: FieldRef<"ProductDetailType", 'String'>
    readonly isActive: FieldRef<"ProductDetailType", 'Boolean'>
    readonly updatedAt: FieldRef<"ProductDetailType", 'DateTime'>
    readonly createdAt: FieldRef<"ProductDetailType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductDetailType findUnique
   */
  export type ProductDetailTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetailType to fetch.
     */
    where: ProductDetailTypeWhereUniqueInput
  }

  /**
   * ProductDetailType findUniqueOrThrow
   */
  export type ProductDetailTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetailType to fetch.
     */
    where: ProductDetailTypeWhereUniqueInput
  }

  /**
   * ProductDetailType findFirst
   */
  export type ProductDetailTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetailType to fetch.
     */
    where?: ProductDetailTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetailTypes to fetch.
     */
    orderBy?: ProductDetailTypeOrderByWithRelationInput | ProductDetailTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDetailTypes.
     */
    cursor?: ProductDetailTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetailTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetailTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDetailTypes.
     */
    distinct?: ProductDetailTypeScalarFieldEnum | ProductDetailTypeScalarFieldEnum[]
  }

  /**
   * ProductDetailType findFirstOrThrow
   */
  export type ProductDetailTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetailType to fetch.
     */
    where?: ProductDetailTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetailTypes to fetch.
     */
    orderBy?: ProductDetailTypeOrderByWithRelationInput | ProductDetailTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDetailTypes.
     */
    cursor?: ProductDetailTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetailTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetailTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDetailTypes.
     */
    distinct?: ProductDetailTypeScalarFieldEnum | ProductDetailTypeScalarFieldEnum[]
  }

  /**
   * ProductDetailType findMany
   */
  export type ProductDetailTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetailTypes to fetch.
     */
    where?: ProductDetailTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetailTypes to fetch.
     */
    orderBy?: ProductDetailTypeOrderByWithRelationInput | ProductDetailTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductDetailTypes.
     */
    cursor?: ProductDetailTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetailTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetailTypes.
     */
    skip?: number
    distinct?: ProductDetailTypeScalarFieldEnum | ProductDetailTypeScalarFieldEnum[]
  }

  /**
   * ProductDetailType create
   */
  export type ProductDetailTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductDetailType.
     */
    data: XOR<ProductDetailTypeCreateInput, ProductDetailTypeUncheckedCreateInput>
  }

  /**
   * ProductDetailType createMany
   */
  export type ProductDetailTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductDetailTypes.
     */
    data: ProductDetailTypeCreateManyInput | ProductDetailTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductDetailType createManyAndReturn
   */
  export type ProductDetailTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ProductDetailTypes.
     */
    data: ProductDetailTypeCreateManyInput | ProductDetailTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductDetailType update
   */
  export type ProductDetailTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductDetailType.
     */
    data: XOR<ProductDetailTypeUpdateInput, ProductDetailTypeUncheckedUpdateInput>
    /**
     * Choose, which ProductDetailType to update.
     */
    where: ProductDetailTypeWhereUniqueInput
  }

  /**
   * ProductDetailType updateMany
   */
  export type ProductDetailTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductDetailTypes.
     */
    data: XOR<ProductDetailTypeUpdateManyMutationInput, ProductDetailTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductDetailTypes to update
     */
    where?: ProductDetailTypeWhereInput
    /**
     * Limit how many ProductDetailTypes to update.
     */
    limit?: number
  }

  /**
   * ProductDetailType updateManyAndReturn
   */
  export type ProductDetailTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * The data used to update ProductDetailTypes.
     */
    data: XOR<ProductDetailTypeUpdateManyMutationInput, ProductDetailTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductDetailTypes to update
     */
    where?: ProductDetailTypeWhereInput
    /**
     * Limit how many ProductDetailTypes to update.
     */
    limit?: number
  }

  /**
   * ProductDetailType upsert
   */
  export type ProductDetailTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductDetailType to update in case it exists.
     */
    where: ProductDetailTypeWhereUniqueInput
    /**
     * In case the ProductDetailType found by the `where` argument doesn't exist, create a new ProductDetailType with this data.
     */
    create: XOR<ProductDetailTypeCreateInput, ProductDetailTypeUncheckedCreateInput>
    /**
     * In case the ProductDetailType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductDetailTypeUpdateInput, ProductDetailTypeUncheckedUpdateInput>
  }

  /**
   * ProductDetailType delete
   */
  export type ProductDetailTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
    /**
     * Filter which ProductDetailType to delete.
     */
    where: ProductDetailTypeWhereUniqueInput
  }

  /**
   * ProductDetailType deleteMany
   */
  export type ProductDetailTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDetailTypes to delete
     */
    where?: ProductDetailTypeWhereInput
    /**
     * Limit how many ProductDetailTypes to delete.
     */
    limit?: number
  }

  /**
   * ProductDetailType.productDetails
   */
  export type ProductDetailType$productDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    where?: ProductDetailWhereInput
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    cursor?: ProductDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }

  /**
   * ProductDetailType without action
   */
  export type ProductDetailTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetailType
     */
    select?: ProductDetailTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetailType
     */
    omit?: ProductDetailTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailTypeInclude<ExtArgs> | null
  }


  /**
   * Model ProductDetail
   */

  export type AggregateProductDetail = {
    _count: ProductDetailCountAggregateOutputType | null
    _avg: ProductDetailAvgAggregateOutputType | null
    _sum: ProductDetailSumAggregateOutputType | null
    _min: ProductDetailMinAggregateOutputType | null
    _max: ProductDetailMaxAggregateOutputType | null
  }

  export type ProductDetailAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    productDetailTypeId: number | null
  }

  export type ProductDetailSumAggregateOutputType = {
    id: number | null
    productId: number | null
    productDetailTypeId: number | null
  }

  export type ProductDetailMinAggregateOutputType = {
    id: number | null
    productId: number | null
    productDetailTypeId: number | null
    detail: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductDetailMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    productDetailTypeId: number | null
    detail: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductDetailCountAggregateOutputType = {
    id: number
    productId: number
    productDetailTypeId: number
    detail: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProductDetailAvgAggregateInputType = {
    id?: true
    productId?: true
    productDetailTypeId?: true
  }

  export type ProductDetailSumAggregateInputType = {
    id?: true
    productId?: true
    productDetailTypeId?: true
  }

  export type ProductDetailMinAggregateInputType = {
    id?: true
    productId?: true
    productDetailTypeId?: true
    detail?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductDetailMaxAggregateInputType = {
    id?: true
    productId?: true
    productDetailTypeId?: true
    detail?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductDetailCountAggregateInputType = {
    id?: true
    productId?: true
    productDetailTypeId?: true
    detail?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProductDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDetail to aggregate.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductDetails
    **/
    _count?: true | ProductDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductDetailMaxAggregateInputType
  }

  export type GetProductDetailAggregateType<T extends ProductDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateProductDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductDetail[P]>
      : GetScalarType<T[P], AggregateProductDetail[P]>
  }




  export type ProductDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDetailWhereInput
    orderBy?: ProductDetailOrderByWithAggregationInput | ProductDetailOrderByWithAggregationInput[]
    by: ProductDetailScalarFieldEnum[] | ProductDetailScalarFieldEnum
    having?: ProductDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductDetailCountAggregateInputType | true
    _avg?: ProductDetailAvgAggregateInputType
    _sum?: ProductDetailSumAggregateInputType
    _min?: ProductDetailMinAggregateInputType
    _max?: ProductDetailMaxAggregateInputType
  }

  export type ProductDetailGroupByOutputType = {
    id: number
    productId: number
    productDetailTypeId: number
    detail: string
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ProductDetailCountAggregateOutputType | null
    _avg: ProductDetailAvgAggregateOutputType | null
    _sum: ProductDetailSumAggregateOutputType | null
    _min: ProductDetailMinAggregateOutputType | null
    _max: ProductDetailMaxAggregateOutputType | null
  }

  type GetProductDetailGroupByPayload<T extends ProductDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ProductDetailGroupByOutputType[P]>
        }
      >
    >


  export type ProductDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    productDetailTypeId?: boolean
    detail?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    detailType?: boolean | ProductDetailTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productDetail"]>

  export type ProductDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    productDetailTypeId?: boolean
    detail?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    detailType?: boolean | ProductDetailTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productDetail"]>

  export type ProductDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    productDetailTypeId?: boolean
    detail?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    detailType?: boolean | ProductDetailTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productDetail"]>

  export type ProductDetailSelectScalar = {
    id?: boolean
    productId?: boolean
    productDetailTypeId?: boolean
    detail?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ProductDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "productDetailTypeId" | "detail" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["productDetail"]>
  export type ProductDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    detailType?: boolean | ProductDetailTypeDefaultArgs<ExtArgs>
  }
  export type ProductDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    detailType?: boolean | ProductDetailTypeDefaultArgs<ExtArgs>
  }
  export type ProductDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    detailType?: boolean | ProductDetailTypeDefaultArgs<ExtArgs>
  }

  export type $ProductDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductDetail"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      detailType: Prisma.$ProductDetailTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      productDetailTypeId: number
      detail: string
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["productDetail"]>
    composites: {}
  }

  type ProductDetailGetPayload<S extends boolean | null | undefined | ProductDetailDefaultArgs> = $Result.GetResult<Prisma.$ProductDetailPayload, S>

  type ProductDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductDetailCountAggregateInputType | true
    }

  export interface ProductDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductDetail'], meta: { name: 'ProductDetail' } }
    /**
     * Find zero or one ProductDetail that matches the filter.
     * @param {ProductDetailFindUniqueArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductDetailFindUniqueArgs>(args: SelectSubset<T, ProductDetailFindUniqueArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductDetailFindUniqueOrThrowArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailFindFirstArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductDetailFindFirstArgs>(args?: SelectSubset<T, ProductDetailFindFirstArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailFindFirstOrThrowArgs} args - Arguments to find a ProductDetail
     * @example
     * // Get one ProductDetail
     * const productDetail = await prisma.productDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductDetails
     * const productDetails = await prisma.productDetail.findMany()
     * 
     * // Get first 10 ProductDetails
     * const productDetails = await prisma.productDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productDetailWithIdOnly = await prisma.productDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductDetailFindManyArgs>(args?: SelectSubset<T, ProductDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductDetail.
     * @param {ProductDetailCreateArgs} args - Arguments to create a ProductDetail.
     * @example
     * // Create one ProductDetail
     * const ProductDetail = await prisma.productDetail.create({
     *   data: {
     *     // ... data to create a ProductDetail
     *   }
     * })
     * 
     */
    create<T extends ProductDetailCreateArgs>(args: SelectSubset<T, ProductDetailCreateArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductDetails.
     * @param {ProductDetailCreateManyArgs} args - Arguments to create many ProductDetails.
     * @example
     * // Create many ProductDetails
     * const productDetail = await prisma.productDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductDetailCreateManyArgs>(args?: SelectSubset<T, ProductDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductDetails and returns the data saved in the database.
     * @param {ProductDetailCreateManyAndReturnArgs} args - Arguments to create many ProductDetails.
     * @example
     * // Create many ProductDetails
     * const productDetail = await prisma.productDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductDetails and only return the `id`
     * const productDetailWithIdOnly = await prisma.productDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductDetail.
     * @param {ProductDetailDeleteArgs} args - Arguments to delete one ProductDetail.
     * @example
     * // Delete one ProductDetail
     * const ProductDetail = await prisma.productDetail.delete({
     *   where: {
     *     // ... filter to delete one ProductDetail
     *   }
     * })
     * 
     */
    delete<T extends ProductDetailDeleteArgs>(args: SelectSubset<T, ProductDetailDeleteArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductDetail.
     * @param {ProductDetailUpdateArgs} args - Arguments to update one ProductDetail.
     * @example
     * // Update one ProductDetail
     * const productDetail = await prisma.productDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductDetailUpdateArgs>(args: SelectSubset<T, ProductDetailUpdateArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductDetails.
     * @param {ProductDetailDeleteManyArgs} args - Arguments to filter ProductDetails to delete.
     * @example
     * // Delete a few ProductDetails
     * const { count } = await prisma.productDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDetailDeleteManyArgs>(args?: SelectSubset<T, ProductDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductDetails
     * const productDetail = await prisma.productDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductDetailUpdateManyArgs>(args: SelectSubset<T, ProductDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductDetails and returns the data updated in the database.
     * @param {ProductDetailUpdateManyAndReturnArgs} args - Arguments to update many ProductDetails.
     * @example
     * // Update many ProductDetails
     * const productDetail = await prisma.productDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductDetails and only return the `id`
     * const productDetailWithIdOnly = await prisma.productDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductDetail.
     * @param {ProductDetailUpsertArgs} args - Arguments to update or create a ProductDetail.
     * @example
     * // Update or create a ProductDetail
     * const productDetail = await prisma.productDetail.upsert({
     *   create: {
     *     // ... data to create a ProductDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductDetail we want to update
     *   }
     * })
     */
    upsert<T extends ProductDetailUpsertArgs>(args: SelectSubset<T, ProductDetailUpsertArgs<ExtArgs>>): Prisma__ProductDetailClient<$Result.GetResult<Prisma.$ProductDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailCountArgs} args - Arguments to filter ProductDetails to count.
     * @example
     * // Count the number of ProductDetails
     * const count = await prisma.productDetail.count({
     *   where: {
     *     // ... the filter for the ProductDetails we want to count
     *   }
     * })
    **/
    count<T extends ProductDetailCountArgs>(
      args?: Subset<T, ProductDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductDetailAggregateArgs>(args: Subset<T, ProductDetailAggregateArgs>): Prisma.PrismaPromise<GetProductDetailAggregateType<T>>

    /**
     * Group by ProductDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductDetailGroupByArgs['orderBy'] }
        : { orderBy?: ProductDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductDetail model
   */
  readonly fields: ProductDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detailType<T extends ProductDetailTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDetailTypeDefaultArgs<ExtArgs>>): Prisma__ProductDetailTypeClient<$Result.GetResult<Prisma.$ProductDetailTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductDetail model
   */ 
  interface ProductDetailFieldRefs {
    readonly id: FieldRef<"ProductDetail", 'Int'>
    readonly productId: FieldRef<"ProductDetail", 'Int'>
    readonly productDetailTypeId: FieldRef<"ProductDetail", 'Int'>
    readonly detail: FieldRef<"ProductDetail", 'String'>
    readonly isActive: FieldRef<"ProductDetail", 'Boolean'>
    readonly updatedAt: FieldRef<"ProductDetail", 'DateTime'>
    readonly createdAt: FieldRef<"ProductDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductDetail findUnique
   */
  export type ProductDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where: ProductDetailWhereUniqueInput
  }

  /**
   * ProductDetail findUniqueOrThrow
   */
  export type ProductDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where: ProductDetailWhereUniqueInput
  }

  /**
   * ProductDetail findFirst
   */
  export type ProductDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDetails.
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDetails.
     */
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }

  /**
   * ProductDetail findFirstOrThrow
   */
  export type ProductDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetail to fetch.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductDetails.
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductDetails.
     */
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }

  /**
   * ProductDetail findMany
   */
  export type ProductDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter, which ProductDetails to fetch.
     */
    where?: ProductDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductDetails to fetch.
     */
    orderBy?: ProductDetailOrderByWithRelationInput | ProductDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductDetails.
     */
    cursor?: ProductDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductDetails.
     */
    skip?: number
    distinct?: ProductDetailScalarFieldEnum | ProductDetailScalarFieldEnum[]
  }

  /**
   * ProductDetail create
   */
  export type ProductDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductDetail.
     */
    data: XOR<ProductDetailCreateInput, ProductDetailUncheckedCreateInput>
  }

  /**
   * ProductDetail createMany
   */
  export type ProductDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductDetails.
     */
    data: ProductDetailCreateManyInput | ProductDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductDetail createManyAndReturn
   */
  export type ProductDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * The data used to create many ProductDetails.
     */
    data: ProductDetailCreateManyInput | ProductDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductDetail update
   */
  export type ProductDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductDetail.
     */
    data: XOR<ProductDetailUpdateInput, ProductDetailUncheckedUpdateInput>
    /**
     * Choose, which ProductDetail to update.
     */
    where: ProductDetailWhereUniqueInput
  }

  /**
   * ProductDetail updateMany
   */
  export type ProductDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductDetails.
     */
    data: XOR<ProductDetailUpdateManyMutationInput, ProductDetailUncheckedUpdateManyInput>
    /**
     * Filter which ProductDetails to update
     */
    where?: ProductDetailWhereInput
    /**
     * Limit how many ProductDetails to update.
     */
    limit?: number
  }

  /**
   * ProductDetail updateManyAndReturn
   */
  export type ProductDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * The data used to update ProductDetails.
     */
    data: XOR<ProductDetailUpdateManyMutationInput, ProductDetailUncheckedUpdateManyInput>
    /**
     * Filter which ProductDetails to update
     */
    where?: ProductDetailWhereInput
    /**
     * Limit how many ProductDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductDetail upsert
   */
  export type ProductDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductDetail to update in case it exists.
     */
    where: ProductDetailWhereUniqueInput
    /**
     * In case the ProductDetail found by the `where` argument doesn't exist, create a new ProductDetail with this data.
     */
    create: XOR<ProductDetailCreateInput, ProductDetailUncheckedCreateInput>
    /**
     * In case the ProductDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductDetailUpdateInput, ProductDetailUncheckedUpdateInput>
  }

  /**
   * ProductDetail delete
   */
  export type ProductDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
    /**
     * Filter which ProductDetail to delete.
     */
    where: ProductDetailWhereUniqueInput
  }

  /**
   * ProductDetail deleteMany
   */
  export type ProductDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductDetails to delete
     */
    where?: ProductDetailWhereInput
    /**
     * Limit how many ProductDetails to delete.
     */
    limit?: number
  }

  /**
   * ProductDetail without action
   */
  export type ProductDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDetail
     */
    select?: ProductDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductDetail
     */
    omit?: ProductDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDetailInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    departments?: boolean | Country$departmentsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Country$departmentsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      departments: Prisma.$CountryDepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Country$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Country$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly description: FieldRef<"Country", 'String'>
    readonly isActive: FieldRef<"Country", 'Boolean'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.departments
   */
  export type Country$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    where?: CountryDepartmentWhereInput
    orderBy?: CountryDepartmentOrderByWithRelationInput | CountryDepartmentOrderByWithRelationInput[]
    cursor?: CountryDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CountryDepartmentScalarFieldEnum | CountryDepartmentScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model CountryDepartment
   */

  export type AggregateCountryDepartment = {
    _count: CountryDepartmentCountAggregateOutputType | null
    _avg: CountryDepartmentAvgAggregateOutputType | null
    _sum: CountryDepartmentSumAggregateOutputType | null
    _min: CountryDepartmentMinAggregateOutputType | null
    _max: CountryDepartmentMaxAggregateOutputType | null
  }

  export type CountryDepartmentAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CountryDepartmentSumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type CountryDepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    countryId: number | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CountryDepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    countryId: number | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type CountryDepartmentCountAggregateOutputType = {
    id: number
    name: number
    countryId: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type CountryDepartmentAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CountryDepartmentSumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type CountryDepartmentMinAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CountryDepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type CountryDepartmentCountAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CountryDepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryDepartment to aggregate.
     */
    where?: CountryDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryDepartments to fetch.
     */
    orderBy?: CountryDepartmentOrderByWithRelationInput | CountryDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountryDepartments
    **/
    _count?: true | CountryDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryDepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountryDepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryDepartmentMaxAggregateInputType
  }

  export type GetCountryDepartmentAggregateType<T extends CountryDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCountryDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountryDepartment[P]>
      : GetScalarType<T[P], AggregateCountryDepartment[P]>
  }




  export type CountryDepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryDepartmentWhereInput
    orderBy?: CountryDepartmentOrderByWithAggregationInput | CountryDepartmentOrderByWithAggregationInput[]
    by: CountryDepartmentScalarFieldEnum[] | CountryDepartmentScalarFieldEnum
    having?: CountryDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryDepartmentCountAggregateInputType | true
    _avg?: CountryDepartmentAvgAggregateInputType
    _sum?: CountryDepartmentSumAggregateInputType
    _min?: CountryDepartmentMinAggregateInputType
    _max?: CountryDepartmentMaxAggregateInputType
  }

  export type CountryDepartmentGroupByOutputType = {
    id: number
    name: string
    countryId: number
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: CountryDepartmentCountAggregateOutputType | null
    _avg: CountryDepartmentAvgAggregateOutputType | null
    _sum: CountryDepartmentSumAggregateOutputType | null
    _min: CountryDepartmentMinAggregateOutputType | null
    _max: CountryDepartmentMaxAggregateOutputType | null
  }

  type GetCountryDepartmentGroupByPayload<T extends CountryDepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], CountryDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type CountryDepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    municipalities?: boolean | CountryDepartment$municipalitiesArgs<ExtArgs>
    _count?: boolean | CountryDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryDepartment"]>

  export type CountryDepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryDepartment"]>

  export type CountryDepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countryDepartment"]>

  export type CountryDepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    countryId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type CountryDepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "countryId" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["countryDepartment"]>
  export type CountryDepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    municipalities?: boolean | CountryDepartment$municipalitiesArgs<ExtArgs>
    _count?: boolean | CountryDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryDepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type CountryDepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $CountryDepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountryDepartment"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      municipalities: Prisma.$MunicipalityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      countryId: number
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["countryDepartment"]>
    composites: {}
  }

  type CountryDepartmentGetPayload<S extends boolean | null | undefined | CountryDepartmentDefaultArgs> = $Result.GetResult<Prisma.$CountryDepartmentPayload, S>

  type CountryDepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryDepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryDepartmentCountAggregateInputType | true
    }

  export interface CountryDepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountryDepartment'], meta: { name: 'CountryDepartment' } }
    /**
     * Find zero or one CountryDepartment that matches the filter.
     * @param {CountryDepartmentFindUniqueArgs} args - Arguments to find a CountryDepartment
     * @example
     * // Get one CountryDepartment
     * const countryDepartment = await prisma.countryDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryDepartmentFindUniqueArgs>(args: SelectSubset<T, CountryDepartmentFindUniqueArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountryDepartment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryDepartmentFindUniqueOrThrowArgs} args - Arguments to find a CountryDepartment
     * @example
     * // Get one CountryDepartment
     * const countryDepartment = await prisma.countryDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryDepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryDepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentFindFirstArgs} args - Arguments to find a CountryDepartment
     * @example
     * // Get one CountryDepartment
     * const countryDepartment = await prisma.countryDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryDepartmentFindFirstArgs>(args?: SelectSubset<T, CountryDepartmentFindFirstArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryDepartment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentFindFirstOrThrowArgs} args - Arguments to find a CountryDepartment
     * @example
     * // Get one CountryDepartment
     * const countryDepartment = await prisma.countryDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryDepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryDepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountryDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountryDepartments
     * const countryDepartments = await prisma.countryDepartment.findMany()
     * 
     * // Get first 10 CountryDepartments
     * const countryDepartments = await prisma.countryDepartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryDepartmentWithIdOnly = await prisma.countryDepartment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryDepartmentFindManyArgs>(args?: SelectSubset<T, CountryDepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountryDepartment.
     * @param {CountryDepartmentCreateArgs} args - Arguments to create a CountryDepartment.
     * @example
     * // Create one CountryDepartment
     * const CountryDepartment = await prisma.countryDepartment.create({
     *   data: {
     *     // ... data to create a CountryDepartment
     *   }
     * })
     * 
     */
    create<T extends CountryDepartmentCreateArgs>(args: SelectSubset<T, CountryDepartmentCreateArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountryDepartments.
     * @param {CountryDepartmentCreateManyArgs} args - Arguments to create many CountryDepartments.
     * @example
     * // Create many CountryDepartments
     * const countryDepartment = await prisma.countryDepartment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryDepartmentCreateManyArgs>(args?: SelectSubset<T, CountryDepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountryDepartments and returns the data saved in the database.
     * @param {CountryDepartmentCreateManyAndReturnArgs} args - Arguments to create many CountryDepartments.
     * @example
     * // Create many CountryDepartments
     * const countryDepartment = await prisma.countryDepartment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountryDepartments and only return the `id`
     * const countryDepartmentWithIdOnly = await prisma.countryDepartment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryDepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryDepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountryDepartment.
     * @param {CountryDepartmentDeleteArgs} args - Arguments to delete one CountryDepartment.
     * @example
     * // Delete one CountryDepartment
     * const CountryDepartment = await prisma.countryDepartment.delete({
     *   where: {
     *     // ... filter to delete one CountryDepartment
     *   }
     * })
     * 
     */
    delete<T extends CountryDepartmentDeleteArgs>(args: SelectSubset<T, CountryDepartmentDeleteArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountryDepartment.
     * @param {CountryDepartmentUpdateArgs} args - Arguments to update one CountryDepartment.
     * @example
     * // Update one CountryDepartment
     * const countryDepartment = await prisma.countryDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryDepartmentUpdateArgs>(args: SelectSubset<T, CountryDepartmentUpdateArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountryDepartments.
     * @param {CountryDepartmentDeleteManyArgs} args - Arguments to filter CountryDepartments to delete.
     * @example
     * // Delete a few CountryDepartments
     * const { count } = await prisma.countryDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDepartmentDeleteManyArgs>(args?: SelectSubset<T, CountryDepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountryDepartments
     * const countryDepartment = await prisma.countryDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryDepartmentUpdateManyArgs>(args: SelectSubset<T, CountryDepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryDepartments and returns the data updated in the database.
     * @param {CountryDepartmentUpdateManyAndReturnArgs} args - Arguments to update many CountryDepartments.
     * @example
     * // Update many CountryDepartments
     * const countryDepartment = await prisma.countryDepartment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountryDepartments and only return the `id`
     * const countryDepartmentWithIdOnly = await prisma.countryDepartment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryDepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryDepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountryDepartment.
     * @param {CountryDepartmentUpsertArgs} args - Arguments to update or create a CountryDepartment.
     * @example
     * // Update or create a CountryDepartment
     * const countryDepartment = await prisma.countryDepartment.upsert({
     *   create: {
     *     // ... data to create a CountryDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountryDepartment we want to update
     *   }
     * })
     */
    upsert<T extends CountryDepartmentUpsertArgs>(args: SelectSubset<T, CountryDepartmentUpsertArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountryDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentCountArgs} args - Arguments to filter CountryDepartments to count.
     * @example
     * // Count the number of CountryDepartments
     * const count = await prisma.countryDepartment.count({
     *   where: {
     *     // ... the filter for the CountryDepartments we want to count
     *   }
     * })
    **/
    count<T extends CountryDepartmentCountArgs>(
      args?: Subset<T, CountryDepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountryDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryDepartmentAggregateArgs>(args: Subset<T, CountryDepartmentAggregateArgs>): Prisma.PrismaPromise<GetCountryDepartmentAggregateType<T>>

    /**
     * Group by CountryDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: CountryDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountryDepartment model
   */
  readonly fields: CountryDepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountryDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryDepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    municipalities<T extends CountryDepartment$municipalitiesArgs<ExtArgs> = {}>(args?: Subset<T, CountryDepartment$municipalitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountryDepartment model
   */ 
  interface CountryDepartmentFieldRefs {
    readonly id: FieldRef<"CountryDepartment", 'Int'>
    readonly name: FieldRef<"CountryDepartment", 'String'>
    readonly countryId: FieldRef<"CountryDepartment", 'Int'>
    readonly description: FieldRef<"CountryDepartment", 'String'>
    readonly isActive: FieldRef<"CountryDepartment", 'Boolean'>
    readonly updatedAt: FieldRef<"CountryDepartment", 'DateTime'>
    readonly createdAt: FieldRef<"CountryDepartment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CountryDepartment findUnique
   */
  export type CountryDepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which CountryDepartment to fetch.
     */
    where: CountryDepartmentWhereUniqueInput
  }

  /**
   * CountryDepartment findUniqueOrThrow
   */
  export type CountryDepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which CountryDepartment to fetch.
     */
    where: CountryDepartmentWhereUniqueInput
  }

  /**
   * CountryDepartment findFirst
   */
  export type CountryDepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which CountryDepartment to fetch.
     */
    where?: CountryDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryDepartments to fetch.
     */
    orderBy?: CountryDepartmentOrderByWithRelationInput | CountryDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryDepartments.
     */
    cursor?: CountryDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryDepartments.
     */
    distinct?: CountryDepartmentScalarFieldEnum | CountryDepartmentScalarFieldEnum[]
  }

  /**
   * CountryDepartment findFirstOrThrow
   */
  export type CountryDepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which CountryDepartment to fetch.
     */
    where?: CountryDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryDepartments to fetch.
     */
    orderBy?: CountryDepartmentOrderByWithRelationInput | CountryDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryDepartments.
     */
    cursor?: CountryDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryDepartments.
     */
    distinct?: CountryDepartmentScalarFieldEnum | CountryDepartmentScalarFieldEnum[]
  }

  /**
   * CountryDepartment findMany
   */
  export type CountryDepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which CountryDepartments to fetch.
     */
    where?: CountryDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryDepartments to fetch.
     */
    orderBy?: CountryDepartmentOrderByWithRelationInput | CountryDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountryDepartments.
     */
    cursor?: CountryDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CountryDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryDepartments.
     */
    skip?: number
    distinct?: CountryDepartmentScalarFieldEnum | CountryDepartmentScalarFieldEnum[]
  }

  /**
   * CountryDepartment create
   */
  export type CountryDepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CountryDepartment.
     */
    data: XOR<CountryDepartmentCreateInput, CountryDepartmentUncheckedCreateInput>
  }

  /**
   * CountryDepartment createMany
   */
  export type CountryDepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountryDepartments.
     */
    data: CountryDepartmentCreateManyInput | CountryDepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryDepartment createManyAndReturn
   */
  export type CountryDepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many CountryDepartments.
     */
    data: CountryDepartmentCreateManyInput | CountryDepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountryDepartment update
   */
  export type CountryDepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CountryDepartment.
     */
    data: XOR<CountryDepartmentUpdateInput, CountryDepartmentUncheckedUpdateInput>
    /**
     * Choose, which CountryDepartment to update.
     */
    where: CountryDepartmentWhereUniqueInput
  }

  /**
   * CountryDepartment updateMany
   */
  export type CountryDepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountryDepartments.
     */
    data: XOR<CountryDepartmentUpdateManyMutationInput, CountryDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which CountryDepartments to update
     */
    where?: CountryDepartmentWhereInput
    /**
     * Limit how many CountryDepartments to update.
     */
    limit?: number
  }

  /**
   * CountryDepartment updateManyAndReturn
   */
  export type CountryDepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * The data used to update CountryDepartments.
     */
    data: XOR<CountryDepartmentUpdateManyMutationInput, CountryDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which CountryDepartments to update
     */
    where?: CountryDepartmentWhereInput
    /**
     * Limit how many CountryDepartments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CountryDepartment upsert
   */
  export type CountryDepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CountryDepartment to update in case it exists.
     */
    where: CountryDepartmentWhereUniqueInput
    /**
     * In case the CountryDepartment found by the `where` argument doesn't exist, create a new CountryDepartment with this data.
     */
    create: XOR<CountryDepartmentCreateInput, CountryDepartmentUncheckedCreateInput>
    /**
     * In case the CountryDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryDepartmentUpdateInput, CountryDepartmentUncheckedUpdateInput>
  }

  /**
   * CountryDepartment delete
   */
  export type CountryDepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
    /**
     * Filter which CountryDepartment to delete.
     */
    where: CountryDepartmentWhereUniqueInput
  }

  /**
   * CountryDepartment deleteMany
   */
  export type CountryDepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryDepartments to delete
     */
    where?: CountryDepartmentWhereInput
    /**
     * Limit how many CountryDepartments to delete.
     */
    limit?: number
  }

  /**
   * CountryDepartment.municipalities
   */
  export type CountryDepartment$municipalitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    cursor?: MunicipalityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * CountryDepartment without action
   */
  export type CountryDepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryDepartment
     */
    select?: CountryDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryDepartment
     */
    omit?: CountryDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryDepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Municipality
   */

  export type AggregateMunicipality = {
    _count: MunicipalityCountAggregateOutputType | null
    _avg: MunicipalityAvgAggregateOutputType | null
    _sum: MunicipalitySumAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  export type MunicipalityAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type MunicipalitySumAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type MunicipalityMinAggregateOutputType = {
    id: number | null
    name: string | null
    departmentId: number | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MunicipalityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    departmentId: number | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MunicipalityCountAggregateOutputType = {
    id: number
    name: number
    departmentId: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type MunicipalityAvgAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type MunicipalitySumAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type MunicipalityMinAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MunicipalityMaxAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MunicipalityCountAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MunicipalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipality to aggregate.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Municipalities
    **/
    _count?: true | MunicipalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipalityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipalitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipalityMaxAggregateInputType
  }

  export type GetMunicipalityAggregateType<T extends MunicipalityAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipality[P]>
      : GetScalarType<T[P], AggregateMunicipality[P]>
  }




  export type MunicipalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MunicipalityWhereInput
    orderBy?: MunicipalityOrderByWithAggregationInput | MunicipalityOrderByWithAggregationInput[]
    by: MunicipalityScalarFieldEnum[] | MunicipalityScalarFieldEnum
    having?: MunicipalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipalityCountAggregateInputType | true
    _avg?: MunicipalityAvgAggregateInputType
    _sum?: MunicipalitySumAggregateInputType
    _min?: MunicipalityMinAggregateInputType
    _max?: MunicipalityMaxAggregateInputType
  }

  export type MunicipalityGroupByOutputType = {
    id: number
    name: string
    departmentId: number
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: MunicipalityCountAggregateOutputType | null
    _avg: MunicipalityAvgAggregateOutputType | null
    _sum: MunicipalitySumAggregateOutputType | null
    _min: MunicipalityMinAggregateOutputType | null
    _max: MunicipalityMaxAggregateOutputType | null
  }

  type GetMunicipalityGroupByPayload<T extends MunicipalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipalityGroupByOutputType[P]>
        }
      >
    >


  export type MunicipalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    department?: boolean | CountryDepartmentDefaultArgs<ExtArgs>
    zones?: boolean | Municipality$zonesArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    department?: boolean | CountryDepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    department?: boolean | CountryDepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipality"]>

  export type MunicipalitySelectScalar = {
    id?: boolean
    name?: boolean
    departmentId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type MunicipalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "departmentId" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["municipality"]>
  export type MunicipalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | CountryDepartmentDefaultArgs<ExtArgs>
    zones?: boolean | Municipality$zonesArgs<ExtArgs>
    _count?: boolean | MunicipalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MunicipalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | CountryDepartmentDefaultArgs<ExtArgs>
  }
  export type MunicipalityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | CountryDepartmentDefaultArgs<ExtArgs>
  }

  export type $MunicipalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Municipality"
    objects: {
      department: Prisma.$CountryDepartmentPayload<ExtArgs>
      zones: Prisma.$ZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      departmentId: number
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["municipality"]>
    composites: {}
  }

  type MunicipalityGetPayload<S extends boolean | null | undefined | MunicipalityDefaultArgs> = $Result.GetResult<Prisma.$MunicipalityPayload, S>

  type MunicipalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MunicipalityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MunicipalityCountAggregateInputType | true
    }

  export interface MunicipalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Municipality'], meta: { name: 'Municipality' } }
    /**
     * Find zero or one Municipality that matches the filter.
     * @param {MunicipalityFindUniqueArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MunicipalityFindUniqueArgs>(args: SelectSubset<T, MunicipalityFindUniqueArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Municipality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MunicipalityFindUniqueOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MunicipalityFindUniqueOrThrowArgs>(args: SelectSubset<T, MunicipalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Municipality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MunicipalityFindFirstArgs>(args?: SelectSubset<T, MunicipalityFindFirstArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Municipality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindFirstOrThrowArgs} args - Arguments to find a Municipality
     * @example
     * // Get one Municipality
     * const municipality = await prisma.municipality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MunicipalityFindFirstOrThrowArgs>(args?: SelectSubset<T, MunicipalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Municipalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipalities
     * const municipalities = await prisma.municipality.findMany()
     * 
     * // Get first 10 Municipalities
     * const municipalities = await prisma.municipality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const municipalityWithIdOnly = await prisma.municipality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MunicipalityFindManyArgs>(args?: SelectSubset<T, MunicipalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Municipality.
     * @param {MunicipalityCreateArgs} args - Arguments to create a Municipality.
     * @example
     * // Create one Municipality
     * const Municipality = await prisma.municipality.create({
     *   data: {
     *     // ... data to create a Municipality
     *   }
     * })
     * 
     */
    create<T extends MunicipalityCreateArgs>(args: SelectSubset<T, MunicipalityCreateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Municipalities.
     * @param {MunicipalityCreateManyArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MunicipalityCreateManyArgs>(args?: SelectSubset<T, MunicipalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Municipalities and returns the data saved in the database.
     * @param {MunicipalityCreateManyAndReturnArgs} args - Arguments to create many Municipalities.
     * @example
     * // Create many Municipalities
     * const municipality = await prisma.municipality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MunicipalityCreateManyAndReturnArgs>(args?: SelectSubset<T, MunicipalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Municipality.
     * @param {MunicipalityDeleteArgs} args - Arguments to delete one Municipality.
     * @example
     * // Delete one Municipality
     * const Municipality = await prisma.municipality.delete({
     *   where: {
     *     // ... filter to delete one Municipality
     *   }
     * })
     * 
     */
    delete<T extends MunicipalityDeleteArgs>(args: SelectSubset<T, MunicipalityDeleteArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Municipality.
     * @param {MunicipalityUpdateArgs} args - Arguments to update one Municipality.
     * @example
     * // Update one Municipality
     * const municipality = await prisma.municipality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MunicipalityUpdateArgs>(args: SelectSubset<T, MunicipalityUpdateArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Municipalities.
     * @param {MunicipalityDeleteManyArgs} args - Arguments to filter Municipalities to delete.
     * @example
     * // Delete a few Municipalities
     * const { count } = await prisma.municipality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MunicipalityDeleteManyArgs>(args?: SelectSubset<T, MunicipalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MunicipalityUpdateManyArgs>(args: SelectSubset<T, MunicipalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipalities and returns the data updated in the database.
     * @param {MunicipalityUpdateManyAndReturnArgs} args - Arguments to update many Municipalities.
     * @example
     * // Update many Municipalities
     * const municipality = await prisma.municipality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Municipalities and only return the `id`
     * const municipalityWithIdOnly = await prisma.municipality.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MunicipalityUpdateManyAndReturnArgs>(args: SelectSubset<T, MunicipalityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Municipality.
     * @param {MunicipalityUpsertArgs} args - Arguments to update or create a Municipality.
     * @example
     * // Update or create a Municipality
     * const municipality = await prisma.municipality.upsert({
     *   create: {
     *     // ... data to create a Municipality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipality we want to update
     *   }
     * })
     */
    upsert<T extends MunicipalityUpsertArgs>(args: SelectSubset<T, MunicipalityUpsertArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Municipalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityCountArgs} args - Arguments to filter Municipalities to count.
     * @example
     * // Count the number of Municipalities
     * const count = await prisma.municipality.count({
     *   where: {
     *     // ... the filter for the Municipalities we want to count
     *   }
     * })
    **/
    count<T extends MunicipalityCountArgs>(
      args?: Subset<T, MunicipalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipalityAggregateArgs>(args: Subset<T, MunicipalityAggregateArgs>): Prisma.PrismaPromise<GetMunicipalityAggregateType<T>>

    /**
     * Group by Municipality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MunicipalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MunicipalityGroupByArgs['orderBy'] }
        : { orderBy?: MunicipalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MunicipalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Municipality model
   */
  readonly fields: MunicipalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Municipality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MunicipalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends CountryDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDepartmentDefaultArgs<ExtArgs>>): Prisma__CountryDepartmentClient<$Result.GetResult<Prisma.$CountryDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zones<T extends Municipality$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Municipality$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Municipality model
   */ 
  interface MunicipalityFieldRefs {
    readonly id: FieldRef<"Municipality", 'Int'>
    readonly name: FieldRef<"Municipality", 'String'>
    readonly departmentId: FieldRef<"Municipality", 'Int'>
    readonly description: FieldRef<"Municipality", 'String'>
    readonly isActive: FieldRef<"Municipality", 'Boolean'>
    readonly updatedAt: FieldRef<"Municipality", 'DateTime'>
    readonly createdAt: FieldRef<"Municipality", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Municipality findUnique
   */
  export type MunicipalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findUniqueOrThrow
   */
  export type MunicipalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality findFirst
   */
  export type MunicipalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findFirstOrThrow
   */
  export type MunicipalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipality to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Municipalities.
     */
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality findMany
   */
  export type MunicipalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter, which Municipalities to fetch.
     */
    where?: MunicipalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Municipalities to fetch.
     */
    orderBy?: MunicipalityOrderByWithRelationInput | MunicipalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Municipalities.
     */
    cursor?: MunicipalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Municipalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Municipalities.
     */
    skip?: number
    distinct?: MunicipalityScalarFieldEnum | MunicipalityScalarFieldEnum[]
  }

  /**
   * Municipality create
   */
  export type MunicipalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Municipality.
     */
    data: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
  }

  /**
   * Municipality createMany
   */
  export type MunicipalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Municipality createManyAndReturn
   */
  export type MunicipalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * The data used to create many Municipalities.
     */
    data: MunicipalityCreateManyInput | MunicipalityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Municipality update
   */
  export type MunicipalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Municipality.
     */
    data: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
    /**
     * Choose, which Municipality to update.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality updateMany
   */
  export type MunicipalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
    /**
     * Limit how many Municipalities to update.
     */
    limit?: number
  }

  /**
   * Municipality updateManyAndReturn
   */
  export type MunicipalityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * The data used to update Municipalities.
     */
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyInput>
    /**
     * Filter which Municipalities to update
     */
    where?: MunicipalityWhereInput
    /**
     * Limit how many Municipalities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Municipality upsert
   */
  export type MunicipalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Municipality to update in case it exists.
     */
    where: MunicipalityWhereUniqueInput
    /**
     * In case the Municipality found by the `where` argument doesn't exist, create a new Municipality with this data.
     */
    create: XOR<MunicipalityCreateInput, MunicipalityUncheckedCreateInput>
    /**
     * In case the Municipality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MunicipalityUpdateInput, MunicipalityUncheckedUpdateInput>
  }

  /**
   * Municipality delete
   */
  export type MunicipalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
    /**
     * Filter which Municipality to delete.
     */
    where: MunicipalityWhereUniqueInput
  }

  /**
   * Municipality deleteMany
   */
  export type MunicipalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Municipalities to delete
     */
    where?: MunicipalityWhereInput
    /**
     * Limit how many Municipalities to delete.
     */
    limit?: number
  }

  /**
   * Municipality.zones
   */
  export type Municipality$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Municipality without action
   */
  export type MunicipalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Municipality
     */
    select?: MunicipalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Municipality
     */
    omit?: MunicipalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MunicipalityInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    id: number | null
    municipalityId: number | null
  }

  export type ZoneSumAggregateOutputType = {
    id: number | null
    municipalityId: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: number | null
    name: string | null
    municipalityId: number | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: number | null
    name: string | null
    municipalityId: number | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    municipalityId: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    id?: true
    municipalityId?: true
  }

  export type ZoneSumAggregateInputType = {
    id?: true
    municipalityId?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    municipalityId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    municipalityId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    municipalityId?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: number
    name: string
    municipalityId: number
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    municipalityId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
    addresses?: boolean | Zone$addressesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    municipalityId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    municipalityId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    municipalityId?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "municipalityId" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["zone"]>
  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
    addresses?: boolean | Zone$addressesArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipality?: boolean | MunicipalityDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      municipality: Prisma.$MunicipalityPayload<ExtArgs>
      addresses: Prisma.$AddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      municipalityId: number
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {ZoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipality<T extends MunicipalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MunicipalityDefaultArgs<ExtArgs>>): Prisma__MunicipalityClient<$Result.GetResult<Prisma.$MunicipalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addresses<T extends Zone$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'Int'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly municipalityId: FieldRef<"Zone", 'Int'>
    readonly description: FieldRef<"Zone", 'String'>
    readonly isActive: FieldRef<"Zone", 'Boolean'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
  }

  /**
   * Zone updateManyAndReturn
   */
  export type ZoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
    /**
     * Limit how many Zones to delete.
     */
    limit?: number
  }

  /**
   * Zone.addresses
   */
  export type Zone$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Zone
     */
    omit?: ZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    zoneId: number | null
    domicilePrice: Decimal | null
    deliveryTimeMinutes: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    zoneId: number | null
    domicilePrice: Decimal | null
    deliveryTimeMinutes: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    zoneId: number | null
    addressKms: string | null
    coordsKms: string | null
    instructionsKms: string | null
    domicilePrice: Decimal | null
    deliveryTimeMinutes: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    zoneId: number | null
    addressKms: string | null
    coordsKms: string | null
    instructionsKms: string | null
    domicilePrice: Decimal | null
    deliveryTimeMinutes: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    userId: number
    zoneId: number
    addressKms: number
    coordsKms: number
    instructionsKms: number
    domicilePrice: number
    deliveryTimeMinutes: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    userId?: true
    zoneId?: true
    domicilePrice?: true
    deliveryTimeMinutes?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    userId?: true
    zoneId?: true
    domicilePrice?: true
    deliveryTimeMinutes?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    userId?: true
    zoneId?: true
    addressKms?: true
    coordsKms?: true
    instructionsKms?: true
    domicilePrice?: true
    deliveryTimeMinutes?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    userId?: true
    zoneId?: true
    addressKms?: true
    coordsKms?: true
    instructionsKms?: true
    domicilePrice?: true
    deliveryTimeMinutes?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    userId?: true
    zoneId?: true
    addressKms?: true
    coordsKms?: true
    instructionsKms?: true
    domicilePrice?: true
    deliveryTimeMinutes?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    userId: number
    zoneId: number
    addressKms: string
    coordsKms: string | null
    instructionsKms: string | null
    domicilePrice: Decimal | null
    deliveryTimeMinutes: number | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    zoneId?: boolean
    addressKms?: boolean
    coordsKms?: boolean
    instructionsKms?: boolean
    domicilePrice?: boolean
    deliveryTimeMinutes?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    services?: boolean | Address$servicesArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    zoneId?: boolean
    addressKms?: boolean
    coordsKms?: boolean
    instructionsKms?: boolean
    domicilePrice?: boolean
    deliveryTimeMinutes?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    zoneId?: boolean
    addressKms?: boolean
    coordsKms?: boolean
    instructionsKms?: boolean
    domicilePrice?: boolean
    deliveryTimeMinutes?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    userId?: boolean
    zoneId?: boolean
    addressKms?: boolean
    coordsKms?: boolean
    instructionsKms?: boolean
    domicilePrice?: boolean
    deliveryTimeMinutes?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "zoneId" | "addressKms" | "coordsKms" | "instructionsKms" | "domicilePrice" | "deliveryTimeMinutes" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    services?: boolean | Address$servicesArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      zoneId: number
      addressKms: string
      coordsKms: string | null
      instructionsKms: string | null
      domicilePrice: Prisma.Decimal | null
      deliveryTimeMinutes: number | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends Address$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Address$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly userId: FieldRef<"Address", 'Int'>
    readonly zoneId: FieldRef<"Address", 'Int'>
    readonly addressKms: FieldRef<"Address", 'String'>
    readonly coordsKms: FieldRef<"Address", 'String'>
    readonly instructionsKms: FieldRef<"Address", 'String'>
    readonly domicilePrice: FieldRef<"Address", 'Decimal'>
    readonly deliveryTimeMinutes: FieldRef<"Address", 'Int'>
    readonly isActive: FieldRef<"Address", 'Boolean'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.services
   */
  export type Address$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model ServiceStatus
   */

  export type AggregateServiceStatus = {
    _count: ServiceStatusCountAggregateOutputType | null
    _avg: ServiceStatusAvgAggregateOutputType | null
    _sum: ServiceStatusSumAggregateOutputType | null
    _min: ServiceStatusMinAggregateOutputType | null
    _max: ServiceStatusMaxAggregateOutputType | null
  }

  export type ServiceStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceStatusSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceStatusCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ServiceStatusAvgAggregateInputType = {
    id?: true
  }

  export type ServiceStatusSumAggregateInputType = {
    id?: true
  }

  export type ServiceStatusMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceStatusMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceStatusCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatus to aggregate.
     */
    where?: ServiceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatuses to fetch.
     */
    orderBy?: ServiceStatusOrderByWithRelationInput | ServiceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceStatuses
    **/
    _count?: true | ServiceStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceStatusMaxAggregateInputType
  }

  export type GetServiceStatusAggregateType<T extends ServiceStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceStatus[P]>
      : GetScalarType<T[P], AggregateServiceStatus[P]>
  }




  export type ServiceStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceStatusWhereInput
    orderBy?: ServiceStatusOrderByWithAggregationInput | ServiceStatusOrderByWithAggregationInput[]
    by: ServiceStatusScalarFieldEnum[] | ServiceStatusScalarFieldEnum
    having?: ServiceStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceStatusCountAggregateInputType | true
    _avg?: ServiceStatusAvgAggregateInputType
    _sum?: ServiceStatusSumAggregateInputType
    _min?: ServiceStatusMinAggregateInputType
    _max?: ServiceStatusMaxAggregateInputType
  }

  export type ServiceStatusGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ServiceStatusCountAggregateOutputType | null
    _avg: ServiceStatusAvgAggregateOutputType | null
    _sum: ServiceStatusSumAggregateOutputType | null
    _min: ServiceStatusMinAggregateOutputType | null
    _max: ServiceStatusMaxAggregateOutputType | null
  }

  type GetServiceStatusGroupByPayload<T extends ServiceStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceStatusGroupByOutputType[P]>
        }
      >
    >


  export type ServiceStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    services?: boolean | ServiceStatus$servicesArgs<ExtArgs>
    _count?: boolean | ServiceStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceStatus"]>

  export type ServiceStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["serviceStatus"]>

  export type ServiceStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["serviceStatus"]>

  export type ServiceStatusSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ServiceStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["serviceStatus"]>
  export type ServiceStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ServiceStatus$servicesArgs<ExtArgs>
    _count?: boolean | ServiceStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceStatus"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["serviceStatus"]>
    composites: {}
  }

  type ServiceStatusGetPayload<S extends boolean | null | undefined | ServiceStatusDefaultArgs> = $Result.GetResult<Prisma.$ServiceStatusPayload, S>

  type ServiceStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceStatusCountAggregateInputType | true
    }

  export interface ServiceStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceStatus'], meta: { name: 'ServiceStatus' } }
    /**
     * Find zero or one ServiceStatus that matches the filter.
     * @param {ServiceStatusFindUniqueArgs} args - Arguments to find a ServiceStatus
     * @example
     * // Get one ServiceStatus
     * const serviceStatus = await prisma.serviceStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceStatusFindUniqueArgs>(args: SelectSubset<T, ServiceStatusFindUniqueArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceStatusFindUniqueOrThrowArgs} args - Arguments to find a ServiceStatus
     * @example
     * // Get one ServiceStatus
     * const serviceStatus = await prisma.serviceStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusFindFirstArgs} args - Arguments to find a ServiceStatus
     * @example
     * // Get one ServiceStatus
     * const serviceStatus = await prisma.serviceStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceStatusFindFirstArgs>(args?: SelectSubset<T, ServiceStatusFindFirstArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusFindFirstOrThrowArgs} args - Arguments to find a ServiceStatus
     * @example
     * // Get one ServiceStatus
     * const serviceStatus = await prisma.serviceStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceStatuses
     * const serviceStatuses = await prisma.serviceStatus.findMany()
     * 
     * // Get first 10 ServiceStatuses
     * const serviceStatuses = await prisma.serviceStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceStatusWithIdOnly = await prisma.serviceStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceStatusFindManyArgs>(args?: SelectSubset<T, ServiceStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceStatus.
     * @param {ServiceStatusCreateArgs} args - Arguments to create a ServiceStatus.
     * @example
     * // Create one ServiceStatus
     * const ServiceStatus = await prisma.serviceStatus.create({
     *   data: {
     *     // ... data to create a ServiceStatus
     *   }
     * })
     * 
     */
    create<T extends ServiceStatusCreateArgs>(args: SelectSubset<T, ServiceStatusCreateArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceStatuses.
     * @param {ServiceStatusCreateManyArgs} args - Arguments to create many ServiceStatuses.
     * @example
     * // Create many ServiceStatuses
     * const serviceStatus = await prisma.serviceStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceStatusCreateManyArgs>(args?: SelectSubset<T, ServiceStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceStatuses and returns the data saved in the database.
     * @param {ServiceStatusCreateManyAndReturnArgs} args - Arguments to create many ServiceStatuses.
     * @example
     * // Create many ServiceStatuses
     * const serviceStatus = await prisma.serviceStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceStatuses and only return the `id`
     * const serviceStatusWithIdOnly = await prisma.serviceStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceStatus.
     * @param {ServiceStatusDeleteArgs} args - Arguments to delete one ServiceStatus.
     * @example
     * // Delete one ServiceStatus
     * const ServiceStatus = await prisma.serviceStatus.delete({
     *   where: {
     *     // ... filter to delete one ServiceStatus
     *   }
     * })
     * 
     */
    delete<T extends ServiceStatusDeleteArgs>(args: SelectSubset<T, ServiceStatusDeleteArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceStatus.
     * @param {ServiceStatusUpdateArgs} args - Arguments to update one ServiceStatus.
     * @example
     * // Update one ServiceStatus
     * const serviceStatus = await prisma.serviceStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceStatusUpdateArgs>(args: SelectSubset<T, ServiceStatusUpdateArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceStatuses.
     * @param {ServiceStatusDeleteManyArgs} args - Arguments to filter ServiceStatuses to delete.
     * @example
     * // Delete a few ServiceStatuses
     * const { count } = await prisma.serviceStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceStatusDeleteManyArgs>(args?: SelectSubset<T, ServiceStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceStatuses
     * const serviceStatus = await prisma.serviceStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceStatusUpdateManyArgs>(args: SelectSubset<T, ServiceStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceStatuses and returns the data updated in the database.
     * @param {ServiceStatusUpdateManyAndReturnArgs} args - Arguments to update many ServiceStatuses.
     * @example
     * // Update many ServiceStatuses
     * const serviceStatus = await prisma.serviceStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceStatuses and only return the `id`
     * const serviceStatusWithIdOnly = await prisma.serviceStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceStatus.
     * @param {ServiceStatusUpsertArgs} args - Arguments to update or create a ServiceStatus.
     * @example
     * // Update or create a ServiceStatus
     * const serviceStatus = await prisma.serviceStatus.upsert({
     *   create: {
     *     // ... data to create a ServiceStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceStatus we want to update
     *   }
     * })
     */
    upsert<T extends ServiceStatusUpsertArgs>(args: SelectSubset<T, ServiceStatusUpsertArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusCountArgs} args - Arguments to filter ServiceStatuses to count.
     * @example
     * // Count the number of ServiceStatuses
     * const count = await prisma.serviceStatus.count({
     *   where: {
     *     // ... the filter for the ServiceStatuses we want to count
     *   }
     * })
    **/
    count<T extends ServiceStatusCountArgs>(
      args?: Subset<T, ServiceStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceStatusAggregateArgs>(args: Subset<T, ServiceStatusAggregateArgs>): Prisma.PrismaPromise<GetServiceStatusAggregateType<T>>

    /**
     * Group by ServiceStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceStatusGroupByArgs['orderBy'] }
        : { orderBy?: ServiceStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceStatus model
   */
  readonly fields: ServiceStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends ServiceStatus$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ServiceStatus$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceStatus model
   */ 
  interface ServiceStatusFieldRefs {
    readonly id: FieldRef<"ServiceStatus", 'Int'>
    readonly name: FieldRef<"ServiceStatus", 'String'>
    readonly description: FieldRef<"ServiceStatus", 'String'>
    readonly isActive: FieldRef<"ServiceStatus", 'Boolean'>
    readonly updatedAt: FieldRef<"ServiceStatus", 'DateTime'>
    readonly createdAt: FieldRef<"ServiceStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceStatus findUnique
   */
  export type ServiceStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatus to fetch.
     */
    where: ServiceStatusWhereUniqueInput
  }

  /**
   * ServiceStatus findUniqueOrThrow
   */
  export type ServiceStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatus to fetch.
     */
    where: ServiceStatusWhereUniqueInput
  }

  /**
   * ServiceStatus findFirst
   */
  export type ServiceStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatus to fetch.
     */
    where?: ServiceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatuses to fetch.
     */
    orderBy?: ServiceStatusOrderByWithRelationInput | ServiceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatuses.
     */
    cursor?: ServiceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatuses.
     */
    distinct?: ServiceStatusScalarFieldEnum | ServiceStatusScalarFieldEnum[]
  }

  /**
   * ServiceStatus findFirstOrThrow
   */
  export type ServiceStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatus to fetch.
     */
    where?: ServiceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatuses to fetch.
     */
    orderBy?: ServiceStatusOrderByWithRelationInput | ServiceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceStatuses.
     */
    cursor?: ServiceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceStatuses.
     */
    distinct?: ServiceStatusScalarFieldEnum | ServiceStatusScalarFieldEnum[]
  }

  /**
   * ServiceStatus findMany
   */
  export type ServiceStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * Filter, which ServiceStatuses to fetch.
     */
    where?: ServiceStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceStatuses to fetch.
     */
    orderBy?: ServiceStatusOrderByWithRelationInput | ServiceStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceStatuses.
     */
    cursor?: ServiceStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceStatuses.
     */
    skip?: number
    distinct?: ServiceStatusScalarFieldEnum | ServiceStatusScalarFieldEnum[]
  }

  /**
   * ServiceStatus create
   */
  export type ServiceStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceStatus.
     */
    data: XOR<ServiceStatusCreateInput, ServiceStatusUncheckedCreateInput>
  }

  /**
   * ServiceStatus createMany
   */
  export type ServiceStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceStatuses.
     */
    data: ServiceStatusCreateManyInput | ServiceStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceStatus createManyAndReturn
   */
  export type ServiceStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceStatuses.
     */
    data: ServiceStatusCreateManyInput | ServiceStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceStatus update
   */
  export type ServiceStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceStatus.
     */
    data: XOR<ServiceStatusUpdateInput, ServiceStatusUncheckedUpdateInput>
    /**
     * Choose, which ServiceStatus to update.
     */
    where: ServiceStatusWhereUniqueInput
  }

  /**
   * ServiceStatus updateMany
   */
  export type ServiceStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceStatuses.
     */
    data: XOR<ServiceStatusUpdateManyMutationInput, ServiceStatusUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatuses to update
     */
    where?: ServiceStatusWhereInput
    /**
     * Limit how many ServiceStatuses to update.
     */
    limit?: number
  }

  /**
   * ServiceStatus updateManyAndReturn
   */
  export type ServiceStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * The data used to update ServiceStatuses.
     */
    data: XOR<ServiceStatusUpdateManyMutationInput, ServiceStatusUncheckedUpdateManyInput>
    /**
     * Filter which ServiceStatuses to update
     */
    where?: ServiceStatusWhereInput
    /**
     * Limit how many ServiceStatuses to update.
     */
    limit?: number
  }

  /**
   * ServiceStatus upsert
   */
  export type ServiceStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceStatus to update in case it exists.
     */
    where: ServiceStatusWhereUniqueInput
    /**
     * In case the ServiceStatus found by the `where` argument doesn't exist, create a new ServiceStatus with this data.
     */
    create: XOR<ServiceStatusCreateInput, ServiceStatusUncheckedCreateInput>
    /**
     * In case the ServiceStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceStatusUpdateInput, ServiceStatusUncheckedUpdateInput>
  }

  /**
   * ServiceStatus delete
   */
  export type ServiceStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
    /**
     * Filter which ServiceStatus to delete.
     */
    where: ServiceStatusWhereUniqueInput
  }

  /**
   * ServiceStatus deleteMany
   */
  export type ServiceStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceStatuses to delete
     */
    where?: ServiceStatusWhereInput
    /**
     * Limit how many ServiceStatuses to delete.
     */
    limit?: number
  }

  /**
   * ServiceStatus.services
   */
  export type ServiceStatus$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * ServiceStatus without action
   */
  export type ServiceStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceStatus
     */
    select?: ServiceStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceStatus
     */
    omit?: ServiceStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceStatusInclude<ExtArgs> | null
  }


  /**
   * Model PaymentStatus
   */

  export type AggregatePaymentStatus = {
    _count: PaymentStatusCountAggregateOutputType | null
    _avg: PaymentStatusAvgAggregateOutputType | null
    _sum: PaymentStatusSumAggregateOutputType | null
    _min: PaymentStatusMinAggregateOutputType | null
    _max: PaymentStatusMaxAggregateOutputType | null
  }

  export type PaymentStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type PaymentStatusSumAggregateOutputType = {
    id: number | null
  }

  export type PaymentStatusMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PaymentStatusMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type PaymentStatusCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type PaymentStatusAvgAggregateInputType = {
    id?: true
  }

  export type PaymentStatusSumAggregateInputType = {
    id?: true
  }

  export type PaymentStatusMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PaymentStatusMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type PaymentStatusCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentStatus to aggregate.
     */
    where?: PaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStatuses to fetch.
     */
    orderBy?: PaymentStatusOrderByWithRelationInput | PaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentStatuses
    **/
    _count?: true | PaymentStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentStatusMaxAggregateInputType
  }

  export type GetPaymentStatusAggregateType<T extends PaymentStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentStatus[P]>
      : GetScalarType<T[P], AggregatePaymentStatus[P]>
  }




  export type PaymentStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentStatusWhereInput
    orderBy?: PaymentStatusOrderByWithAggregationInput | PaymentStatusOrderByWithAggregationInput[]
    by: PaymentStatusScalarFieldEnum[] | PaymentStatusScalarFieldEnum
    having?: PaymentStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentStatusCountAggregateInputType | true
    _avg?: PaymentStatusAvgAggregateInputType
    _sum?: PaymentStatusSumAggregateInputType
    _min?: PaymentStatusMinAggregateInputType
    _max?: PaymentStatusMaxAggregateInputType
  }

  export type PaymentStatusGroupByOutputType = {
    id: number
    name: string
    description: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: PaymentStatusCountAggregateOutputType | null
    _avg: PaymentStatusAvgAggregateOutputType | null
    _sum: PaymentStatusSumAggregateOutputType | null
    _min: PaymentStatusMinAggregateOutputType | null
    _max: PaymentStatusMaxAggregateOutputType | null
  }

  type GetPaymentStatusGroupByPayload<T extends PaymentStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentStatusGroupByOutputType[P]>
        }
      >
    >


  export type PaymentStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    services?: boolean | PaymentStatus$servicesArgs<ExtArgs>
    _count?: boolean | PaymentStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentStatus"]>

  export type PaymentStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentStatus"]>

  export type PaymentStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentStatus"]>

  export type PaymentStatusSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type PaymentStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["paymentStatus"]>
  export type PaymentStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | PaymentStatus$servicesArgs<ExtArgs>
    _count?: boolean | PaymentStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentStatus"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["paymentStatus"]>
    composites: {}
  }

  type PaymentStatusGetPayload<S extends boolean | null | undefined | PaymentStatusDefaultArgs> = $Result.GetResult<Prisma.$PaymentStatusPayload, S>

  type PaymentStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentStatusCountAggregateInputType | true
    }

  export interface PaymentStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentStatus'], meta: { name: 'PaymentStatus' } }
    /**
     * Find zero or one PaymentStatus that matches the filter.
     * @param {PaymentStatusFindUniqueArgs} args - Arguments to find a PaymentStatus
     * @example
     * // Get one PaymentStatus
     * const paymentStatus = await prisma.paymentStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentStatusFindUniqueArgs>(args: SelectSubset<T, PaymentStatusFindUniqueArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentStatusFindUniqueOrThrowArgs} args - Arguments to find a PaymentStatus
     * @example
     * // Get one PaymentStatus
     * const paymentStatus = await prisma.paymentStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusFindFirstArgs} args - Arguments to find a PaymentStatus
     * @example
     * // Get one PaymentStatus
     * const paymentStatus = await prisma.paymentStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentStatusFindFirstArgs>(args?: SelectSubset<T, PaymentStatusFindFirstArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusFindFirstOrThrowArgs} args - Arguments to find a PaymentStatus
     * @example
     * // Get one PaymentStatus
     * const paymentStatus = await prisma.paymentStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentStatuses
     * const paymentStatuses = await prisma.paymentStatus.findMany()
     * 
     * // Get first 10 PaymentStatuses
     * const paymentStatuses = await prisma.paymentStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentStatusWithIdOnly = await prisma.paymentStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentStatusFindManyArgs>(args?: SelectSubset<T, PaymentStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentStatus.
     * @param {PaymentStatusCreateArgs} args - Arguments to create a PaymentStatus.
     * @example
     * // Create one PaymentStatus
     * const PaymentStatus = await prisma.paymentStatus.create({
     *   data: {
     *     // ... data to create a PaymentStatus
     *   }
     * })
     * 
     */
    create<T extends PaymentStatusCreateArgs>(args: SelectSubset<T, PaymentStatusCreateArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentStatuses.
     * @param {PaymentStatusCreateManyArgs} args - Arguments to create many PaymentStatuses.
     * @example
     * // Create many PaymentStatuses
     * const paymentStatus = await prisma.paymentStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentStatusCreateManyArgs>(args?: SelectSubset<T, PaymentStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentStatuses and returns the data saved in the database.
     * @param {PaymentStatusCreateManyAndReturnArgs} args - Arguments to create many PaymentStatuses.
     * @example
     * // Create many PaymentStatuses
     * const paymentStatus = await prisma.paymentStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentStatuses and only return the `id`
     * const paymentStatusWithIdOnly = await prisma.paymentStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentStatus.
     * @param {PaymentStatusDeleteArgs} args - Arguments to delete one PaymentStatus.
     * @example
     * // Delete one PaymentStatus
     * const PaymentStatus = await prisma.paymentStatus.delete({
     *   where: {
     *     // ... filter to delete one PaymentStatus
     *   }
     * })
     * 
     */
    delete<T extends PaymentStatusDeleteArgs>(args: SelectSubset<T, PaymentStatusDeleteArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentStatus.
     * @param {PaymentStatusUpdateArgs} args - Arguments to update one PaymentStatus.
     * @example
     * // Update one PaymentStatus
     * const paymentStatus = await prisma.paymentStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentStatusUpdateArgs>(args: SelectSubset<T, PaymentStatusUpdateArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentStatuses.
     * @param {PaymentStatusDeleteManyArgs} args - Arguments to filter PaymentStatuses to delete.
     * @example
     * // Delete a few PaymentStatuses
     * const { count } = await prisma.paymentStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentStatusDeleteManyArgs>(args?: SelectSubset<T, PaymentStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentStatuses
     * const paymentStatus = await prisma.paymentStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentStatusUpdateManyArgs>(args: SelectSubset<T, PaymentStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentStatuses and returns the data updated in the database.
     * @param {PaymentStatusUpdateManyAndReturnArgs} args - Arguments to update many PaymentStatuses.
     * @example
     * // Update many PaymentStatuses
     * const paymentStatus = await prisma.paymentStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentStatuses and only return the `id`
     * const paymentStatusWithIdOnly = await prisma.paymentStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentStatus.
     * @param {PaymentStatusUpsertArgs} args - Arguments to update or create a PaymentStatus.
     * @example
     * // Update or create a PaymentStatus
     * const paymentStatus = await prisma.paymentStatus.upsert({
     *   create: {
     *     // ... data to create a PaymentStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentStatus we want to update
     *   }
     * })
     */
    upsert<T extends PaymentStatusUpsertArgs>(args: SelectSubset<T, PaymentStatusUpsertArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusCountArgs} args - Arguments to filter PaymentStatuses to count.
     * @example
     * // Count the number of PaymentStatuses
     * const count = await prisma.paymentStatus.count({
     *   where: {
     *     // ... the filter for the PaymentStatuses we want to count
     *   }
     * })
    **/
    count<T extends PaymentStatusCountArgs>(
      args?: Subset<T, PaymentStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentStatusAggregateArgs>(args: Subset<T, PaymentStatusAggregateArgs>): Prisma.PrismaPromise<GetPaymentStatusAggregateType<T>>

    /**
     * Group by PaymentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentStatusGroupByArgs['orderBy'] }
        : { orderBy?: PaymentStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentStatus model
   */
  readonly fields: PaymentStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends PaymentStatus$servicesArgs<ExtArgs> = {}>(args?: Subset<T, PaymentStatus$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentStatus model
   */ 
  interface PaymentStatusFieldRefs {
    readonly id: FieldRef<"PaymentStatus", 'Int'>
    readonly name: FieldRef<"PaymentStatus", 'String'>
    readonly description: FieldRef<"PaymentStatus", 'String'>
    readonly isActive: FieldRef<"PaymentStatus", 'Boolean'>
    readonly updatedAt: FieldRef<"PaymentStatus", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentStatus findUnique
   */
  export type PaymentStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * Filter, which PaymentStatus to fetch.
     */
    where: PaymentStatusWhereUniqueInput
  }

  /**
   * PaymentStatus findUniqueOrThrow
   */
  export type PaymentStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * Filter, which PaymentStatus to fetch.
     */
    where: PaymentStatusWhereUniqueInput
  }

  /**
   * PaymentStatus findFirst
   */
  export type PaymentStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * Filter, which PaymentStatus to fetch.
     */
    where?: PaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStatuses to fetch.
     */
    orderBy?: PaymentStatusOrderByWithRelationInput | PaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentStatuses.
     */
    cursor?: PaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentStatuses.
     */
    distinct?: PaymentStatusScalarFieldEnum | PaymentStatusScalarFieldEnum[]
  }

  /**
   * PaymentStatus findFirstOrThrow
   */
  export type PaymentStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * Filter, which PaymentStatus to fetch.
     */
    where?: PaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStatuses to fetch.
     */
    orderBy?: PaymentStatusOrderByWithRelationInput | PaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentStatuses.
     */
    cursor?: PaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentStatuses.
     */
    distinct?: PaymentStatusScalarFieldEnum | PaymentStatusScalarFieldEnum[]
  }

  /**
   * PaymentStatus findMany
   */
  export type PaymentStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * Filter, which PaymentStatuses to fetch.
     */
    where?: PaymentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStatuses to fetch.
     */
    orderBy?: PaymentStatusOrderByWithRelationInput | PaymentStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentStatuses.
     */
    cursor?: PaymentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStatuses.
     */
    skip?: number
    distinct?: PaymentStatusScalarFieldEnum | PaymentStatusScalarFieldEnum[]
  }

  /**
   * PaymentStatus create
   */
  export type PaymentStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentStatus.
     */
    data: XOR<PaymentStatusCreateInput, PaymentStatusUncheckedCreateInput>
  }

  /**
   * PaymentStatus createMany
   */
  export type PaymentStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentStatuses.
     */
    data: PaymentStatusCreateManyInput | PaymentStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentStatus createManyAndReturn
   */
  export type PaymentStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentStatuses.
     */
    data: PaymentStatusCreateManyInput | PaymentStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentStatus update
   */
  export type PaymentStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentStatus.
     */
    data: XOR<PaymentStatusUpdateInput, PaymentStatusUncheckedUpdateInput>
    /**
     * Choose, which PaymentStatus to update.
     */
    where: PaymentStatusWhereUniqueInput
  }

  /**
   * PaymentStatus updateMany
   */
  export type PaymentStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentStatuses.
     */
    data: XOR<PaymentStatusUpdateManyMutationInput, PaymentStatusUncheckedUpdateManyInput>
    /**
     * Filter which PaymentStatuses to update
     */
    where?: PaymentStatusWhereInput
    /**
     * Limit how many PaymentStatuses to update.
     */
    limit?: number
  }

  /**
   * PaymentStatus updateManyAndReturn
   */
  export type PaymentStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * The data used to update PaymentStatuses.
     */
    data: XOR<PaymentStatusUpdateManyMutationInput, PaymentStatusUncheckedUpdateManyInput>
    /**
     * Filter which PaymentStatuses to update
     */
    where?: PaymentStatusWhereInput
    /**
     * Limit how many PaymentStatuses to update.
     */
    limit?: number
  }

  /**
   * PaymentStatus upsert
   */
  export type PaymentStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentStatus to update in case it exists.
     */
    where: PaymentStatusWhereUniqueInput
    /**
     * In case the PaymentStatus found by the `where` argument doesn't exist, create a new PaymentStatus with this data.
     */
    create: XOR<PaymentStatusCreateInput, PaymentStatusUncheckedCreateInput>
    /**
     * In case the PaymentStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentStatusUpdateInput, PaymentStatusUncheckedUpdateInput>
  }

  /**
   * PaymentStatus delete
   */
  export type PaymentStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
    /**
     * Filter which PaymentStatus to delete.
     */
    where: PaymentStatusWhereUniqueInput
  }

  /**
   * PaymentStatus deleteMany
   */
  export type PaymentStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentStatuses to delete
     */
    where?: PaymentStatusWhereInput
    /**
     * Limit how many PaymentStatuses to delete.
     */
    limit?: number
  }

  /**
   * PaymentStatus.services
   */
  export type PaymentStatus$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * PaymentStatus without action
   */
  export type PaymentStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStatus
     */
    select?: PaymentStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStatus
     */
    omit?: PaymentStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentStatusInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    addressId: number | null
    userPhoneId: number | null
    totalAmount: Decimal | null
    currencyId: number | null
    serviceStatusId: number | null
    paymentStatusId: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    userId: number | null
    addressId: number | null
    userPhoneId: number | null
    totalAmount: Decimal | null
    currencyId: number | null
    serviceStatusId: number | null
    paymentStatusId: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    userId: number | null
    deliveryNameKms: string | null
    addressId: number | null
    userPhoneId: number | null
    description: string | null
    serviceStart: Date | null
    serviceEnd: Date | null
    totalAmount: Decimal | null
    currencyId: number | null
    serviceStatusId: number | null
    paymentStatusId: number | null
    comment: string | null
    invoiceNumberKms: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    deliveryNameKms: string | null
    addressId: number | null
    userPhoneId: number | null
    description: string | null
    serviceStart: Date | null
    serviceEnd: Date | null
    totalAmount: Decimal | null
    currencyId: number | null
    serviceStatusId: number | null
    paymentStatusId: number | null
    comment: string | null
    invoiceNumberKms: string | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    userId: number
    deliveryNameKms: number
    addressId: number
    userPhoneId: number
    description: number
    serviceStart: number
    serviceEnd: number
    totalAmount: number
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment: number
    invoiceNumberKms: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
    userPhoneId?: true
    totalAmount?: true
    currencyId?: true
    serviceStatusId?: true
    paymentStatusId?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    userId?: true
    addressId?: true
    userPhoneId?: true
    totalAmount?: true
    currencyId?: true
    serviceStatusId?: true
    paymentStatusId?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    userId?: true
    deliveryNameKms?: true
    addressId?: true
    userPhoneId?: true
    description?: true
    serviceStart?: true
    serviceEnd?: true
    totalAmount?: true
    currencyId?: true
    serviceStatusId?: true
    paymentStatusId?: true
    comment?: true
    invoiceNumberKms?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    userId?: true
    deliveryNameKms?: true
    addressId?: true
    userPhoneId?: true
    description?: true
    serviceStart?: true
    serviceEnd?: true
    totalAmount?: true
    currencyId?: true
    serviceStatusId?: true
    paymentStatusId?: true
    comment?: true
    invoiceNumberKms?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    userId?: true
    deliveryNameKms?: true
    addressId?: true
    userPhoneId?: true
    description?: true
    serviceStart?: true
    serviceEnd?: true
    totalAmount?: true
    currencyId?: true
    serviceStatusId?: true
    paymentStatusId?: true
    comment?: true
    invoiceNumberKms?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description: string | null
    serviceStart: Date
    serviceEnd: Date
    totalAmount: Decimal
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment: string | null
    invoiceNumberKms: string | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deliveryNameKms?: boolean
    addressId?: boolean
    userPhoneId?: boolean
    description?: boolean
    serviceStart?: boolean
    serviceEnd?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    serviceStatusId?: boolean
    paymentStatusId?: boolean
    comment?: boolean
    invoiceNumberKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    userPhone?: boolean | UserPhoneDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    serviceStatus?: boolean | ServiceStatusDefaultArgs<ExtArgs>
    paymentStatus?: boolean | PaymentStatusDefaultArgs<ExtArgs>
    serviceDetails?: boolean | Service$serviceDetailsArgs<ExtArgs>
    serviceExtras?: boolean | Service$serviceExtrasArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deliveryNameKms?: boolean
    addressId?: boolean
    userPhoneId?: boolean
    description?: boolean
    serviceStart?: boolean
    serviceEnd?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    serviceStatusId?: boolean
    paymentStatusId?: boolean
    comment?: boolean
    invoiceNumberKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    userPhone?: boolean | UserPhoneDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    serviceStatus?: boolean | ServiceStatusDefaultArgs<ExtArgs>
    paymentStatus?: boolean | PaymentStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deliveryNameKms?: boolean
    addressId?: boolean
    userPhoneId?: boolean
    description?: boolean
    serviceStart?: boolean
    serviceEnd?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    serviceStatusId?: boolean
    paymentStatusId?: boolean
    comment?: boolean
    invoiceNumberKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    userPhone?: boolean | UserPhoneDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    serviceStatus?: boolean | ServiceStatusDefaultArgs<ExtArgs>
    paymentStatus?: boolean | PaymentStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    userId?: boolean
    deliveryNameKms?: boolean
    addressId?: boolean
    userPhoneId?: boolean
    description?: boolean
    serviceStart?: boolean
    serviceEnd?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    serviceStatusId?: boolean
    paymentStatusId?: boolean
    comment?: boolean
    invoiceNumberKms?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deliveryNameKms" | "addressId" | "userPhoneId" | "description" | "serviceStart" | "serviceEnd" | "totalAmount" | "currencyId" | "serviceStatusId" | "paymentStatusId" | "comment" | "invoiceNumberKms" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    userPhone?: boolean | UserPhoneDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    serviceStatus?: boolean | ServiceStatusDefaultArgs<ExtArgs>
    paymentStatus?: boolean | PaymentStatusDefaultArgs<ExtArgs>
    serviceDetails?: boolean | Service$serviceDetailsArgs<ExtArgs>
    serviceExtras?: boolean | Service$serviceExtrasArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    userPhone?: boolean | UserPhoneDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    serviceStatus?: boolean | ServiceStatusDefaultArgs<ExtArgs>
    paymentStatus?: boolean | PaymentStatusDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | AddressDefaultArgs<ExtArgs>
    userPhone?: boolean | UserPhoneDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    serviceStatus?: boolean | ServiceStatusDefaultArgs<ExtArgs>
    paymentStatus?: boolean | PaymentStatusDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      address: Prisma.$AddressPayload<ExtArgs>
      userPhone: Prisma.$UserPhonePayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
      serviceStatus: Prisma.$ServiceStatusPayload<ExtArgs>
      paymentStatus: Prisma.$PaymentStatusPayload<ExtArgs>
      serviceDetails: Prisma.$ServiceDetailPayload<ExtArgs>[]
      serviceExtras: Prisma.$ServiceExtraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      deliveryNameKms: string
      addressId: number
      userPhoneId: number
      description: string | null
      serviceStart: Date
      serviceEnd: Date
      totalAmount: Prisma.Decimal
      currencyId: number
      serviceStatusId: number
      paymentStatusId: number
      comment: string | null
      invoiceNumberKms: string | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    address<T extends AddressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddressDefaultArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userPhone<T extends UserPhoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPhoneDefaultArgs<ExtArgs>>): Prisma__UserPhoneClient<$Result.GetResult<Prisma.$UserPhonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceStatus<T extends ServiceStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceStatusDefaultArgs<ExtArgs>>): Prisma__ServiceStatusClient<$Result.GetResult<Prisma.$ServiceStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentStatus<T extends PaymentStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentStatusDefaultArgs<ExtArgs>>): Prisma__PaymentStatusClient<$Result.GetResult<Prisma.$PaymentStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceDetails<T extends Service$serviceDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceExtras<T extends Service$serviceExtrasArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceExtrasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly userId: FieldRef<"Service", 'Int'>
    readonly deliveryNameKms: FieldRef<"Service", 'String'>
    readonly addressId: FieldRef<"Service", 'Int'>
    readonly userPhoneId: FieldRef<"Service", 'Int'>
    readonly description: FieldRef<"Service", 'String'>
    readonly serviceStart: FieldRef<"Service", 'DateTime'>
    readonly serviceEnd: FieldRef<"Service", 'DateTime'>
    readonly totalAmount: FieldRef<"Service", 'Decimal'>
    readonly currencyId: FieldRef<"Service", 'Int'>
    readonly serviceStatusId: FieldRef<"Service", 'Int'>
    readonly paymentStatusId: FieldRef<"Service", 'Int'>
    readonly comment: FieldRef<"Service", 'String'>
    readonly invoiceNumberKms: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.serviceDetails
   */
  export type Service$serviceDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    where?: ServiceDetailWhereInput
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    cursor?: ServiceDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceDetailScalarFieldEnum | ServiceDetailScalarFieldEnum[]
  }

  /**
   * Service.serviceExtras
   */
  export type Service$serviceExtrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    where?: ServiceExtraWhereInput
    orderBy?: ServiceExtraOrderByWithRelationInput | ServiceExtraOrderByWithRelationInput[]
    cursor?: ServiceExtraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceExtraScalarFieldEnum | ServiceExtraScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceDetail
   */

  export type AggregateServiceDetail = {
    _count: ServiceDetailCountAggregateOutputType | null
    _avg: ServiceDetailAvgAggregateOutputType | null
    _sum: ServiceDetailSumAggregateOutputType | null
    _min: ServiceDetailMinAggregateOutputType | null
    _max: ServiceDetailMaxAggregateOutputType | null
  }

  export type ServiceDetailAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
    productId: number | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
  }

  export type ServiceDetailSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
    productId: number | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
  }

  export type ServiceDetailMinAggregateOutputType = {
    id: number | null
    serviceId: number | null
    productId: number | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceDetailMaxAggregateOutputType = {
    id: number | null
    serviceId: number | null
    productId: number | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceDetailCountAggregateOutputType = {
    id: number
    serviceId: number
    productId: number
    quantity: number
    unitaryPrice: number
    parcialPrice: number
    currencyId: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ServiceDetailAvgAggregateInputType = {
    id?: true
    serviceId?: true
    productId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
  }

  export type ServiceDetailSumAggregateInputType = {
    id?: true
    serviceId?: true
    productId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
  }

  export type ServiceDetailMinAggregateInputType = {
    id?: true
    serviceId?: true
    productId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceDetailMaxAggregateInputType = {
    id?: true
    serviceId?: true
    productId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceDetailCountAggregateInputType = {
    id?: true
    serviceId?: true
    productId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceDetail to aggregate.
     */
    where?: ServiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDetails to fetch.
     */
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceDetails
    **/
    _count?: true | ServiceDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceDetailMaxAggregateInputType
  }

  export type GetServiceDetailAggregateType<T extends ServiceDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceDetail[P]>
      : GetScalarType<T[P], AggregateServiceDetail[P]>
  }




  export type ServiceDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceDetailWhereInput
    orderBy?: ServiceDetailOrderByWithAggregationInput | ServiceDetailOrderByWithAggregationInput[]
    by: ServiceDetailScalarFieldEnum[] | ServiceDetailScalarFieldEnum
    having?: ServiceDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceDetailCountAggregateInputType | true
    _avg?: ServiceDetailAvgAggregateInputType
    _sum?: ServiceDetailSumAggregateInputType
    _min?: ServiceDetailMinAggregateInputType
    _max?: ServiceDetailMaxAggregateInputType
  }

  export type ServiceDetailGroupByOutputType = {
    id: number
    serviceId: number
    productId: number
    quantity: number
    unitaryPrice: Decimal
    parcialPrice: Decimal
    currencyId: number
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ServiceDetailCountAggregateOutputType | null
    _avg: ServiceDetailAvgAggregateOutputType | null
    _sum: ServiceDetailSumAggregateOutputType | null
    _min: ServiceDetailMinAggregateOutputType | null
    _max: ServiceDetailMaxAggregateOutputType | null
  }

  type GetServiceDetailGroupByPayload<T extends ServiceDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceDetailGroupByOutputType[P]>
        }
      >
    >


  export type ServiceDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    productId?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceDetail"]>

  export type ServiceDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    productId?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceDetail"]>

  export type ServiceDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    productId?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceDetail"]>

  export type ServiceDetailSelectScalar = {
    id?: boolean
    serviceId?: boolean
    productId?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ServiceDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "productId" | "quantity" | "unitaryPrice" | "parcialPrice" | "currencyId" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["serviceDetail"]>
  export type ServiceDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type ServiceDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type ServiceDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $ServiceDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceDetail"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceId: number
      productId: number
      quantity: number
      unitaryPrice: Prisma.Decimal
      parcialPrice: Prisma.Decimal
      currencyId: number
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["serviceDetail"]>
    composites: {}
  }

  type ServiceDetailGetPayload<S extends boolean | null | undefined | ServiceDetailDefaultArgs> = $Result.GetResult<Prisma.$ServiceDetailPayload, S>

  type ServiceDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceDetailCountAggregateInputType | true
    }

  export interface ServiceDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceDetail'], meta: { name: 'ServiceDetail' } }
    /**
     * Find zero or one ServiceDetail that matches the filter.
     * @param {ServiceDetailFindUniqueArgs} args - Arguments to find a ServiceDetail
     * @example
     * // Get one ServiceDetail
     * const serviceDetail = await prisma.serviceDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceDetailFindUniqueArgs>(args: SelectSubset<T, ServiceDetailFindUniqueArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceDetailFindUniqueOrThrowArgs} args - Arguments to find a ServiceDetail
     * @example
     * // Get one ServiceDetail
     * const serviceDetail = await prisma.serviceDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailFindFirstArgs} args - Arguments to find a ServiceDetail
     * @example
     * // Get one ServiceDetail
     * const serviceDetail = await prisma.serviceDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceDetailFindFirstArgs>(args?: SelectSubset<T, ServiceDetailFindFirstArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailFindFirstOrThrowArgs} args - Arguments to find a ServiceDetail
     * @example
     * // Get one ServiceDetail
     * const serviceDetail = await prisma.serviceDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceDetails
     * const serviceDetails = await prisma.serviceDetail.findMany()
     * 
     * // Get first 10 ServiceDetails
     * const serviceDetails = await prisma.serviceDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceDetailWithIdOnly = await prisma.serviceDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceDetailFindManyArgs>(args?: SelectSubset<T, ServiceDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceDetail.
     * @param {ServiceDetailCreateArgs} args - Arguments to create a ServiceDetail.
     * @example
     * // Create one ServiceDetail
     * const ServiceDetail = await prisma.serviceDetail.create({
     *   data: {
     *     // ... data to create a ServiceDetail
     *   }
     * })
     * 
     */
    create<T extends ServiceDetailCreateArgs>(args: SelectSubset<T, ServiceDetailCreateArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceDetails.
     * @param {ServiceDetailCreateManyArgs} args - Arguments to create many ServiceDetails.
     * @example
     * // Create many ServiceDetails
     * const serviceDetail = await prisma.serviceDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceDetailCreateManyArgs>(args?: SelectSubset<T, ServiceDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceDetails and returns the data saved in the database.
     * @param {ServiceDetailCreateManyAndReturnArgs} args - Arguments to create many ServiceDetails.
     * @example
     * // Create many ServiceDetails
     * const serviceDetail = await prisma.serviceDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceDetails and only return the `id`
     * const serviceDetailWithIdOnly = await prisma.serviceDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceDetail.
     * @param {ServiceDetailDeleteArgs} args - Arguments to delete one ServiceDetail.
     * @example
     * // Delete one ServiceDetail
     * const ServiceDetail = await prisma.serviceDetail.delete({
     *   where: {
     *     // ... filter to delete one ServiceDetail
     *   }
     * })
     * 
     */
    delete<T extends ServiceDetailDeleteArgs>(args: SelectSubset<T, ServiceDetailDeleteArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceDetail.
     * @param {ServiceDetailUpdateArgs} args - Arguments to update one ServiceDetail.
     * @example
     * // Update one ServiceDetail
     * const serviceDetail = await prisma.serviceDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceDetailUpdateArgs>(args: SelectSubset<T, ServiceDetailUpdateArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceDetails.
     * @param {ServiceDetailDeleteManyArgs} args - Arguments to filter ServiceDetails to delete.
     * @example
     * // Delete a few ServiceDetails
     * const { count } = await prisma.serviceDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDetailDeleteManyArgs>(args?: SelectSubset<T, ServiceDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceDetails
     * const serviceDetail = await prisma.serviceDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceDetailUpdateManyArgs>(args: SelectSubset<T, ServiceDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceDetails and returns the data updated in the database.
     * @param {ServiceDetailUpdateManyAndReturnArgs} args - Arguments to update many ServiceDetails.
     * @example
     * // Update many ServiceDetails
     * const serviceDetail = await prisma.serviceDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceDetails and only return the `id`
     * const serviceDetailWithIdOnly = await prisma.serviceDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceDetail.
     * @param {ServiceDetailUpsertArgs} args - Arguments to update or create a ServiceDetail.
     * @example
     * // Update or create a ServiceDetail
     * const serviceDetail = await prisma.serviceDetail.upsert({
     *   create: {
     *     // ... data to create a ServiceDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceDetail we want to update
     *   }
     * })
     */
    upsert<T extends ServiceDetailUpsertArgs>(args: SelectSubset<T, ServiceDetailUpsertArgs<ExtArgs>>): Prisma__ServiceDetailClient<$Result.GetResult<Prisma.$ServiceDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailCountArgs} args - Arguments to filter ServiceDetails to count.
     * @example
     * // Count the number of ServiceDetails
     * const count = await prisma.serviceDetail.count({
     *   where: {
     *     // ... the filter for the ServiceDetails we want to count
     *   }
     * })
    **/
    count<T extends ServiceDetailCountArgs>(
      args?: Subset<T, ServiceDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceDetailAggregateArgs>(args: Subset<T, ServiceDetailAggregateArgs>): Prisma.PrismaPromise<GetServiceDetailAggregateType<T>>

    /**
     * Group by ServiceDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceDetailGroupByArgs['orderBy'] }
        : { orderBy?: ServiceDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceDetail model
   */
  readonly fields: ServiceDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceDetail model
   */ 
  interface ServiceDetailFieldRefs {
    readonly id: FieldRef<"ServiceDetail", 'Int'>
    readonly serviceId: FieldRef<"ServiceDetail", 'Int'>
    readonly productId: FieldRef<"ServiceDetail", 'Int'>
    readonly quantity: FieldRef<"ServiceDetail", 'Int'>
    readonly unitaryPrice: FieldRef<"ServiceDetail", 'Decimal'>
    readonly parcialPrice: FieldRef<"ServiceDetail", 'Decimal'>
    readonly currencyId: FieldRef<"ServiceDetail", 'Int'>
    readonly isActive: FieldRef<"ServiceDetail", 'Boolean'>
    readonly updatedAt: FieldRef<"ServiceDetail", 'DateTime'>
    readonly createdAt: FieldRef<"ServiceDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceDetail findUnique
   */
  export type ServiceDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDetail to fetch.
     */
    where: ServiceDetailWhereUniqueInput
  }

  /**
   * ServiceDetail findUniqueOrThrow
   */
  export type ServiceDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDetail to fetch.
     */
    where: ServiceDetailWhereUniqueInput
  }

  /**
   * ServiceDetail findFirst
   */
  export type ServiceDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDetail to fetch.
     */
    where?: ServiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDetails to fetch.
     */
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceDetails.
     */
    cursor?: ServiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceDetails.
     */
    distinct?: ServiceDetailScalarFieldEnum | ServiceDetailScalarFieldEnum[]
  }

  /**
   * ServiceDetail findFirstOrThrow
   */
  export type ServiceDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDetail to fetch.
     */
    where?: ServiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDetails to fetch.
     */
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceDetails.
     */
    cursor?: ServiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceDetails.
     */
    distinct?: ServiceDetailScalarFieldEnum | ServiceDetailScalarFieldEnum[]
  }

  /**
   * ServiceDetail findMany
   */
  export type ServiceDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * Filter, which ServiceDetails to fetch.
     */
    where?: ServiceDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceDetails to fetch.
     */
    orderBy?: ServiceDetailOrderByWithRelationInput | ServiceDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceDetails.
     */
    cursor?: ServiceDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceDetails.
     */
    skip?: number
    distinct?: ServiceDetailScalarFieldEnum | ServiceDetailScalarFieldEnum[]
  }

  /**
   * ServiceDetail create
   */
  export type ServiceDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceDetail.
     */
    data: XOR<ServiceDetailCreateInput, ServiceDetailUncheckedCreateInput>
  }

  /**
   * ServiceDetail createMany
   */
  export type ServiceDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceDetails.
     */
    data: ServiceDetailCreateManyInput | ServiceDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceDetail createManyAndReturn
   */
  export type ServiceDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceDetails.
     */
    data: ServiceDetailCreateManyInput | ServiceDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceDetail update
   */
  export type ServiceDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceDetail.
     */
    data: XOR<ServiceDetailUpdateInput, ServiceDetailUncheckedUpdateInput>
    /**
     * Choose, which ServiceDetail to update.
     */
    where: ServiceDetailWhereUniqueInput
  }

  /**
   * ServiceDetail updateMany
   */
  export type ServiceDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceDetails.
     */
    data: XOR<ServiceDetailUpdateManyMutationInput, ServiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which ServiceDetails to update
     */
    where?: ServiceDetailWhereInput
    /**
     * Limit how many ServiceDetails to update.
     */
    limit?: number
  }

  /**
   * ServiceDetail updateManyAndReturn
   */
  export type ServiceDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * The data used to update ServiceDetails.
     */
    data: XOR<ServiceDetailUpdateManyMutationInput, ServiceDetailUncheckedUpdateManyInput>
    /**
     * Filter which ServiceDetails to update
     */
    where?: ServiceDetailWhereInput
    /**
     * Limit how many ServiceDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceDetail upsert
   */
  export type ServiceDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceDetail to update in case it exists.
     */
    where: ServiceDetailWhereUniqueInput
    /**
     * In case the ServiceDetail found by the `where` argument doesn't exist, create a new ServiceDetail with this data.
     */
    create: XOR<ServiceDetailCreateInput, ServiceDetailUncheckedCreateInput>
    /**
     * In case the ServiceDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceDetailUpdateInput, ServiceDetailUncheckedUpdateInput>
  }

  /**
   * ServiceDetail delete
   */
  export type ServiceDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
    /**
     * Filter which ServiceDetail to delete.
     */
    where: ServiceDetailWhereUniqueInput
  }

  /**
   * ServiceDetail deleteMany
   */
  export type ServiceDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceDetails to delete
     */
    where?: ServiceDetailWhereInput
    /**
     * Limit how many ServiceDetails to delete.
     */
    limit?: number
  }

  /**
   * ServiceDetail without action
   */
  export type ServiceDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceDetail
     */
    select?: ServiceDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceDetail
     */
    omit?: ServiceDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceDetailInclude<ExtArgs> | null
  }


  /**
   * Model ServiceExtra
   */

  export type AggregateServiceExtra = {
    _count: ServiceExtraCountAggregateOutputType | null
    _avg: ServiceExtraAvgAggregateOutputType | null
    _sum: ServiceExtraSumAggregateOutputType | null
    _min: ServiceExtraMinAggregateOutputType | null
    _max: ServiceExtraMaxAggregateOutputType | null
  }

  export type ServiceExtraAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
  }

  export type ServiceExtraSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
  }

  export type ServiceExtraMinAggregateOutputType = {
    id: number | null
    serviceId: number | null
    name: string | null
    description: string | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceExtraMaxAggregateOutputType = {
    id: number | null
    serviceId: number | null
    name: string | null
    description: string | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
    isActive: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ServiceExtraCountAggregateOutputType = {
    id: number
    serviceId: number
    name: number
    description: number
    quantity: number
    unitaryPrice: number
    parcialPrice: number
    currencyId: number
    isActive: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ServiceExtraAvgAggregateInputType = {
    id?: true
    serviceId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
  }

  export type ServiceExtraSumAggregateInputType = {
    id?: true
    serviceId?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
  }

  export type ServiceExtraMinAggregateInputType = {
    id?: true
    serviceId?: true
    name?: true
    description?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceExtraMaxAggregateInputType = {
    id?: true
    serviceId?: true
    name?: true
    description?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ServiceExtraCountAggregateInputType = {
    id?: true
    serviceId?: true
    name?: true
    description?: true
    quantity?: true
    unitaryPrice?: true
    parcialPrice?: true
    currencyId?: true
    isActive?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceExtraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceExtra to aggregate.
     */
    where?: ServiceExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceExtras to fetch.
     */
    orderBy?: ServiceExtraOrderByWithRelationInput | ServiceExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceExtras
    **/
    _count?: true | ServiceExtraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceExtraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceExtraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceExtraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceExtraMaxAggregateInputType
  }

  export type GetServiceExtraAggregateType<T extends ServiceExtraAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceExtra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceExtra[P]>
      : GetScalarType<T[P], AggregateServiceExtra[P]>
  }




  export type ServiceExtraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceExtraWhereInput
    orderBy?: ServiceExtraOrderByWithAggregationInput | ServiceExtraOrderByWithAggregationInput[]
    by: ServiceExtraScalarFieldEnum[] | ServiceExtraScalarFieldEnum
    having?: ServiceExtraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceExtraCountAggregateInputType | true
    _avg?: ServiceExtraAvgAggregateInputType
    _sum?: ServiceExtraSumAggregateInputType
    _min?: ServiceExtraMinAggregateInputType
    _max?: ServiceExtraMaxAggregateInputType
  }

  export type ServiceExtraGroupByOutputType = {
    id: number
    serviceId: number
    name: string
    description: string | null
    quantity: number | null
    unitaryPrice: Decimal | null
    parcialPrice: Decimal | null
    currencyId: number | null
    isActive: boolean
    updatedAt: Date | null
    createdAt: Date
    _count: ServiceExtraCountAggregateOutputType | null
    _avg: ServiceExtraAvgAggregateOutputType | null
    _sum: ServiceExtraSumAggregateOutputType | null
    _min: ServiceExtraMinAggregateOutputType | null
    _max: ServiceExtraMaxAggregateOutputType | null
  }

  type GetServiceExtraGroupByPayload<T extends ServiceExtraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceExtraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceExtraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceExtraGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceExtraGroupByOutputType[P]>
        }
      >
    >


  export type ServiceExtraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    currency?: boolean | ServiceExtra$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["serviceExtra"]>

  export type ServiceExtraSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    currency?: boolean | ServiceExtra$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["serviceExtra"]>

  export type ServiceExtraSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    currency?: boolean | ServiceExtra$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["serviceExtra"]>

  export type ServiceExtraSelectScalar = {
    id?: boolean
    serviceId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitaryPrice?: boolean
    parcialPrice?: boolean
    currencyId?: boolean
    isActive?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type ServiceExtraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "name" | "description" | "quantity" | "unitaryPrice" | "parcialPrice" | "currencyId" | "isActive" | "updatedAt" | "createdAt", ExtArgs["result"]["serviceExtra"]>
  export type ServiceExtraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    currency?: boolean | ServiceExtra$currencyArgs<ExtArgs>
  }
  export type ServiceExtraIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    currency?: boolean | ServiceExtra$currencyArgs<ExtArgs>
  }
  export type ServiceExtraIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    currency?: boolean | ServiceExtra$currencyArgs<ExtArgs>
  }

  export type $ServiceExtraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceExtra"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceId: number
      name: string
      description: string | null
      quantity: number | null
      unitaryPrice: Prisma.Decimal | null
      parcialPrice: Prisma.Decimal | null
      currencyId: number | null
      isActive: boolean
      updatedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["serviceExtra"]>
    composites: {}
  }

  type ServiceExtraGetPayload<S extends boolean | null | undefined | ServiceExtraDefaultArgs> = $Result.GetResult<Prisma.$ServiceExtraPayload, S>

  type ServiceExtraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceExtraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceExtraCountAggregateInputType | true
    }

  export interface ServiceExtraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceExtra'], meta: { name: 'ServiceExtra' } }
    /**
     * Find zero or one ServiceExtra that matches the filter.
     * @param {ServiceExtraFindUniqueArgs} args - Arguments to find a ServiceExtra
     * @example
     * // Get one ServiceExtra
     * const serviceExtra = await prisma.serviceExtra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceExtraFindUniqueArgs>(args: SelectSubset<T, ServiceExtraFindUniqueArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceExtra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceExtraFindUniqueOrThrowArgs} args - Arguments to find a ServiceExtra
     * @example
     * // Get one ServiceExtra
     * const serviceExtra = await prisma.serviceExtra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceExtraFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceExtraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceExtra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraFindFirstArgs} args - Arguments to find a ServiceExtra
     * @example
     * // Get one ServiceExtra
     * const serviceExtra = await prisma.serviceExtra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceExtraFindFirstArgs>(args?: SelectSubset<T, ServiceExtraFindFirstArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceExtra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraFindFirstOrThrowArgs} args - Arguments to find a ServiceExtra
     * @example
     * // Get one ServiceExtra
     * const serviceExtra = await prisma.serviceExtra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceExtraFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceExtraFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceExtras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceExtras
     * const serviceExtras = await prisma.serviceExtra.findMany()
     * 
     * // Get first 10 ServiceExtras
     * const serviceExtras = await prisma.serviceExtra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceExtraWithIdOnly = await prisma.serviceExtra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceExtraFindManyArgs>(args?: SelectSubset<T, ServiceExtraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceExtra.
     * @param {ServiceExtraCreateArgs} args - Arguments to create a ServiceExtra.
     * @example
     * // Create one ServiceExtra
     * const ServiceExtra = await prisma.serviceExtra.create({
     *   data: {
     *     // ... data to create a ServiceExtra
     *   }
     * })
     * 
     */
    create<T extends ServiceExtraCreateArgs>(args: SelectSubset<T, ServiceExtraCreateArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceExtras.
     * @param {ServiceExtraCreateManyArgs} args - Arguments to create many ServiceExtras.
     * @example
     * // Create many ServiceExtras
     * const serviceExtra = await prisma.serviceExtra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceExtraCreateManyArgs>(args?: SelectSubset<T, ServiceExtraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceExtras and returns the data saved in the database.
     * @param {ServiceExtraCreateManyAndReturnArgs} args - Arguments to create many ServiceExtras.
     * @example
     * // Create many ServiceExtras
     * const serviceExtra = await prisma.serviceExtra.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceExtras and only return the `id`
     * const serviceExtraWithIdOnly = await prisma.serviceExtra.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceExtraCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceExtraCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceExtra.
     * @param {ServiceExtraDeleteArgs} args - Arguments to delete one ServiceExtra.
     * @example
     * // Delete one ServiceExtra
     * const ServiceExtra = await prisma.serviceExtra.delete({
     *   where: {
     *     // ... filter to delete one ServiceExtra
     *   }
     * })
     * 
     */
    delete<T extends ServiceExtraDeleteArgs>(args: SelectSubset<T, ServiceExtraDeleteArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceExtra.
     * @param {ServiceExtraUpdateArgs} args - Arguments to update one ServiceExtra.
     * @example
     * // Update one ServiceExtra
     * const serviceExtra = await prisma.serviceExtra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceExtraUpdateArgs>(args: SelectSubset<T, ServiceExtraUpdateArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceExtras.
     * @param {ServiceExtraDeleteManyArgs} args - Arguments to filter ServiceExtras to delete.
     * @example
     * // Delete a few ServiceExtras
     * const { count } = await prisma.serviceExtra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceExtraDeleteManyArgs>(args?: SelectSubset<T, ServiceExtraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceExtras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceExtras
     * const serviceExtra = await prisma.serviceExtra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceExtraUpdateManyArgs>(args: SelectSubset<T, ServiceExtraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceExtras and returns the data updated in the database.
     * @param {ServiceExtraUpdateManyAndReturnArgs} args - Arguments to update many ServiceExtras.
     * @example
     * // Update many ServiceExtras
     * const serviceExtra = await prisma.serviceExtra.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceExtras and only return the `id`
     * const serviceExtraWithIdOnly = await prisma.serviceExtra.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceExtraUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceExtraUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceExtra.
     * @param {ServiceExtraUpsertArgs} args - Arguments to update or create a ServiceExtra.
     * @example
     * // Update or create a ServiceExtra
     * const serviceExtra = await prisma.serviceExtra.upsert({
     *   create: {
     *     // ... data to create a ServiceExtra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceExtra we want to update
     *   }
     * })
     */
    upsert<T extends ServiceExtraUpsertArgs>(args: SelectSubset<T, ServiceExtraUpsertArgs<ExtArgs>>): Prisma__ServiceExtraClient<$Result.GetResult<Prisma.$ServiceExtraPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceExtras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraCountArgs} args - Arguments to filter ServiceExtras to count.
     * @example
     * // Count the number of ServiceExtras
     * const count = await prisma.serviceExtra.count({
     *   where: {
     *     // ... the filter for the ServiceExtras we want to count
     *   }
     * })
    **/
    count<T extends ServiceExtraCountArgs>(
      args?: Subset<T, ServiceExtraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceExtraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceExtra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceExtraAggregateArgs>(args: Subset<T, ServiceExtraAggregateArgs>): Prisma.PrismaPromise<GetServiceExtraAggregateType<T>>

    /**
     * Group by ServiceExtra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceExtraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceExtraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceExtraGroupByArgs['orderBy'] }
        : { orderBy?: ServiceExtraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceExtraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceExtraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceExtra model
   */
  readonly fields: ServiceExtraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceExtra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceExtraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends ServiceExtra$currencyArgs<ExtArgs> = {}>(args?: Subset<T, ServiceExtra$currencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceExtra model
   */ 
  interface ServiceExtraFieldRefs {
    readonly id: FieldRef<"ServiceExtra", 'Int'>
    readonly serviceId: FieldRef<"ServiceExtra", 'Int'>
    readonly name: FieldRef<"ServiceExtra", 'String'>
    readonly description: FieldRef<"ServiceExtra", 'String'>
    readonly quantity: FieldRef<"ServiceExtra", 'Int'>
    readonly unitaryPrice: FieldRef<"ServiceExtra", 'Decimal'>
    readonly parcialPrice: FieldRef<"ServiceExtra", 'Decimal'>
    readonly currencyId: FieldRef<"ServiceExtra", 'Int'>
    readonly isActive: FieldRef<"ServiceExtra", 'Boolean'>
    readonly updatedAt: FieldRef<"ServiceExtra", 'DateTime'>
    readonly createdAt: FieldRef<"ServiceExtra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceExtra findUnique
   */
  export type ServiceExtraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * Filter, which ServiceExtra to fetch.
     */
    where: ServiceExtraWhereUniqueInput
  }

  /**
   * ServiceExtra findUniqueOrThrow
   */
  export type ServiceExtraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * Filter, which ServiceExtra to fetch.
     */
    where: ServiceExtraWhereUniqueInput
  }

  /**
   * ServiceExtra findFirst
   */
  export type ServiceExtraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * Filter, which ServiceExtra to fetch.
     */
    where?: ServiceExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceExtras to fetch.
     */
    orderBy?: ServiceExtraOrderByWithRelationInput | ServiceExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceExtras.
     */
    cursor?: ServiceExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceExtras.
     */
    distinct?: ServiceExtraScalarFieldEnum | ServiceExtraScalarFieldEnum[]
  }

  /**
   * ServiceExtra findFirstOrThrow
   */
  export type ServiceExtraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * Filter, which ServiceExtra to fetch.
     */
    where?: ServiceExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceExtras to fetch.
     */
    orderBy?: ServiceExtraOrderByWithRelationInput | ServiceExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceExtras.
     */
    cursor?: ServiceExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceExtras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceExtras.
     */
    distinct?: ServiceExtraScalarFieldEnum | ServiceExtraScalarFieldEnum[]
  }

  /**
   * ServiceExtra findMany
   */
  export type ServiceExtraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * Filter, which ServiceExtras to fetch.
     */
    where?: ServiceExtraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceExtras to fetch.
     */
    orderBy?: ServiceExtraOrderByWithRelationInput | ServiceExtraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceExtras.
     */
    cursor?: ServiceExtraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceExtras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceExtras.
     */
    skip?: number
    distinct?: ServiceExtraScalarFieldEnum | ServiceExtraScalarFieldEnum[]
  }

  /**
   * ServiceExtra create
   */
  export type ServiceExtraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceExtra.
     */
    data: XOR<ServiceExtraCreateInput, ServiceExtraUncheckedCreateInput>
  }

  /**
   * ServiceExtra createMany
   */
  export type ServiceExtraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceExtras.
     */
    data: ServiceExtraCreateManyInput | ServiceExtraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceExtra createManyAndReturn
   */
  export type ServiceExtraCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceExtras.
     */
    data: ServiceExtraCreateManyInput | ServiceExtraCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceExtra update
   */
  export type ServiceExtraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceExtra.
     */
    data: XOR<ServiceExtraUpdateInput, ServiceExtraUncheckedUpdateInput>
    /**
     * Choose, which ServiceExtra to update.
     */
    where: ServiceExtraWhereUniqueInput
  }

  /**
   * ServiceExtra updateMany
   */
  export type ServiceExtraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceExtras.
     */
    data: XOR<ServiceExtraUpdateManyMutationInput, ServiceExtraUncheckedUpdateManyInput>
    /**
     * Filter which ServiceExtras to update
     */
    where?: ServiceExtraWhereInput
    /**
     * Limit how many ServiceExtras to update.
     */
    limit?: number
  }

  /**
   * ServiceExtra updateManyAndReturn
   */
  export type ServiceExtraUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * The data used to update ServiceExtras.
     */
    data: XOR<ServiceExtraUpdateManyMutationInput, ServiceExtraUncheckedUpdateManyInput>
    /**
     * Filter which ServiceExtras to update
     */
    where?: ServiceExtraWhereInput
    /**
     * Limit how many ServiceExtras to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceExtra upsert
   */
  export type ServiceExtraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceExtra to update in case it exists.
     */
    where: ServiceExtraWhereUniqueInput
    /**
     * In case the ServiceExtra found by the `where` argument doesn't exist, create a new ServiceExtra with this data.
     */
    create: XOR<ServiceExtraCreateInput, ServiceExtraUncheckedCreateInput>
    /**
     * In case the ServiceExtra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceExtraUpdateInput, ServiceExtraUncheckedUpdateInput>
  }

  /**
   * ServiceExtra delete
   */
  export type ServiceExtraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
    /**
     * Filter which ServiceExtra to delete.
     */
    where: ServiceExtraWhereUniqueInput
  }

  /**
   * ServiceExtra deleteMany
   */
  export type ServiceExtraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceExtras to delete
     */
    where?: ServiceExtraWhereInput
    /**
     * Limit how many ServiceExtras to delete.
     */
    limit?: number
  }

  /**
   * ServiceExtra.currency
   */
  export type ServiceExtra$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * ServiceExtra without action
   */
  export type ServiceExtraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceExtra
     */
    select?: ServiceExtraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceExtra
     */
    omit?: ServiceExtraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceExtraInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullNameKms: 'fullNameKms',
    emailSha: 'emailSha',
    emailKms: 'emailKms',
    roleId: 'roleId',
    passwordSha: 'passwordSha',
    passwordKms: 'passwordKms',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BlacklistTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type BlacklistTypeScalarFieldEnum = (typeof BlacklistTypeScalarFieldEnum)[keyof typeof BlacklistTypeScalarFieldEnum]


  export const BlacklistScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    blacklistTypeId: 'blacklistTypeId',
    reason: 'reason',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type BlacklistScalarFieldEnum = (typeof BlacklistScalarFieldEnum)[keyof typeof BlacklistScalarFieldEnum]


  export const UserPhoneTypeScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type UserPhoneTypeScalarFieldEnum = (typeof UserPhoneTypeScalarFieldEnum)[keyof typeof UserPhoneTypeScalarFieldEnum]


  export const UserPhoneScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userPhoneTypeId: 'userPhoneTypeId',
    phoneNumberKms: 'phoneNumberKms',
    isPrincipal: 'isPrincipal',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type UserPhoneScalarFieldEnum = (typeof UserPhoneScalarFieldEnum)[keyof typeof UserPhoneScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    symbol: 'symbol',
    iso4217Code: 'iso4217Code',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const ProductBusinessTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProductBusinessTypeScalarFieldEnum = (typeof ProductBusinessTypeScalarFieldEnum)[keyof typeof ProductBusinessTypeScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    productBusinessTypeId: 'productBusinessTypeId',
    productCategoryId: 'productCategoryId',
    rentPrice: 'rentPrice',
    sellPrice: 'sellPrice',
    currencyId: 'currencyId',
    quantity: 'quantity',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductDetailTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProductDetailTypeScalarFieldEnum = (typeof ProductDetailTypeScalarFieldEnum)[keyof typeof ProductDetailTypeScalarFieldEnum]


  export const ProductDetailScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    productDetailTypeId: 'productDetailTypeId',
    detail: 'detail',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProductDetailScalarFieldEnum = (typeof ProductDetailScalarFieldEnum)[keyof typeof ProductDetailScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const CountryDepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryId: 'countryId',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type CountryDepartmentScalarFieldEnum = (typeof CountryDepartmentScalarFieldEnum)[keyof typeof CountryDepartmentScalarFieldEnum]


  export const MunicipalityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    departmentId: 'departmentId',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type MunicipalityScalarFieldEnum = (typeof MunicipalityScalarFieldEnum)[keyof typeof MunicipalityScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    municipalityId: 'municipalityId',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    zoneId: 'zoneId',
    addressKms: 'addressKms',
    coordsKms: 'coordsKms',
    instructionsKms: 'instructionsKms',
    domicilePrice: 'domicilePrice',
    deliveryTimeMinutes: 'deliveryTimeMinutes',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ServiceStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ServiceStatusScalarFieldEnum = (typeof ServiceStatusScalarFieldEnum)[keyof typeof ServiceStatusScalarFieldEnum]


  export const PaymentStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type PaymentStatusScalarFieldEnum = (typeof PaymentStatusScalarFieldEnum)[keyof typeof PaymentStatusScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deliveryNameKms: 'deliveryNameKms',
    addressId: 'addressId',
    userPhoneId: 'userPhoneId',
    description: 'description',
    serviceStart: 'serviceStart',
    serviceEnd: 'serviceEnd',
    totalAmount: 'totalAmount',
    currencyId: 'currencyId',
    serviceStatusId: 'serviceStatusId',
    paymentStatusId: 'paymentStatusId',
    comment: 'comment',
    invoiceNumberKms: 'invoiceNumberKms',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceDetailScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    productId: 'productId',
    quantity: 'quantity',
    unitaryPrice: 'unitaryPrice',
    parcialPrice: 'parcialPrice',
    currencyId: 'currencyId',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ServiceDetailScalarFieldEnum = (typeof ServiceDetailScalarFieldEnum)[keyof typeof ServiceDetailScalarFieldEnum]


  export const ServiceExtraScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    unitaryPrice: 'unitaryPrice',
    parcialPrice: 'parcialPrice',
    currencyId: 'currencyId',
    isActive: 'isActive',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ServiceExtraScalarFieldEnum = (typeof ServiceExtraScalarFieldEnum)[keyof typeof ServiceExtraScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: IntFilter<"UserRole"> | number
    name?: StringFilter<"UserRole"> | string
    description?: StringNullableFilter<"UserRole"> | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    users?: UserListRelationFilter
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    name?: StringFilter<"UserRole"> | string
    description?: StringNullableFilter<"UserRole"> | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    users?: UserListRelationFilter
  }, "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRole"> | number
    name?: StringWithAggregatesFilter<"UserRole"> | string
    description?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserRole"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserRole"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    fullNameKms?: StringNullableFilter<"User"> | string | null
    emailSha?: StringNullableFilter<"User"> | string | null
    emailKms?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    passwordSha?: StringFilter<"User"> | string
    passwordKms?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<UserRoleScalarRelationFilter, UserRoleWhereInput>
    blacklists?: BlacklistListRelationFilter
    userPhones?: UserPhoneListRelationFilter
    addresses?: AddressListRelationFilter
    services?: ServiceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullNameKms?: SortOrderInput | SortOrder
    emailSha?: SortOrderInput | SortOrder
    emailKms?: SortOrder
    roleId?: SortOrder
    passwordSha?: SortOrder
    passwordKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    role?: UserRoleOrderByWithRelationInput
    blacklists?: BlacklistOrderByRelationAggregateInput
    userPhones?: UserPhoneOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    emailSha?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullNameKms?: StringNullableFilter<"User"> | string | null
    emailKms?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    passwordSha?: StringFilter<"User"> | string
    passwordKms?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<UserRoleScalarRelationFilter, UserRoleWhereInput>
    blacklists?: BlacklistListRelationFilter
    userPhones?: UserPhoneListRelationFilter
    addresses?: AddressListRelationFilter
    services?: ServiceListRelationFilter
  }, "id" | "emailSha">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullNameKms?: SortOrderInput | SortOrder
    emailSha?: SortOrderInput | SortOrder
    emailKms?: SortOrder
    roleId?: SortOrder
    passwordSha?: SortOrder
    passwordKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    fullNameKms?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailSha?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailKms?: StringWithAggregatesFilter<"User"> | string
    roleId?: IntWithAggregatesFilter<"User"> | number
    passwordSha?: StringWithAggregatesFilter<"User"> | string
    passwordKms?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BlacklistTypeWhereInput = {
    AND?: BlacklistTypeWhereInput | BlacklistTypeWhereInput[]
    OR?: BlacklistTypeWhereInput[]
    NOT?: BlacklistTypeWhereInput | BlacklistTypeWhereInput[]
    id?: IntFilter<"BlacklistType"> | number
    name?: StringFilter<"BlacklistType"> | string
    description?: StringNullableFilter<"BlacklistType"> | string | null
    isActive?: BoolFilter<"BlacklistType"> | boolean
    updatedAt?: DateTimeNullableFilter<"BlacklistType"> | Date | string | null
    createdAt?: DateTimeFilter<"BlacklistType"> | Date | string
    blacklists?: BlacklistListRelationFilter
  }

  export type BlacklistTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    blacklists?: BlacklistOrderByRelationAggregateInput
  }

  export type BlacklistTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlacklistTypeWhereInput | BlacklistTypeWhereInput[]
    OR?: BlacklistTypeWhereInput[]
    NOT?: BlacklistTypeWhereInput | BlacklistTypeWhereInput[]
    name?: StringFilter<"BlacklistType"> | string
    description?: StringNullableFilter<"BlacklistType"> | string | null
    isActive?: BoolFilter<"BlacklistType"> | boolean
    updatedAt?: DateTimeNullableFilter<"BlacklistType"> | Date | string | null
    createdAt?: DateTimeFilter<"BlacklistType"> | Date | string
    blacklists?: BlacklistListRelationFilter
  }, "id">

  export type BlacklistTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlacklistTypeCountOrderByAggregateInput
    _avg?: BlacklistTypeAvgOrderByAggregateInput
    _max?: BlacklistTypeMaxOrderByAggregateInput
    _min?: BlacklistTypeMinOrderByAggregateInput
    _sum?: BlacklistTypeSumOrderByAggregateInput
  }

  export type BlacklistTypeScalarWhereWithAggregatesInput = {
    AND?: BlacklistTypeScalarWhereWithAggregatesInput | BlacklistTypeScalarWhereWithAggregatesInput[]
    OR?: BlacklistTypeScalarWhereWithAggregatesInput[]
    NOT?: BlacklistTypeScalarWhereWithAggregatesInput | BlacklistTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlacklistType"> | number
    name?: StringWithAggregatesFilter<"BlacklistType"> | string
    description?: StringNullableWithAggregatesFilter<"BlacklistType"> | string | null
    isActive?: BoolWithAggregatesFilter<"BlacklistType"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"BlacklistType"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlacklistType"> | Date | string
  }

  export type BlacklistWhereInput = {
    AND?: BlacklistWhereInput | BlacklistWhereInput[]
    OR?: BlacklistWhereInput[]
    NOT?: BlacklistWhereInput | BlacklistWhereInput[]
    id?: IntFilter<"Blacklist"> | number
    userId?: IntFilter<"Blacklist"> | number
    blacklistTypeId?: IntFilter<"Blacklist"> | number
    reason?: StringFilter<"Blacklist"> | string
    isActive?: BoolFilter<"Blacklist"> | boolean
    updatedAt?: DateTimeNullableFilter<"Blacklist"> | Date | string | null
    createdAt?: DateTimeFilter<"Blacklist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    blacklistType?: XOR<BlacklistTypeScalarRelationFilter, BlacklistTypeWhereInput>
  }

  export type BlacklistOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    blacklistType?: BlacklistTypeOrderByWithRelationInput
  }

  export type BlacklistWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlacklistWhereInput | BlacklistWhereInput[]
    OR?: BlacklistWhereInput[]
    NOT?: BlacklistWhereInput | BlacklistWhereInput[]
    userId?: IntFilter<"Blacklist"> | number
    blacklistTypeId?: IntFilter<"Blacklist"> | number
    reason?: StringFilter<"Blacklist"> | string
    isActive?: BoolFilter<"Blacklist"> | boolean
    updatedAt?: DateTimeNullableFilter<"Blacklist"> | Date | string | null
    createdAt?: DateTimeFilter<"Blacklist"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    blacklistType?: XOR<BlacklistTypeScalarRelationFilter, BlacklistTypeWhereInput>
  }, "id">

  export type BlacklistOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BlacklistCountOrderByAggregateInput
    _avg?: BlacklistAvgOrderByAggregateInput
    _max?: BlacklistMaxOrderByAggregateInput
    _min?: BlacklistMinOrderByAggregateInput
    _sum?: BlacklistSumOrderByAggregateInput
  }

  export type BlacklistScalarWhereWithAggregatesInput = {
    AND?: BlacklistScalarWhereWithAggregatesInput | BlacklistScalarWhereWithAggregatesInput[]
    OR?: BlacklistScalarWhereWithAggregatesInput[]
    NOT?: BlacklistScalarWhereWithAggregatesInput | BlacklistScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Blacklist"> | number
    userId?: IntWithAggregatesFilter<"Blacklist"> | number
    blacklistTypeId?: IntWithAggregatesFilter<"Blacklist"> | number
    reason?: StringWithAggregatesFilter<"Blacklist"> | string
    isActive?: BoolWithAggregatesFilter<"Blacklist"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Blacklist"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Blacklist"> | Date | string
  }

  export type UserPhoneTypeWhereInput = {
    AND?: UserPhoneTypeWhereInput | UserPhoneTypeWhereInput[]
    OR?: UserPhoneTypeWhereInput[]
    NOT?: UserPhoneTypeWhereInput | UserPhoneTypeWhereInput[]
    id?: IntFilter<"UserPhoneType"> | number
    type?: StringFilter<"UserPhoneType"> | string
    description?: StringNullableFilter<"UserPhoneType"> | string | null
    isActive?: BoolFilter<"UserPhoneType"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserPhoneType"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPhoneType"> | Date | string
    userPhones?: UserPhoneListRelationFilter
  }

  export type UserPhoneTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userPhones?: UserPhoneOrderByRelationAggregateInput
  }

  export type UserPhoneTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPhoneTypeWhereInput | UserPhoneTypeWhereInput[]
    OR?: UserPhoneTypeWhereInput[]
    NOT?: UserPhoneTypeWhereInput | UserPhoneTypeWhereInput[]
    type?: StringFilter<"UserPhoneType"> | string
    description?: StringNullableFilter<"UserPhoneType"> | string | null
    isActive?: BoolFilter<"UserPhoneType"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserPhoneType"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPhoneType"> | Date | string
    userPhones?: UserPhoneListRelationFilter
  }, "id">

  export type UserPhoneTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserPhoneTypeCountOrderByAggregateInput
    _avg?: UserPhoneTypeAvgOrderByAggregateInput
    _max?: UserPhoneTypeMaxOrderByAggregateInput
    _min?: UserPhoneTypeMinOrderByAggregateInput
    _sum?: UserPhoneTypeSumOrderByAggregateInput
  }

  export type UserPhoneTypeScalarWhereWithAggregatesInput = {
    AND?: UserPhoneTypeScalarWhereWithAggregatesInput | UserPhoneTypeScalarWhereWithAggregatesInput[]
    OR?: UserPhoneTypeScalarWhereWithAggregatesInput[]
    NOT?: UserPhoneTypeScalarWhereWithAggregatesInput | UserPhoneTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPhoneType"> | number
    type?: StringWithAggregatesFilter<"UserPhoneType"> | string
    description?: StringNullableWithAggregatesFilter<"UserPhoneType"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserPhoneType"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserPhoneType"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPhoneType"> | Date | string
  }

  export type UserPhoneWhereInput = {
    AND?: UserPhoneWhereInput | UserPhoneWhereInput[]
    OR?: UserPhoneWhereInput[]
    NOT?: UserPhoneWhereInput | UserPhoneWhereInput[]
    id?: IntFilter<"UserPhone"> | number
    userId?: IntFilter<"UserPhone"> | number
    userPhoneTypeId?: IntFilter<"UserPhone"> | number
    phoneNumberKms?: StringFilter<"UserPhone"> | string
    isPrincipal?: BoolFilter<"UserPhone"> | boolean
    isActive?: BoolFilter<"UserPhone"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    phoneType?: XOR<UserPhoneTypeScalarRelationFilter, UserPhoneTypeWhereInput>
    services?: ServiceListRelationFilter
  }

  export type UserPhoneOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
    phoneNumberKms?: SortOrder
    isPrincipal?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    phoneType?: UserPhoneTypeOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type UserPhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserPhoneWhereInput | UserPhoneWhereInput[]
    OR?: UserPhoneWhereInput[]
    NOT?: UserPhoneWhereInput | UserPhoneWhereInput[]
    userId?: IntFilter<"UserPhone"> | number
    userPhoneTypeId?: IntFilter<"UserPhone"> | number
    phoneNumberKms?: StringFilter<"UserPhone"> | string
    isPrincipal?: BoolFilter<"UserPhone"> | boolean
    isActive?: BoolFilter<"UserPhone"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    phoneType?: XOR<UserPhoneTypeScalarRelationFilter, UserPhoneTypeWhereInput>
    services?: ServiceListRelationFilter
  }, "id">

  export type UserPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
    phoneNumberKms?: SortOrder
    isPrincipal?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserPhoneCountOrderByAggregateInput
    _avg?: UserPhoneAvgOrderByAggregateInput
    _max?: UserPhoneMaxOrderByAggregateInput
    _min?: UserPhoneMinOrderByAggregateInput
    _sum?: UserPhoneSumOrderByAggregateInput
  }

  export type UserPhoneScalarWhereWithAggregatesInput = {
    AND?: UserPhoneScalarWhereWithAggregatesInput | UserPhoneScalarWhereWithAggregatesInput[]
    OR?: UserPhoneScalarWhereWithAggregatesInput[]
    NOT?: UserPhoneScalarWhereWithAggregatesInput | UserPhoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserPhone"> | number
    userId?: IntWithAggregatesFilter<"UserPhone"> | number
    userPhoneTypeId?: IntWithAggregatesFilter<"UserPhone"> | number
    phoneNumberKms?: StringWithAggregatesFilter<"UserPhone"> | string
    isPrincipal?: BoolWithAggregatesFilter<"UserPhone"> | boolean
    isActive?: BoolWithAggregatesFilter<"UserPhone"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UserPhone"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPhone"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: IntFilter<"Currency"> | number
    name?: StringFilter<"Currency"> | string
    description?: StringNullableFilter<"Currency"> | string | null
    symbol?: StringFilter<"Currency"> | string
    iso4217Code?: StringFilter<"Currency"> | string
    isActive?: BoolFilter<"Currency"> | boolean
    updatedAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    products?: ProductListRelationFilter
    services?: ServiceListRelationFilter
    serviceDetails?: ServiceDetailListRelationFilter
    serviceExtras?: ServiceExtraListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    symbol?: SortOrder
    iso4217Code?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    serviceDetails?: ServiceDetailOrderByRelationAggregateInput
    serviceExtras?: ServiceExtraOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    name?: StringFilter<"Currency"> | string
    description?: StringNullableFilter<"Currency"> | string | null
    symbol?: StringFilter<"Currency"> | string
    iso4217Code?: StringFilter<"Currency"> | string
    isActive?: BoolFilter<"Currency"> | boolean
    updatedAt?: DateTimeNullableFilter<"Currency"> | Date | string | null
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    products?: ProductListRelationFilter
    services?: ServiceListRelationFilter
    serviceDetails?: ServiceDetailListRelationFilter
    serviceExtras?: ServiceExtraListRelationFilter
  }, "id">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    symbol?: SortOrder
    iso4217Code?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Currency"> | number
    name?: StringWithAggregatesFilter<"Currency"> | string
    description?: StringNullableWithAggregatesFilter<"Currency"> | string | null
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    iso4217Code?: StringWithAggregatesFilter<"Currency"> | string
    isActive?: BoolWithAggregatesFilter<"Currency"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Currency"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type ProductBusinessTypeWhereInput = {
    AND?: ProductBusinessTypeWhereInput | ProductBusinessTypeWhereInput[]
    OR?: ProductBusinessTypeWhereInput[]
    NOT?: ProductBusinessTypeWhereInput | ProductBusinessTypeWhereInput[]
    id?: IntFilter<"ProductBusinessType"> | number
    name?: StringFilter<"ProductBusinessType"> | string
    description?: StringNullableFilter<"ProductBusinessType"> | string | null
    isActive?: BoolFilter<"ProductBusinessType"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductBusinessType"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductBusinessType"> | Date | string
    products?: ProductListRelationFilter
  }

  export type ProductBusinessTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type ProductBusinessTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductBusinessTypeWhereInput | ProductBusinessTypeWhereInput[]
    OR?: ProductBusinessTypeWhereInput[]
    NOT?: ProductBusinessTypeWhereInput | ProductBusinessTypeWhereInput[]
    name?: StringFilter<"ProductBusinessType"> | string
    description?: StringNullableFilter<"ProductBusinessType"> | string | null
    isActive?: BoolFilter<"ProductBusinessType"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductBusinessType"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductBusinessType"> | Date | string
    products?: ProductListRelationFilter
  }, "id">

  export type ProductBusinessTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductBusinessTypeCountOrderByAggregateInput
    _avg?: ProductBusinessTypeAvgOrderByAggregateInput
    _max?: ProductBusinessTypeMaxOrderByAggregateInput
    _min?: ProductBusinessTypeMinOrderByAggregateInput
    _sum?: ProductBusinessTypeSumOrderByAggregateInput
  }

  export type ProductBusinessTypeScalarWhereWithAggregatesInput = {
    AND?: ProductBusinessTypeScalarWhereWithAggregatesInput | ProductBusinessTypeScalarWhereWithAggregatesInput[]
    OR?: ProductBusinessTypeScalarWhereWithAggregatesInput[]
    NOT?: ProductBusinessTypeScalarWhereWithAggregatesInput | ProductBusinessTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductBusinessType"> | number
    name?: StringWithAggregatesFilter<"ProductBusinessType"> | string
    description?: StringNullableWithAggregatesFilter<"ProductBusinessType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductBusinessType"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductBusinessType"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductBusinessType"> | Date | string
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: IntFilter<"ProductCategory"> | number
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    products?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    products?: ProductListRelationFilter
  }, "id">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _avg?: ProductCategoryAvgOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
    _sum?: ProductCategorySumOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductCategory"> | number
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductCategory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    productBusinessTypeId?: IntFilter<"Product"> | number
    productCategoryId?: IntFilter<"Product"> | number
    rentPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    sellPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    businessType?: XOR<ProductBusinessTypeScalarRelationFilter, ProductBusinessTypeWhereInput>
    category?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    productDetails?: ProductDetailListRelationFilter
    serviceDetails?: ServiceDetailListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrderInput | SortOrder
    sellPrice?: SortOrderInput | SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    businessType?: ProductBusinessTypeOrderByWithRelationInput
    category?: ProductCategoryOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
    productDetails?: ProductDetailOrderByRelationAggregateInput
    serviceDetails?: ServiceDetailOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    productBusinessTypeId?: IntFilter<"Product"> | number
    productCategoryId?: IntFilter<"Product"> | number
    rentPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    sellPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    businessType?: XOR<ProductBusinessTypeScalarRelationFilter, ProductBusinessTypeWhereInput>
    category?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    productDetails?: ProductDetailListRelationFilter
    serviceDetails?: ServiceDetailListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrderInput | SortOrder
    sellPrice?: SortOrderInput | SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    productBusinessTypeId?: IntWithAggregatesFilter<"Product"> | number
    productCategoryId?: IntWithAggregatesFilter<"Product"> | number
    rentPrice?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    sellPrice?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntWithAggregatesFilter<"Product"> | number
    quantity?: IntWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductDetailTypeWhereInput = {
    AND?: ProductDetailTypeWhereInput | ProductDetailTypeWhereInput[]
    OR?: ProductDetailTypeWhereInput[]
    NOT?: ProductDetailTypeWhereInput | ProductDetailTypeWhereInput[]
    id?: IntFilter<"ProductDetailType"> | number
    name?: StringFilter<"ProductDetailType"> | string
    description?: StringNullableFilter<"ProductDetailType"> | string | null
    isActive?: BoolFilter<"ProductDetailType"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductDetailType"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductDetailType"> | Date | string
    productDetails?: ProductDetailListRelationFilter
  }

  export type ProductDetailTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    productDetails?: ProductDetailOrderByRelationAggregateInput
  }

  export type ProductDetailTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductDetailTypeWhereInput | ProductDetailTypeWhereInput[]
    OR?: ProductDetailTypeWhereInput[]
    NOT?: ProductDetailTypeWhereInput | ProductDetailTypeWhereInput[]
    name?: StringFilter<"ProductDetailType"> | string
    description?: StringNullableFilter<"ProductDetailType"> | string | null
    isActive?: BoolFilter<"ProductDetailType"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductDetailType"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductDetailType"> | Date | string
    productDetails?: ProductDetailListRelationFilter
  }, "id">

  export type ProductDetailTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductDetailTypeCountOrderByAggregateInput
    _avg?: ProductDetailTypeAvgOrderByAggregateInput
    _max?: ProductDetailTypeMaxOrderByAggregateInput
    _min?: ProductDetailTypeMinOrderByAggregateInput
    _sum?: ProductDetailTypeSumOrderByAggregateInput
  }

  export type ProductDetailTypeScalarWhereWithAggregatesInput = {
    AND?: ProductDetailTypeScalarWhereWithAggregatesInput | ProductDetailTypeScalarWhereWithAggregatesInput[]
    OR?: ProductDetailTypeScalarWhereWithAggregatesInput[]
    NOT?: ProductDetailTypeScalarWhereWithAggregatesInput | ProductDetailTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductDetailType"> | number
    name?: StringWithAggregatesFilter<"ProductDetailType"> | string
    description?: StringNullableWithAggregatesFilter<"ProductDetailType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductDetailType"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductDetailType"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductDetailType"> | Date | string
  }

  export type ProductDetailWhereInput = {
    AND?: ProductDetailWhereInput | ProductDetailWhereInput[]
    OR?: ProductDetailWhereInput[]
    NOT?: ProductDetailWhereInput | ProductDetailWhereInput[]
    id?: IntFilter<"ProductDetail"> | number
    productId?: IntFilter<"ProductDetail"> | number
    productDetailTypeId?: IntFilter<"ProductDetail"> | number
    detail?: StringFilter<"ProductDetail"> | string
    isActive?: BoolFilter<"ProductDetail"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductDetail"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductDetail"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    detailType?: XOR<ProductDetailTypeScalarRelationFilter, ProductDetailTypeWhereInput>
  }

  export type ProductDetailOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    detailType?: ProductDetailTypeOrderByWithRelationInput
  }

  export type ProductDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductDetailWhereInput | ProductDetailWhereInput[]
    OR?: ProductDetailWhereInput[]
    NOT?: ProductDetailWhereInput | ProductDetailWhereInput[]
    productId?: IntFilter<"ProductDetail"> | number
    productDetailTypeId?: IntFilter<"ProductDetail"> | number
    detail?: StringFilter<"ProductDetail"> | string
    isActive?: BoolFilter<"ProductDetail"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductDetail"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductDetail"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    detailType?: XOR<ProductDetailTypeScalarRelationFilter, ProductDetailTypeWhereInput>
  }, "id">

  export type ProductDetailOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductDetailCountOrderByAggregateInput
    _avg?: ProductDetailAvgOrderByAggregateInput
    _max?: ProductDetailMaxOrderByAggregateInput
    _min?: ProductDetailMinOrderByAggregateInput
    _sum?: ProductDetailSumOrderByAggregateInput
  }

  export type ProductDetailScalarWhereWithAggregatesInput = {
    AND?: ProductDetailScalarWhereWithAggregatesInput | ProductDetailScalarWhereWithAggregatesInput[]
    OR?: ProductDetailScalarWhereWithAggregatesInput[]
    NOT?: ProductDetailScalarWhereWithAggregatesInput | ProductDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductDetail"> | number
    productId?: IntWithAggregatesFilter<"ProductDetail"> | number
    productDetailTypeId?: IntWithAggregatesFilter<"ProductDetail"> | number
    detail?: StringWithAggregatesFilter<"ProductDetail"> | string
    isActive?: BoolWithAggregatesFilter<"ProductDetail"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductDetail"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductDetail"> | Date | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    description?: StringNullableFilter<"Country"> | string | null
    isActive?: BoolFilter<"Country"> | boolean
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    createdAt?: DateTimeFilter<"Country"> | Date | string
    departments?: CountryDepartmentListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    departments?: CountryDepartmentOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    description?: StringNullableFilter<"Country"> | string | null
    isActive?: BoolFilter<"Country"> | boolean
    updatedAt?: DateTimeNullableFilter<"Country"> | Date | string | null
    createdAt?: DateTimeFilter<"Country"> | Date | string
    departments?: CountryDepartmentListRelationFilter
  }, "id">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    description?: StringNullableWithAggregatesFilter<"Country"> | string | null
    isActive?: BoolWithAggregatesFilter<"Country"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Country"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
  }

  export type CountryDepartmentWhereInput = {
    AND?: CountryDepartmentWhereInput | CountryDepartmentWhereInput[]
    OR?: CountryDepartmentWhereInput[]
    NOT?: CountryDepartmentWhereInput | CountryDepartmentWhereInput[]
    id?: IntFilter<"CountryDepartment"> | number
    name?: StringFilter<"CountryDepartment"> | string
    countryId?: IntFilter<"CountryDepartment"> | number
    description?: StringNullableFilter<"CountryDepartment"> | string | null
    isActive?: BoolFilter<"CountryDepartment"> | boolean
    updatedAt?: DateTimeNullableFilter<"CountryDepartment"> | Date | string | null
    createdAt?: DateTimeFilter<"CountryDepartment"> | Date | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    municipalities?: MunicipalityListRelationFilter
  }

  export type CountryDepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    country?: CountryOrderByWithRelationInput
    municipalities?: MunicipalityOrderByRelationAggregateInput
  }

  export type CountryDepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CountryDepartmentWhereInput | CountryDepartmentWhereInput[]
    OR?: CountryDepartmentWhereInput[]
    NOT?: CountryDepartmentWhereInput | CountryDepartmentWhereInput[]
    name?: StringFilter<"CountryDepartment"> | string
    countryId?: IntFilter<"CountryDepartment"> | number
    description?: StringNullableFilter<"CountryDepartment"> | string | null
    isActive?: BoolFilter<"CountryDepartment"> | boolean
    updatedAt?: DateTimeNullableFilter<"CountryDepartment"> | Date | string | null
    createdAt?: DateTimeFilter<"CountryDepartment"> | Date | string
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
    municipalities?: MunicipalityListRelationFilter
  }, "id">

  export type CountryDepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CountryDepartmentCountOrderByAggregateInput
    _avg?: CountryDepartmentAvgOrderByAggregateInput
    _max?: CountryDepartmentMaxOrderByAggregateInput
    _min?: CountryDepartmentMinOrderByAggregateInput
    _sum?: CountryDepartmentSumOrderByAggregateInput
  }

  export type CountryDepartmentScalarWhereWithAggregatesInput = {
    AND?: CountryDepartmentScalarWhereWithAggregatesInput | CountryDepartmentScalarWhereWithAggregatesInput[]
    OR?: CountryDepartmentScalarWhereWithAggregatesInput[]
    NOT?: CountryDepartmentScalarWhereWithAggregatesInput | CountryDepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CountryDepartment"> | number
    name?: StringWithAggregatesFilter<"CountryDepartment"> | string
    countryId?: IntWithAggregatesFilter<"CountryDepartment"> | number
    description?: StringNullableWithAggregatesFilter<"CountryDepartment"> | string | null
    isActive?: BoolWithAggregatesFilter<"CountryDepartment"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CountryDepartment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CountryDepartment"> | Date | string
  }

  export type MunicipalityWhereInput = {
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    id?: IntFilter<"Municipality"> | number
    name?: StringFilter<"Municipality"> | string
    departmentId?: IntFilter<"Municipality"> | number
    description?: StringNullableFilter<"Municipality"> | string | null
    isActive?: BoolFilter<"Municipality"> | boolean
    updatedAt?: DateTimeNullableFilter<"Municipality"> | Date | string | null
    createdAt?: DateTimeFilter<"Municipality"> | Date | string
    department?: XOR<CountryDepartmentScalarRelationFilter, CountryDepartmentWhereInput>
    zones?: ZoneListRelationFilter
  }

  export type MunicipalityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    department?: CountryDepartmentOrderByWithRelationInput
    zones?: ZoneOrderByRelationAggregateInput
  }

  export type MunicipalityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MunicipalityWhereInput | MunicipalityWhereInput[]
    OR?: MunicipalityWhereInput[]
    NOT?: MunicipalityWhereInput | MunicipalityWhereInput[]
    name?: StringFilter<"Municipality"> | string
    departmentId?: IntFilter<"Municipality"> | number
    description?: StringNullableFilter<"Municipality"> | string | null
    isActive?: BoolFilter<"Municipality"> | boolean
    updatedAt?: DateTimeNullableFilter<"Municipality"> | Date | string | null
    createdAt?: DateTimeFilter<"Municipality"> | Date | string
    department?: XOR<CountryDepartmentScalarRelationFilter, CountryDepartmentWhereInput>
    zones?: ZoneListRelationFilter
  }, "id">

  export type MunicipalityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MunicipalityCountOrderByAggregateInput
    _avg?: MunicipalityAvgOrderByAggregateInput
    _max?: MunicipalityMaxOrderByAggregateInput
    _min?: MunicipalityMinOrderByAggregateInput
    _sum?: MunicipalitySumOrderByAggregateInput
  }

  export type MunicipalityScalarWhereWithAggregatesInput = {
    AND?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    OR?: MunicipalityScalarWhereWithAggregatesInput[]
    NOT?: MunicipalityScalarWhereWithAggregatesInput | MunicipalityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Municipality"> | number
    name?: StringWithAggregatesFilter<"Municipality"> | string
    departmentId?: IntWithAggregatesFilter<"Municipality"> | number
    description?: StringNullableWithAggregatesFilter<"Municipality"> | string | null
    isActive?: BoolWithAggregatesFilter<"Municipality"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Municipality"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Municipality"> | Date | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: IntFilter<"Zone"> | number
    name?: StringFilter<"Zone"> | string
    municipalityId?: IntFilter<"Zone"> | number
    description?: StringNullableFilter<"Zone"> | string | null
    isActive?: BoolFilter<"Zone"> | boolean
    updatedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    municipality?: XOR<MunicipalityScalarRelationFilter, MunicipalityWhereInput>
    addresses?: AddressListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    municipality?: MunicipalityOrderByWithRelationInput
    addresses?: AddressOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    municipalityId?: IntFilter<"Zone"> | number
    description?: StringNullableFilter<"Zone"> | string | null
    isActive?: BoolFilter<"Zone"> | boolean
    updatedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    municipality?: XOR<MunicipalityScalarRelationFilter, MunicipalityWhereInput>
    addresses?: AddressListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Zone"> | number
    name?: StringWithAggregatesFilter<"Zone"> | string
    municipalityId?: IntWithAggregatesFilter<"Zone"> | number
    description?: StringNullableWithAggregatesFilter<"Zone"> | string | null
    isActive?: BoolWithAggregatesFilter<"Zone"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Zone"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    userId?: IntFilter<"Address"> | number
    zoneId?: IntFilter<"Address"> | number
    addressKms?: StringFilter<"Address"> | string
    coordsKms?: StringNullableFilter<"Address"> | string | null
    instructionsKms?: StringNullableFilter<"Address"> | string | null
    domicilePrice?: DecimalNullableFilter<"Address"> | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: IntNullableFilter<"Address"> | number | null
    isActive?: BoolFilter<"Address"> | boolean
    updatedAt?: DateTimeNullableFilter<"Address"> | Date | string | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    services?: ServiceListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    addressKms?: SortOrder
    coordsKms?: SortOrderInput | SortOrder
    instructionsKms?: SortOrderInput | SortOrder
    domicilePrice?: SortOrderInput | SortOrder
    deliveryTimeMinutes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    userId?: IntFilter<"Address"> | number
    zoneId?: IntFilter<"Address"> | number
    addressKms?: StringFilter<"Address"> | string
    coordsKms?: StringNullableFilter<"Address"> | string | null
    instructionsKms?: StringNullableFilter<"Address"> | string | null
    domicilePrice?: DecimalNullableFilter<"Address"> | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: IntNullableFilter<"Address"> | number | null
    isActive?: BoolFilter<"Address"> | boolean
    updatedAt?: DateTimeNullableFilter<"Address"> | Date | string | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, ZoneWhereInput>
    services?: ServiceListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    addressKms?: SortOrder
    coordsKms?: SortOrderInput | SortOrder
    instructionsKms?: SortOrderInput | SortOrder
    domicilePrice?: SortOrderInput | SortOrder
    deliveryTimeMinutes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    userId?: IntWithAggregatesFilter<"Address"> | number
    zoneId?: IntWithAggregatesFilter<"Address"> | number
    addressKms?: StringWithAggregatesFilter<"Address"> | string
    coordsKms?: StringNullableWithAggregatesFilter<"Address"> | string | null
    instructionsKms?: StringNullableWithAggregatesFilter<"Address"> | string | null
    domicilePrice?: DecimalNullableWithAggregatesFilter<"Address"> | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: IntNullableWithAggregatesFilter<"Address"> | number | null
    isActive?: BoolWithAggregatesFilter<"Address"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Address"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type ServiceStatusWhereInput = {
    AND?: ServiceStatusWhereInput | ServiceStatusWhereInput[]
    OR?: ServiceStatusWhereInput[]
    NOT?: ServiceStatusWhereInput | ServiceStatusWhereInput[]
    id?: IntFilter<"ServiceStatus"> | number
    name?: StringFilter<"ServiceStatus"> | string
    description?: StringNullableFilter<"ServiceStatus"> | string | null
    isActive?: BoolFilter<"ServiceStatus"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceStatus"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceStatus"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type ServiceStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type ServiceStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceStatusWhereInput | ServiceStatusWhereInput[]
    OR?: ServiceStatusWhereInput[]
    NOT?: ServiceStatusWhereInput | ServiceStatusWhereInput[]
    name?: StringFilter<"ServiceStatus"> | string
    description?: StringNullableFilter<"ServiceStatus"> | string | null
    isActive?: BoolFilter<"ServiceStatus"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceStatus"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceStatus"> | Date | string
    services?: ServiceListRelationFilter
  }, "id">

  export type ServiceStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceStatusCountOrderByAggregateInput
    _avg?: ServiceStatusAvgOrderByAggregateInput
    _max?: ServiceStatusMaxOrderByAggregateInput
    _min?: ServiceStatusMinOrderByAggregateInput
    _sum?: ServiceStatusSumOrderByAggregateInput
  }

  export type ServiceStatusScalarWhereWithAggregatesInput = {
    AND?: ServiceStatusScalarWhereWithAggregatesInput | ServiceStatusScalarWhereWithAggregatesInput[]
    OR?: ServiceStatusScalarWhereWithAggregatesInput[]
    NOT?: ServiceStatusScalarWhereWithAggregatesInput | ServiceStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceStatus"> | number
    name?: StringWithAggregatesFilter<"ServiceStatus"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceStatus"> | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceStatus"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ServiceStatus"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceStatus"> | Date | string
  }

  export type PaymentStatusWhereInput = {
    AND?: PaymentStatusWhereInput | PaymentStatusWhereInput[]
    OR?: PaymentStatusWhereInput[]
    NOT?: PaymentStatusWhereInput | PaymentStatusWhereInput[]
    id?: IntFilter<"PaymentStatus"> | number
    name?: StringFilter<"PaymentStatus"> | string
    description?: StringNullableFilter<"PaymentStatus"> | string | null
    isActive?: BoolFilter<"PaymentStatus"> | boolean
    updatedAt?: DateTimeNullableFilter<"PaymentStatus"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentStatus"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type PaymentStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type PaymentStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentStatusWhereInput | PaymentStatusWhereInput[]
    OR?: PaymentStatusWhereInput[]
    NOT?: PaymentStatusWhereInput | PaymentStatusWhereInput[]
    name?: StringFilter<"PaymentStatus"> | string
    description?: StringNullableFilter<"PaymentStatus"> | string | null
    isActive?: BoolFilter<"PaymentStatus"> | boolean
    updatedAt?: DateTimeNullableFilter<"PaymentStatus"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentStatus"> | Date | string
    services?: ServiceListRelationFilter
  }, "id">

  export type PaymentStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentStatusCountOrderByAggregateInput
    _avg?: PaymentStatusAvgOrderByAggregateInput
    _max?: PaymentStatusMaxOrderByAggregateInput
    _min?: PaymentStatusMinOrderByAggregateInput
    _sum?: PaymentStatusSumOrderByAggregateInput
  }

  export type PaymentStatusScalarWhereWithAggregatesInput = {
    AND?: PaymentStatusScalarWhereWithAggregatesInput | PaymentStatusScalarWhereWithAggregatesInput[]
    OR?: PaymentStatusScalarWhereWithAggregatesInput[]
    NOT?: PaymentStatusScalarWhereWithAggregatesInput | PaymentStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentStatus"> | number
    name?: StringWithAggregatesFilter<"PaymentStatus"> | string
    description?: StringNullableWithAggregatesFilter<"PaymentStatus"> | string | null
    isActive?: BoolWithAggregatesFilter<"PaymentStatus"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PaymentStatus"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentStatus"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    userId?: IntFilter<"Service"> | number
    deliveryNameKms?: StringFilter<"Service"> | string
    addressId?: IntFilter<"Service"> | number
    userPhoneId?: IntFilter<"Service"> | number
    description?: StringNullableFilter<"Service"> | string | null
    serviceStart?: DateTimeFilter<"Service"> | Date | string
    serviceEnd?: DateTimeFilter<"Service"> | Date | string
    totalAmount?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntFilter<"Service"> | number
    serviceStatusId?: IntFilter<"Service"> | number
    paymentStatusId?: IntFilter<"Service"> | number
    comment?: StringNullableFilter<"Service"> | string | null
    invoiceNumberKms?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    updatedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    userPhone?: XOR<UserPhoneScalarRelationFilter, UserPhoneWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    serviceStatus?: XOR<ServiceStatusScalarRelationFilter, ServiceStatusWhereInput>
    paymentStatus?: XOR<PaymentStatusScalarRelationFilter, PaymentStatusWhereInput>
    serviceDetails?: ServiceDetailListRelationFilter
    serviceExtras?: ServiceExtraListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryNameKms?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    description?: SortOrderInput | SortOrder
    serviceStart?: SortOrder
    serviceEnd?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
    comment?: SortOrderInput | SortOrder
    invoiceNumberKms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
    userPhone?: UserPhoneOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
    serviceStatus?: ServiceStatusOrderByWithRelationInput
    paymentStatus?: PaymentStatusOrderByWithRelationInput
    serviceDetails?: ServiceDetailOrderByRelationAggregateInput
    serviceExtras?: ServiceExtraOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    userId?: IntFilter<"Service"> | number
    deliveryNameKms?: StringFilter<"Service"> | string
    addressId?: IntFilter<"Service"> | number
    userPhoneId?: IntFilter<"Service"> | number
    description?: StringNullableFilter<"Service"> | string | null
    serviceStart?: DateTimeFilter<"Service"> | Date | string
    serviceEnd?: DateTimeFilter<"Service"> | Date | string
    totalAmount?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntFilter<"Service"> | number
    serviceStatusId?: IntFilter<"Service"> | number
    paymentStatusId?: IntFilter<"Service"> | number
    comment?: StringNullableFilter<"Service"> | string | null
    invoiceNumberKms?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    updatedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    address?: XOR<AddressScalarRelationFilter, AddressWhereInput>
    userPhone?: XOR<UserPhoneScalarRelationFilter, UserPhoneWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    serviceStatus?: XOR<ServiceStatusScalarRelationFilter, ServiceStatusWhereInput>
    paymentStatus?: XOR<PaymentStatusScalarRelationFilter, PaymentStatusWhereInput>
    serviceDetails?: ServiceDetailListRelationFilter
    serviceExtras?: ServiceExtraListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryNameKms?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    description?: SortOrderInput | SortOrder
    serviceStart?: SortOrder
    serviceEnd?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
    comment?: SortOrderInput | SortOrder
    invoiceNumberKms?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    userId?: IntWithAggregatesFilter<"Service"> | number
    deliveryNameKms?: StringWithAggregatesFilter<"Service"> | string
    addressId?: IntWithAggregatesFilter<"Service"> | number
    userPhoneId?: IntWithAggregatesFilter<"Service"> | number
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    serviceStart?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    serviceEnd?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntWithAggregatesFilter<"Service"> | number
    serviceStatusId?: IntWithAggregatesFilter<"Service"> | number
    paymentStatusId?: IntWithAggregatesFilter<"Service"> | number
    comment?: StringNullableWithAggregatesFilter<"Service"> | string | null
    invoiceNumberKms?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServiceDetailWhereInput = {
    AND?: ServiceDetailWhereInput | ServiceDetailWhereInput[]
    OR?: ServiceDetailWhereInput[]
    NOT?: ServiceDetailWhereInput | ServiceDetailWhereInput[]
    id?: IntFilter<"ServiceDetail"> | number
    serviceId?: IntFilter<"ServiceDetail"> | number
    productId?: IntFilter<"ServiceDetail"> | number
    quantity?: IntFilter<"ServiceDetail"> | number
    unitaryPrice?: DecimalFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntFilter<"ServiceDetail"> | number
    isActive?: BoolFilter<"ServiceDetail"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceDetail"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceDetail"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type ServiceDetailOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
  }

  export type ServiceDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceDetailWhereInput | ServiceDetailWhereInput[]
    OR?: ServiceDetailWhereInput[]
    NOT?: ServiceDetailWhereInput | ServiceDetailWhereInput[]
    serviceId?: IntFilter<"ServiceDetail"> | number
    productId?: IntFilter<"ServiceDetail"> | number
    quantity?: IntFilter<"ServiceDetail"> | number
    unitaryPrice?: DecimalFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntFilter<"ServiceDetail"> | number
    isActive?: BoolFilter<"ServiceDetail"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceDetail"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceDetail"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "id">

  export type ServiceDetailOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceDetailCountOrderByAggregateInput
    _avg?: ServiceDetailAvgOrderByAggregateInput
    _max?: ServiceDetailMaxOrderByAggregateInput
    _min?: ServiceDetailMinOrderByAggregateInput
    _sum?: ServiceDetailSumOrderByAggregateInput
  }

  export type ServiceDetailScalarWhereWithAggregatesInput = {
    AND?: ServiceDetailScalarWhereWithAggregatesInput | ServiceDetailScalarWhereWithAggregatesInput[]
    OR?: ServiceDetailScalarWhereWithAggregatesInput[]
    NOT?: ServiceDetailScalarWhereWithAggregatesInput | ServiceDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceDetail"> | number
    serviceId?: IntWithAggregatesFilter<"ServiceDetail"> | number
    productId?: IntWithAggregatesFilter<"ServiceDetail"> | number
    quantity?: IntWithAggregatesFilter<"ServiceDetail"> | number
    unitaryPrice?: DecimalWithAggregatesFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalWithAggregatesFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntWithAggregatesFilter<"ServiceDetail"> | number
    isActive?: BoolWithAggregatesFilter<"ServiceDetail"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ServiceDetail"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceDetail"> | Date | string
  }

  export type ServiceExtraWhereInput = {
    AND?: ServiceExtraWhereInput | ServiceExtraWhereInput[]
    OR?: ServiceExtraWhereInput[]
    NOT?: ServiceExtraWhereInput | ServiceExtraWhereInput[]
    id?: IntFilter<"ServiceExtra"> | number
    serviceId?: IntFilter<"ServiceExtra"> | number
    name?: StringFilter<"ServiceExtra"> | string
    description?: StringNullableFilter<"ServiceExtra"> | string | null
    quantity?: IntNullableFilter<"ServiceExtra"> | number | null
    unitaryPrice?: DecimalNullableFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: DecimalNullableFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntNullableFilter<"ServiceExtra"> | number | null
    isActive?: BoolFilter<"ServiceExtra"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceExtra"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceExtra"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
  }

  export type ServiceExtraOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitaryPrice?: SortOrderInput | SortOrder
    parcialPrice?: SortOrderInput | SortOrder
    currencyId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
  }

  export type ServiceExtraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceExtraWhereInput | ServiceExtraWhereInput[]
    OR?: ServiceExtraWhereInput[]
    NOT?: ServiceExtraWhereInput | ServiceExtraWhereInput[]
    serviceId?: IntFilter<"ServiceExtra"> | number
    name?: StringFilter<"ServiceExtra"> | string
    description?: StringNullableFilter<"ServiceExtra"> | string | null
    quantity?: IntNullableFilter<"ServiceExtra"> | number | null
    unitaryPrice?: DecimalNullableFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: DecimalNullableFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntNullableFilter<"ServiceExtra"> | number | null
    isActive?: BoolFilter<"ServiceExtra"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceExtra"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceExtra"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
  }, "id">

  export type ServiceExtraOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitaryPrice?: SortOrderInput | SortOrder
    parcialPrice?: SortOrderInput | SortOrder
    currencyId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ServiceExtraCountOrderByAggregateInput
    _avg?: ServiceExtraAvgOrderByAggregateInput
    _max?: ServiceExtraMaxOrderByAggregateInput
    _min?: ServiceExtraMinOrderByAggregateInput
    _sum?: ServiceExtraSumOrderByAggregateInput
  }

  export type ServiceExtraScalarWhereWithAggregatesInput = {
    AND?: ServiceExtraScalarWhereWithAggregatesInput | ServiceExtraScalarWhereWithAggregatesInput[]
    OR?: ServiceExtraScalarWhereWithAggregatesInput[]
    NOT?: ServiceExtraScalarWhereWithAggregatesInput | ServiceExtraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceExtra"> | number
    serviceId?: IntWithAggregatesFilter<"ServiceExtra"> | number
    name?: StringWithAggregatesFilter<"ServiceExtra"> | string
    description?: StringNullableWithAggregatesFilter<"ServiceExtra"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"ServiceExtra"> | number | null
    unitaryPrice?: DecimalNullableWithAggregatesFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: DecimalNullableWithAggregatesFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntNullableWithAggregatesFilter<"ServiceExtra"> | number | null
    isActive?: BoolWithAggregatesFilter<"ServiceExtra"> | boolean
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ServiceExtra"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceExtra"> | Date | string
  }

  export type UserRoleCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type UserRoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserRoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    role: UserRoleCreateNestedOneWithoutUsersInput
    blacklists?: BlacklistCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: UserRoleUpdateOneRequiredWithoutUsersNestedInput
    blacklists?: BlacklistUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistTypeCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistCreateNestedManyWithoutBlacklistTypeInput
  }

  export type BlacklistTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistUncheckedCreateNestedManyWithoutBlacklistTypeInput
  }

  export type BlacklistTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUpdateManyWithoutBlacklistTypeNestedInput
  }

  export type BlacklistTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUncheckedUpdateManyWithoutBlacklistTypeNestedInput
  }

  export type BlacklistTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistCreateInput = {
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBlacklistsInput
    blacklistType: BlacklistTypeCreateNestedOneWithoutBlacklistsInput
  }

  export type BlacklistUncheckedCreateInput = {
    id?: number
    userId: number
    blacklistTypeId: number
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlacklistsNestedInput
    blacklistType?: BlacklistTypeUpdateOneRequiredWithoutBlacklistsNestedInput
  }

  export type BlacklistUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    blacklistTypeId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistCreateManyInput = {
    id?: number
    userId: number
    blacklistTypeId: number
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    blacklistTypeId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneTypeCreateInput = {
    type: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    userPhones?: UserPhoneCreateNestedManyWithoutPhoneTypeInput
  }

  export type UserPhoneTypeUncheckedCreateInput = {
    id?: number
    type: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    userPhones?: UserPhoneUncheckedCreateNestedManyWithoutPhoneTypeInput
  }

  export type UserPhoneTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPhones?: UserPhoneUpdateManyWithoutPhoneTypeNestedInput
  }

  export type UserPhoneTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPhones?: UserPhoneUncheckedUpdateManyWithoutPhoneTypeNestedInput
  }

  export type UserPhoneTypeCreateManyInput = {
    id?: number
    type: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateInput = {
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhonesInput
    phoneType: UserPhoneTypeCreateNestedOneWithoutUserPhonesInput
    services?: ServiceCreateNestedManyWithoutUserPhoneInput
  }

  export type UserPhoneUncheckedCreateInput = {
    id?: number
    userId: number
    userPhoneTypeId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutUserPhoneInput
  }

  export type UserPhoneUpdateInput = {
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhonesNestedInput
    phoneType?: UserPhoneTypeUpdateOneRequiredWithoutUserPhonesNestedInput
    services?: ServiceUpdateManyWithoutUserPhoneNestedInput
  }

  export type UserPhoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userPhoneTypeId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutUserPhoneNestedInput
  }

  export type UserPhoneCreateManyInput = {
    id?: number
    userId: number
    userPhoneTypeId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneUpdateManyMutationInput = {
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userPhoneTypeId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutCurrencyInput
    services?: ServiceCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCurrencyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCurrencyNestedInput
    services?: ServiceUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCurrencyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBusinessTypeCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutBusinessTypeInput
  }

  export type ProductBusinessTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutBusinessTypeInput
  }

  export type ProductBusinessTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutBusinessTypeNestedInput
  }

  export type ProductBusinessTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutBusinessTypeNestedInput
  }

  export type ProductBusinessTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductBusinessTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBusinessTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    businessType: ProductBusinessTypeCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    currency: CurrencyCreateNestedOneWithoutProductsInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: ProductBusinessTypeUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutProductsNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailTypeCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailCreateNestedManyWithoutDetailTypeInput
  }

  export type ProductDetailTypeUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutDetailTypeInput
  }

  export type ProductDetailTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUpdateManyWithoutDetailTypeNestedInput
  }

  export type ProductDetailTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUncheckedUpdateManyWithoutDetailTypeNestedInput
  }

  export type ProductDetailTypeCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailCreateInput = {
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductDetailsInput
    detailType: ProductDetailTypeCreateNestedOneWithoutProductDetailsInput
  }

  export type ProductDetailUncheckedCreateInput = {
    id?: number
    productId: number
    productDetailTypeId: number
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailUpdateInput = {
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductDetailsNestedInput
    detailType?: ProductDetailTypeUpdateOneRequiredWithoutProductDetailsNestedInput
  }

  export type ProductDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    productDetailTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailCreateManyInput = {
    id?: number
    productId: number
    productDetailTypeId: number
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailUpdateManyMutationInput = {
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    productDetailTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    departments?: CountryDepartmentCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    departments?: CountryDepartmentUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: CountryDepartmentUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: CountryDepartmentUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryDepartmentCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    country: CountryCreateNestedOneWithoutDepartmentsInput
    municipalities?: MunicipalityCreateNestedManyWithoutDepartmentInput
  }

  export type CountryDepartmentUncheckedCreateInput = {
    id?: number
    name: string
    countryId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type CountryDepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutDepartmentsNestedInput
    municipalities?: MunicipalityUpdateManyWithoutDepartmentNestedInput
  }

  export type CountryDepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalities?: MunicipalityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type CountryDepartmentCreateManyInput = {
    id?: number
    name: string
    countryId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CountryDepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryDepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    department: CountryDepartmentCreateNestedOneWithoutMunicipalitiesInput
    zones?: ZoneCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateInput = {
    id?: number
    name: string
    departmentId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    zones?: ZoneUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: CountryDepartmentUpdateOneRequiredWithoutMunicipalitiesNestedInput
    zones?: ZoneUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityCreateManyInput = {
    id?: number
    name: string
    departmentId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MunicipalityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    municipality: MunicipalityCreateNestedOneWithoutZonesInput
    addresses?: AddressCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: number
    name: string
    municipalityId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipality?: MunicipalityUpdateOneRequiredWithoutZonesNestedInput
    addresses?: AddressUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: number
    name: string
    municipalityId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ZoneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    zone: ZoneCreateNestedOneWithoutAddressesInput
    services?: ServiceCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    userId: number
    zoneId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutAddressesNestedInput
    services?: ServiceUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    userId: number
    zoneId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceCreateNestedManyWithoutServiceStatusInput
  }

  export type ServiceStatusUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutServiceStatusInput
  }

  export type ServiceStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutServiceStatusNestedInput
  }

  export type ServiceStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutServiceStatusNestedInput
  }

  export type ServiceStatusCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentStatusCreateInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceCreateNestedManyWithoutPaymentStatusInput
  }

  export type PaymentStatusUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutPaymentStatusInput
  }

  export type PaymentStatusUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutPaymentStatusNestedInput
  }

  export type PaymentStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutPaymentStatusNestedInput
  }

  export type PaymentStatusCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentStatusUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailCreateInput = {
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutServiceDetailsInput
    product: ProductCreateNestedOneWithoutServiceDetailsInput
    currency: CurrencyCreateNestedOneWithoutServiceDetailsInput
  }

  export type ServiceDetailUncheckedCreateInput = {
    id?: number
    serviceId: number
    productId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    currencyId: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServiceDetailsNestedInput
    product?: ProductUpdateOneRequiredWithoutServiceDetailsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServiceDetailsNestedInput
  }

  export type ServiceDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailCreateManyInput = {
    id?: number
    serviceId: number
    productId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    currencyId: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraCreateInput = {
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutServiceExtrasInput
    currency?: CurrencyCreateNestedOneWithoutServiceExtrasInput
  }

  export type ServiceExtraUncheckedCreateInput = {
    id?: number
    serviceId: number
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceExtraUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServiceExtrasNestedInput
    currency?: CurrencyUpdateOneWithoutServiceExtrasNestedInput
  }

  export type ServiceExtraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraCreateManyInput = {
    id?: number
    serviceId: number
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceExtraUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRoleScalarRelationFilter = {
    is?: UserRoleWhereInput
    isNot?: UserRoleWhereInput
  }

  export type BlacklistListRelationFilter = {
    every?: BlacklistWhereInput
    some?: BlacklistWhereInput
    none?: BlacklistWhereInput
  }

  export type UserPhoneListRelationFilter = {
    every?: UserPhoneWhereInput
    some?: UserPhoneWhereInput
    none?: UserPhoneWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type BlacklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullNameKms?: SortOrder
    emailSha?: SortOrder
    emailKms?: SortOrder
    roleId?: SortOrder
    passwordSha?: SortOrder
    passwordKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullNameKms?: SortOrder
    emailSha?: SortOrder
    emailKms?: SortOrder
    roleId?: SortOrder
    passwordSha?: SortOrder
    passwordKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullNameKms?: SortOrder
    emailSha?: SortOrder
    emailKms?: SortOrder
    roleId?: SortOrder
    passwordSha?: SortOrder
    passwordKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type BlacklistTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlacklistTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BlacklistTypeScalarRelationFilter = {
    is?: BlacklistTypeWhereInput
    isNot?: BlacklistTypeWhereInput
  }

  export type BlacklistCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
  }

  export type BlacklistMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BlacklistSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    blacklistTypeId?: SortOrder
  }

  export type UserPhoneTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhoneTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserPhoneTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhoneTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhoneTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserPhoneTypeScalarRelationFilter = {
    is?: UserPhoneTypeWhereInput
    isNot?: UserPhoneTypeWhereInput
  }

  export type UserPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
    phoneNumberKms?: SortOrder
    isPrincipal?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhoneAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
  }

  export type UserPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
    phoneNumberKms?: SortOrder
    isPrincipal?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
    phoneNumberKms?: SortOrder
    isPrincipal?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserPhoneSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userPhoneTypeId?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ServiceDetailListRelationFilter = {
    every?: ServiceDetailWhereInput
    some?: ServiceDetailWhereInput
    none?: ServiceDetailWhereInput
  }

  export type ServiceExtraListRelationFilter = {
    every?: ServiceExtraWhereInput
    some?: ServiceExtraWhereInput
    none?: ServiceExtraWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceExtraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    iso4217Code?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    iso4217Code?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symbol?: SortOrder
    iso4217Code?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductBusinessTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductBusinessTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductBusinessTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductBusinessTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductBusinessTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductBusinessTypeScalarRelationFilter = {
    is?: ProductBusinessTypeWhereInput
    isNot?: ProductBusinessTypeWhereInput
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type ProductDetailListRelationFilter = {
    every?: ProductDetailWhereInput
    some?: ProductDetailWhereInput
    none?: ProductDetailWhereInput
  }

  export type ProductDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrder
    sellPrice?: SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrder
    sellPrice?: SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrder
    sellPrice?: SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrder
    sellPrice?: SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    productBusinessTypeId?: SortOrder
    productCategoryId?: SortOrder
    rentPrice?: SortOrder
    sellPrice?: SortOrder
    currencyId?: SortOrder
    quantity?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ProductDetailTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductDetailTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductDetailTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductDetailTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductDetailTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductDetailTypeScalarRelationFilter = {
    is?: ProductDetailTypeWhereInput
    isNot?: ProductDetailTypeWhereInput
  }

  export type ProductDetailCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
  }

  export type ProductDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductDetailMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
    detail?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductDetailSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    productDetailTypeId?: SortOrder
  }

  export type CountryDepartmentListRelationFilter = {
    every?: CountryDepartmentWhereInput
    some?: CountryDepartmentWhereInput
    none?: CountryDepartmentWhereInput
  }

  export type CountryDepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type MunicipalityListRelationFilter = {
    every?: MunicipalityWhereInput
    some?: MunicipalityWhereInput
    none?: MunicipalityWhereInput
  }

  export type MunicipalityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryDepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CountryDepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CountryDepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CountryDepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CountryDepartmentSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type CountryDepartmentScalarRelationFilter = {
    is?: CountryDepartmentWhereInput
    isNot?: CountryDepartmentWhereInput
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MunicipalityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MunicipalityAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type MunicipalityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MunicipalityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MunicipalitySumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type MunicipalityScalarRelationFilter = {
    is?: MunicipalityWhereInput
    isNot?: MunicipalityWhereInput
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    id?: SortOrder
    municipalityId?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    municipalityId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    id?: SortOrder
    municipalityId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ZoneScalarRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    addressKms?: SortOrder
    coordsKms?: SortOrder
    instructionsKms?: SortOrder
    domicilePrice?: SortOrder
    deliveryTimeMinutes?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    domicilePrice?: SortOrder
    deliveryTimeMinutes?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    addressKms?: SortOrder
    coordsKms?: SortOrder
    instructionsKms?: SortOrder
    domicilePrice?: SortOrder
    deliveryTimeMinutes?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    addressKms?: SortOrder
    coordsKms?: SortOrder
    instructionsKms?: SortOrder
    domicilePrice?: SortOrder
    deliveryTimeMinutes?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    domicilePrice?: SortOrder
    deliveryTimeMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ServiceStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaymentStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AddressScalarRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type UserPhoneScalarRelationFilter = {
    is?: UserPhoneWhereInput
    isNot?: UserPhoneWhereInput
  }

  export type ServiceStatusScalarRelationFilter = {
    is?: ServiceStatusWhereInput
    isNot?: ServiceStatusWhereInput
  }

  export type PaymentStatusScalarRelationFilter = {
    is?: PaymentStatusWhereInput
    isNot?: PaymentStatusWhereInput
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryNameKms?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    description?: SortOrder
    serviceStart?: SortOrder
    serviceEnd?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
    comment?: SortOrder
    invoiceNumberKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryNameKms?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    description?: SortOrder
    serviceStart?: SortOrder
    serviceEnd?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
    comment?: SortOrder
    invoiceNumberKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryNameKms?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    description?: SortOrder
    serviceStart?: SortOrder
    serviceEnd?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
    comment?: SortOrder
    invoiceNumberKms?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    addressId?: SortOrder
    userPhoneId?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    serviceStatusId?: SortOrder
    paymentStatusId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceDetailCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
  }

  export type ServiceDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceDetailMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceDetailSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
  }

  export type CurrencyNullableScalarRelationFilter = {
    is?: CurrencyWhereInput | null
    isNot?: CurrencyWhereInput | null
  }

  export type ServiceExtraCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceExtraAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
  }

  export type ServiceExtraMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceExtraMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceExtraSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    unitaryPrice?: SortOrder
    parcialPrice?: SortOrder
    currencyId?: SortOrder
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserRoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput
    connect?: UserRoleWhereUniqueInput
  }

  export type BlacklistCreateNestedManyWithoutUserInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type UserPhoneCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type BlacklistUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type UserPhoneUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type UserRoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput
    upsert?: UserRoleUpsertWithoutUsersInput
    connect?: UserRoleWhereUniqueInput
    update?: XOR<XOR<UserRoleUpdateToOneWithWhereWithoutUsersInput, UserRoleUpdateWithoutUsersInput>, UserRoleUncheckedUpdateWithoutUsersInput>
  }

  export type BlacklistUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutUserInput | BlacklistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutUserInput | BlacklistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutUserInput | BlacklistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type UserPhoneUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    upsert?: UserPhoneUpsertWithWhereUniqueWithoutUserInput | UserPhoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    set?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    disconnect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    delete?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    update?: UserPhoneUpdateWithWhereUniqueWithoutUserInput | UserPhoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhoneUpdateManyWithWhereWithoutUserInput | UserPhoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BlacklistUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput> | BlacklistCreateWithoutUserInput[] | BlacklistUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutUserInput | BlacklistCreateOrConnectWithoutUserInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutUserInput | BlacklistUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlacklistCreateManyUserInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutUserInput | BlacklistUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutUserInput | BlacklistUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type UserPhoneUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput> | UserPhoneCreateWithoutUserInput[] | UserPhoneUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput | UserPhoneCreateOrConnectWithoutUserInput[]
    upsert?: UserPhoneUpsertWithWhereUniqueWithoutUserInput | UserPhoneUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPhoneCreateManyUserInputEnvelope
    set?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    disconnect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    delete?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    update?: UserPhoneUpdateWithWhereUniqueWithoutUserInput | UserPhoneUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPhoneUpdateManyWithWhereWithoutUserInput | UserPhoneUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type BlacklistCreateNestedManyWithoutBlacklistTypeInput = {
    create?: XOR<BlacklistCreateWithoutBlacklistTypeInput, BlacklistUncheckedCreateWithoutBlacklistTypeInput> | BlacklistCreateWithoutBlacklistTypeInput[] | BlacklistUncheckedCreateWithoutBlacklistTypeInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutBlacklistTypeInput | BlacklistCreateOrConnectWithoutBlacklistTypeInput[]
    createMany?: BlacklistCreateManyBlacklistTypeInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type BlacklistUncheckedCreateNestedManyWithoutBlacklistTypeInput = {
    create?: XOR<BlacklistCreateWithoutBlacklistTypeInput, BlacklistUncheckedCreateWithoutBlacklistTypeInput> | BlacklistCreateWithoutBlacklistTypeInput[] | BlacklistUncheckedCreateWithoutBlacklistTypeInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutBlacklistTypeInput | BlacklistCreateOrConnectWithoutBlacklistTypeInput[]
    createMany?: BlacklistCreateManyBlacklistTypeInputEnvelope
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
  }

  export type BlacklistUpdateManyWithoutBlacklistTypeNestedInput = {
    create?: XOR<BlacklistCreateWithoutBlacklistTypeInput, BlacklistUncheckedCreateWithoutBlacklistTypeInput> | BlacklistCreateWithoutBlacklistTypeInput[] | BlacklistUncheckedCreateWithoutBlacklistTypeInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutBlacklistTypeInput | BlacklistCreateOrConnectWithoutBlacklistTypeInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutBlacklistTypeInput | BlacklistUpsertWithWhereUniqueWithoutBlacklistTypeInput[]
    createMany?: BlacklistCreateManyBlacklistTypeInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutBlacklistTypeInput | BlacklistUpdateWithWhereUniqueWithoutBlacklistTypeInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutBlacklistTypeInput | BlacklistUpdateManyWithWhereWithoutBlacklistTypeInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type BlacklistUncheckedUpdateManyWithoutBlacklistTypeNestedInput = {
    create?: XOR<BlacklistCreateWithoutBlacklistTypeInput, BlacklistUncheckedCreateWithoutBlacklistTypeInput> | BlacklistCreateWithoutBlacklistTypeInput[] | BlacklistUncheckedCreateWithoutBlacklistTypeInput[]
    connectOrCreate?: BlacklistCreateOrConnectWithoutBlacklistTypeInput | BlacklistCreateOrConnectWithoutBlacklistTypeInput[]
    upsert?: BlacklistUpsertWithWhereUniqueWithoutBlacklistTypeInput | BlacklistUpsertWithWhereUniqueWithoutBlacklistTypeInput[]
    createMany?: BlacklistCreateManyBlacklistTypeInputEnvelope
    set?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    disconnect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    delete?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    connect?: BlacklistWhereUniqueInput | BlacklistWhereUniqueInput[]
    update?: BlacklistUpdateWithWhereUniqueWithoutBlacklistTypeInput | BlacklistUpdateWithWhereUniqueWithoutBlacklistTypeInput[]
    updateMany?: BlacklistUpdateManyWithWhereWithoutBlacklistTypeInput | BlacklistUpdateManyWithWhereWithoutBlacklistTypeInput[]
    deleteMany?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlacklistsInput = {
    create?: XOR<UserCreateWithoutBlacklistsInput, UserUncheckedCreateWithoutBlacklistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlacklistsInput
    connect?: UserWhereUniqueInput
  }

  export type BlacklistTypeCreateNestedOneWithoutBlacklistsInput = {
    create?: XOR<BlacklistTypeCreateWithoutBlacklistsInput, BlacklistTypeUncheckedCreateWithoutBlacklistsInput>
    connectOrCreate?: BlacklistTypeCreateOrConnectWithoutBlacklistsInput
    connect?: BlacklistTypeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlacklistsNestedInput = {
    create?: XOR<UserCreateWithoutBlacklistsInput, UserUncheckedCreateWithoutBlacklistsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlacklistsInput
    upsert?: UserUpsertWithoutBlacklistsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlacklistsInput, UserUpdateWithoutBlacklistsInput>, UserUncheckedUpdateWithoutBlacklistsInput>
  }

  export type BlacklistTypeUpdateOneRequiredWithoutBlacklistsNestedInput = {
    create?: XOR<BlacklistTypeCreateWithoutBlacklistsInput, BlacklistTypeUncheckedCreateWithoutBlacklistsInput>
    connectOrCreate?: BlacklistTypeCreateOrConnectWithoutBlacklistsInput
    upsert?: BlacklistTypeUpsertWithoutBlacklistsInput
    connect?: BlacklistTypeWhereUniqueInput
    update?: XOR<XOR<BlacklistTypeUpdateToOneWithWhereWithoutBlacklistsInput, BlacklistTypeUpdateWithoutBlacklistsInput>, BlacklistTypeUncheckedUpdateWithoutBlacklistsInput>
  }

  export type UserPhoneCreateNestedManyWithoutPhoneTypeInput = {
    create?: XOR<UserPhoneCreateWithoutPhoneTypeInput, UserPhoneUncheckedCreateWithoutPhoneTypeInput> | UserPhoneCreateWithoutPhoneTypeInput[] | UserPhoneUncheckedCreateWithoutPhoneTypeInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutPhoneTypeInput | UserPhoneCreateOrConnectWithoutPhoneTypeInput[]
    createMany?: UserPhoneCreateManyPhoneTypeInputEnvelope
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
  }

  export type UserPhoneUncheckedCreateNestedManyWithoutPhoneTypeInput = {
    create?: XOR<UserPhoneCreateWithoutPhoneTypeInput, UserPhoneUncheckedCreateWithoutPhoneTypeInput> | UserPhoneCreateWithoutPhoneTypeInput[] | UserPhoneUncheckedCreateWithoutPhoneTypeInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutPhoneTypeInput | UserPhoneCreateOrConnectWithoutPhoneTypeInput[]
    createMany?: UserPhoneCreateManyPhoneTypeInputEnvelope
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
  }

  export type UserPhoneUpdateManyWithoutPhoneTypeNestedInput = {
    create?: XOR<UserPhoneCreateWithoutPhoneTypeInput, UserPhoneUncheckedCreateWithoutPhoneTypeInput> | UserPhoneCreateWithoutPhoneTypeInput[] | UserPhoneUncheckedCreateWithoutPhoneTypeInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutPhoneTypeInput | UserPhoneCreateOrConnectWithoutPhoneTypeInput[]
    upsert?: UserPhoneUpsertWithWhereUniqueWithoutPhoneTypeInput | UserPhoneUpsertWithWhereUniqueWithoutPhoneTypeInput[]
    createMany?: UserPhoneCreateManyPhoneTypeInputEnvelope
    set?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    disconnect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    delete?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    update?: UserPhoneUpdateWithWhereUniqueWithoutPhoneTypeInput | UserPhoneUpdateWithWhereUniqueWithoutPhoneTypeInput[]
    updateMany?: UserPhoneUpdateManyWithWhereWithoutPhoneTypeInput | UserPhoneUpdateManyWithWhereWithoutPhoneTypeInput[]
    deleteMany?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
  }

  export type UserPhoneUncheckedUpdateManyWithoutPhoneTypeNestedInput = {
    create?: XOR<UserPhoneCreateWithoutPhoneTypeInput, UserPhoneUncheckedCreateWithoutPhoneTypeInput> | UserPhoneCreateWithoutPhoneTypeInput[] | UserPhoneUncheckedCreateWithoutPhoneTypeInput[]
    connectOrCreate?: UserPhoneCreateOrConnectWithoutPhoneTypeInput | UserPhoneCreateOrConnectWithoutPhoneTypeInput[]
    upsert?: UserPhoneUpsertWithWhereUniqueWithoutPhoneTypeInput | UserPhoneUpsertWithWhereUniqueWithoutPhoneTypeInput[]
    createMany?: UserPhoneCreateManyPhoneTypeInputEnvelope
    set?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    disconnect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    delete?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    connect?: UserPhoneWhereUniqueInput | UserPhoneWhereUniqueInput[]
    update?: UserPhoneUpdateWithWhereUniqueWithoutPhoneTypeInput | UserPhoneUpdateWithWhereUniqueWithoutPhoneTypeInput[]
    updateMany?: UserPhoneUpdateManyWithWhereWithoutPhoneTypeInput | UserPhoneUpdateManyWithWhereWithoutPhoneTypeInput[]
    deleteMany?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserPhonesInput = {
    create?: XOR<UserCreateWithoutUserPhonesInput, UserUncheckedCreateWithoutUserPhonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPhonesInput
    connect?: UserWhereUniqueInput
  }

  export type UserPhoneTypeCreateNestedOneWithoutUserPhonesInput = {
    create?: XOR<UserPhoneTypeCreateWithoutUserPhonesInput, UserPhoneTypeUncheckedCreateWithoutUserPhonesInput>
    connectOrCreate?: UserPhoneTypeCreateOrConnectWithoutUserPhonesInput
    connect?: UserPhoneTypeWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutUserPhoneInput = {
    create?: XOR<ServiceCreateWithoutUserPhoneInput, ServiceUncheckedCreateWithoutUserPhoneInput> | ServiceCreateWithoutUserPhoneInput[] | ServiceUncheckedCreateWithoutUserPhoneInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserPhoneInput | ServiceCreateOrConnectWithoutUserPhoneInput[]
    createMany?: ServiceCreateManyUserPhoneInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutUserPhoneInput = {
    create?: XOR<ServiceCreateWithoutUserPhoneInput, ServiceUncheckedCreateWithoutUserPhoneInput> | ServiceCreateWithoutUserPhoneInput[] | ServiceUncheckedCreateWithoutUserPhoneInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserPhoneInput | ServiceCreateOrConnectWithoutUserPhoneInput[]
    createMany?: ServiceCreateManyUserPhoneInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserPhonesNestedInput = {
    create?: XOR<UserCreateWithoutUserPhonesInput, UserUncheckedCreateWithoutUserPhonesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPhonesInput
    upsert?: UserUpsertWithoutUserPhonesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPhonesInput, UserUpdateWithoutUserPhonesInput>, UserUncheckedUpdateWithoutUserPhonesInput>
  }

  export type UserPhoneTypeUpdateOneRequiredWithoutUserPhonesNestedInput = {
    create?: XOR<UserPhoneTypeCreateWithoutUserPhonesInput, UserPhoneTypeUncheckedCreateWithoutUserPhonesInput>
    connectOrCreate?: UserPhoneTypeCreateOrConnectWithoutUserPhonesInput
    upsert?: UserPhoneTypeUpsertWithoutUserPhonesInput
    connect?: UserPhoneTypeWhereUniqueInput
    update?: XOR<XOR<UserPhoneTypeUpdateToOneWithWhereWithoutUserPhonesInput, UserPhoneTypeUpdateWithoutUserPhonesInput>, UserPhoneTypeUncheckedUpdateWithoutUserPhonesInput>
  }

  export type ServiceUpdateManyWithoutUserPhoneNestedInput = {
    create?: XOR<ServiceCreateWithoutUserPhoneInput, ServiceUncheckedCreateWithoutUserPhoneInput> | ServiceCreateWithoutUserPhoneInput[] | ServiceUncheckedCreateWithoutUserPhoneInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserPhoneInput | ServiceCreateOrConnectWithoutUserPhoneInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserPhoneInput | ServiceUpsertWithWhereUniqueWithoutUserPhoneInput[]
    createMany?: ServiceCreateManyUserPhoneInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserPhoneInput | ServiceUpdateWithWhereUniqueWithoutUserPhoneInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserPhoneInput | ServiceUpdateManyWithWhereWithoutUserPhoneInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutUserPhoneNestedInput = {
    create?: XOR<ServiceCreateWithoutUserPhoneInput, ServiceUncheckedCreateWithoutUserPhoneInput> | ServiceCreateWithoutUserPhoneInput[] | ServiceUncheckedCreateWithoutUserPhoneInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserPhoneInput | ServiceCreateOrConnectWithoutUserPhoneInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserPhoneInput | ServiceUpsertWithWhereUniqueWithoutUserPhoneInput[]
    createMany?: ServiceCreateManyUserPhoneInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserPhoneInput | ServiceUpdateWithWhereUniqueWithoutUserPhoneInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserPhoneInput | ServiceUpdateManyWithWhereWithoutUserPhoneInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ProductCreateWithoutCurrencyInput, ProductUncheckedCreateWithoutCurrencyInput> | ProductCreateWithoutCurrencyInput[] | ProductUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCurrencyInput | ProductCreateOrConnectWithoutCurrencyInput[]
    createMany?: ProductCreateManyCurrencyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ServiceCreateWithoutCurrencyInput, ServiceUncheckedCreateWithoutCurrencyInput> | ServiceCreateWithoutCurrencyInput[] | ServiceUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCurrencyInput | ServiceCreateOrConnectWithoutCurrencyInput[]
    createMany?: ServiceCreateManyCurrencyInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceDetailCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ServiceDetailCreateWithoutCurrencyInput, ServiceDetailUncheckedCreateWithoutCurrencyInput> | ServiceDetailCreateWithoutCurrencyInput[] | ServiceDetailUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutCurrencyInput | ServiceDetailCreateOrConnectWithoutCurrencyInput[]
    createMany?: ServiceDetailCreateManyCurrencyInputEnvelope
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
  }

  export type ServiceExtraCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ServiceExtraCreateWithoutCurrencyInput, ServiceExtraUncheckedCreateWithoutCurrencyInput> | ServiceExtraCreateWithoutCurrencyInput[] | ServiceExtraUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutCurrencyInput | ServiceExtraCreateOrConnectWithoutCurrencyInput[]
    createMany?: ServiceExtraCreateManyCurrencyInputEnvelope
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ProductCreateWithoutCurrencyInput, ProductUncheckedCreateWithoutCurrencyInput> | ProductCreateWithoutCurrencyInput[] | ProductUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCurrencyInput | ProductCreateOrConnectWithoutCurrencyInput[]
    createMany?: ProductCreateManyCurrencyInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ServiceCreateWithoutCurrencyInput, ServiceUncheckedCreateWithoutCurrencyInput> | ServiceCreateWithoutCurrencyInput[] | ServiceUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCurrencyInput | ServiceCreateOrConnectWithoutCurrencyInput[]
    createMany?: ServiceCreateManyCurrencyInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceDetailUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ServiceDetailCreateWithoutCurrencyInput, ServiceDetailUncheckedCreateWithoutCurrencyInput> | ServiceDetailCreateWithoutCurrencyInput[] | ServiceDetailUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutCurrencyInput | ServiceDetailCreateOrConnectWithoutCurrencyInput[]
    createMany?: ServiceDetailCreateManyCurrencyInputEnvelope
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
  }

  export type ServiceExtraUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<ServiceExtraCreateWithoutCurrencyInput, ServiceExtraUncheckedCreateWithoutCurrencyInput> | ServiceExtraCreateWithoutCurrencyInput[] | ServiceExtraUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutCurrencyInput | ServiceExtraCreateOrConnectWithoutCurrencyInput[]
    createMany?: ServiceExtraCreateManyCurrencyInputEnvelope
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ProductCreateWithoutCurrencyInput, ProductUncheckedCreateWithoutCurrencyInput> | ProductCreateWithoutCurrencyInput[] | ProductUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCurrencyInput | ProductCreateOrConnectWithoutCurrencyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCurrencyInput | ProductUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ProductCreateManyCurrencyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCurrencyInput | ProductUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCurrencyInput | ProductUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ServiceCreateWithoutCurrencyInput, ServiceUncheckedCreateWithoutCurrencyInput> | ServiceCreateWithoutCurrencyInput[] | ServiceUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCurrencyInput | ServiceCreateOrConnectWithoutCurrencyInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCurrencyInput | ServiceUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ServiceCreateManyCurrencyInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCurrencyInput | ServiceUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCurrencyInput | ServiceUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceDetailUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ServiceDetailCreateWithoutCurrencyInput, ServiceDetailUncheckedCreateWithoutCurrencyInput> | ServiceDetailCreateWithoutCurrencyInput[] | ServiceDetailUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutCurrencyInput | ServiceDetailCreateOrConnectWithoutCurrencyInput[]
    upsert?: ServiceDetailUpsertWithWhereUniqueWithoutCurrencyInput | ServiceDetailUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ServiceDetailCreateManyCurrencyInputEnvelope
    set?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    disconnect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    delete?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    update?: ServiceDetailUpdateWithWhereUniqueWithoutCurrencyInput | ServiceDetailUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ServiceDetailUpdateManyWithWhereWithoutCurrencyInput | ServiceDetailUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
  }

  export type ServiceExtraUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ServiceExtraCreateWithoutCurrencyInput, ServiceExtraUncheckedCreateWithoutCurrencyInput> | ServiceExtraCreateWithoutCurrencyInput[] | ServiceExtraUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutCurrencyInput | ServiceExtraCreateOrConnectWithoutCurrencyInput[]
    upsert?: ServiceExtraUpsertWithWhereUniqueWithoutCurrencyInput | ServiceExtraUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ServiceExtraCreateManyCurrencyInputEnvelope
    set?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    disconnect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    delete?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    update?: ServiceExtraUpdateWithWhereUniqueWithoutCurrencyInput | ServiceExtraUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ServiceExtraUpdateManyWithWhereWithoutCurrencyInput | ServiceExtraUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ServiceExtraScalarWhereInput | ServiceExtraScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ProductCreateWithoutCurrencyInput, ProductUncheckedCreateWithoutCurrencyInput> | ProductCreateWithoutCurrencyInput[] | ProductUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCurrencyInput | ProductCreateOrConnectWithoutCurrencyInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCurrencyInput | ProductUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ProductCreateManyCurrencyInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCurrencyInput | ProductUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCurrencyInput | ProductUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ServiceCreateWithoutCurrencyInput, ServiceUncheckedCreateWithoutCurrencyInput> | ServiceCreateWithoutCurrencyInput[] | ServiceUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCurrencyInput | ServiceCreateOrConnectWithoutCurrencyInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCurrencyInput | ServiceUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ServiceCreateManyCurrencyInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCurrencyInput | ServiceUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCurrencyInput | ServiceUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceDetailUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ServiceDetailCreateWithoutCurrencyInput, ServiceDetailUncheckedCreateWithoutCurrencyInput> | ServiceDetailCreateWithoutCurrencyInput[] | ServiceDetailUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutCurrencyInput | ServiceDetailCreateOrConnectWithoutCurrencyInput[]
    upsert?: ServiceDetailUpsertWithWhereUniqueWithoutCurrencyInput | ServiceDetailUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ServiceDetailCreateManyCurrencyInputEnvelope
    set?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    disconnect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    delete?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    update?: ServiceDetailUpdateWithWhereUniqueWithoutCurrencyInput | ServiceDetailUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ServiceDetailUpdateManyWithWhereWithoutCurrencyInput | ServiceDetailUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
  }

  export type ServiceExtraUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<ServiceExtraCreateWithoutCurrencyInput, ServiceExtraUncheckedCreateWithoutCurrencyInput> | ServiceExtraCreateWithoutCurrencyInput[] | ServiceExtraUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutCurrencyInput | ServiceExtraCreateOrConnectWithoutCurrencyInput[]
    upsert?: ServiceExtraUpsertWithWhereUniqueWithoutCurrencyInput | ServiceExtraUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: ServiceExtraCreateManyCurrencyInputEnvelope
    set?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    disconnect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    delete?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    update?: ServiceExtraUpdateWithWhereUniqueWithoutCurrencyInput | ServiceExtraUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: ServiceExtraUpdateManyWithWhereWithoutCurrencyInput | ServiceExtraUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: ServiceExtraScalarWhereInput | ServiceExtraScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<ProductCreateWithoutBusinessTypeInput, ProductUncheckedCreateWithoutBusinessTypeInput> | ProductCreateWithoutBusinessTypeInput[] | ProductUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessTypeInput | ProductCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: ProductCreateManyBusinessTypeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBusinessTypeInput = {
    create?: XOR<ProductCreateWithoutBusinessTypeInput, ProductUncheckedCreateWithoutBusinessTypeInput> | ProductCreateWithoutBusinessTypeInput[] | ProductUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessTypeInput | ProductCreateOrConnectWithoutBusinessTypeInput[]
    createMany?: ProductCreateManyBusinessTypeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<ProductCreateWithoutBusinessTypeInput, ProductUncheckedCreateWithoutBusinessTypeInput> | ProductCreateWithoutBusinessTypeInput[] | ProductUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessTypeInput | ProductCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBusinessTypeInput | ProductUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: ProductCreateManyBusinessTypeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBusinessTypeInput | ProductUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBusinessTypeInput | ProductUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBusinessTypeNestedInput = {
    create?: XOR<ProductCreateWithoutBusinessTypeInput, ProductUncheckedCreateWithoutBusinessTypeInput> | ProductCreateWithoutBusinessTypeInput[] | ProductUncheckedCreateWithoutBusinessTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessTypeInput | ProductCreateOrConnectWithoutBusinessTypeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBusinessTypeInput | ProductUpsertWithWhereUniqueWithoutBusinessTypeInput[]
    createMany?: ProductCreateManyBusinessTypeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBusinessTypeInput | ProductUpdateWithWhereUniqueWithoutBusinessTypeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBusinessTypeInput | ProductUpdateManyWithWhereWithoutBusinessTypeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductBusinessTypeCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductBusinessTypeCreateWithoutProductsInput, ProductBusinessTypeUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductBusinessTypeCreateOrConnectWithoutProductsInput
    connect?: ProductBusinessTypeWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutProductsInput = {
    create?: XOR<CurrencyCreateWithoutProductsInput, CurrencyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutProductsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type ProductDetailCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
  }

  export type ServiceDetailCreateNestedManyWithoutProductInput = {
    create?: XOR<ServiceDetailCreateWithoutProductInput, ServiceDetailUncheckedCreateWithoutProductInput> | ServiceDetailCreateWithoutProductInput[] | ServiceDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutProductInput | ServiceDetailCreateOrConnectWithoutProductInput[]
    createMany?: ServiceDetailCreateManyProductInputEnvelope
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
  }

  export type ProductDetailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
  }

  export type ServiceDetailUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ServiceDetailCreateWithoutProductInput, ServiceDetailUncheckedCreateWithoutProductInput> | ServiceDetailCreateWithoutProductInput[] | ServiceDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutProductInput | ServiceDetailCreateOrConnectWithoutProductInput[]
    createMany?: ServiceDetailCreateManyProductInputEnvelope
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductBusinessTypeUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductBusinessTypeCreateWithoutProductsInput, ProductBusinessTypeUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductBusinessTypeCreateOrConnectWithoutProductsInput
    upsert?: ProductBusinessTypeUpsertWithoutProductsInput
    connect?: ProductBusinessTypeWhereUniqueInput
    update?: XOR<XOR<ProductBusinessTypeUpdateToOneWithWhereWithoutProductsInput, ProductBusinessTypeUpdateWithoutProductsInput>, ProductBusinessTypeUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CurrencyUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CurrencyCreateWithoutProductsInput, CurrencyUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutProductsInput
    upsert?: CurrencyUpsertWithoutProductsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutProductsInput, CurrencyUpdateWithoutProductsInput>, CurrencyUncheckedUpdateWithoutProductsInput>
  }

  export type ProductDetailUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    upsert?: ProductDetailUpsertWithWhereUniqueWithoutProductInput | ProductDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    set?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    disconnect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    delete?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    update?: ProductDetailUpdateWithWhereUniqueWithoutProductInput | ProductDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductDetailUpdateManyWithWhereWithoutProductInput | ProductDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
  }

  export type ServiceDetailUpdateManyWithoutProductNestedInput = {
    create?: XOR<ServiceDetailCreateWithoutProductInput, ServiceDetailUncheckedCreateWithoutProductInput> | ServiceDetailCreateWithoutProductInput[] | ServiceDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutProductInput | ServiceDetailCreateOrConnectWithoutProductInput[]
    upsert?: ServiceDetailUpsertWithWhereUniqueWithoutProductInput | ServiceDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ServiceDetailCreateManyProductInputEnvelope
    set?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    disconnect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    delete?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    update?: ServiceDetailUpdateWithWhereUniqueWithoutProductInput | ServiceDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ServiceDetailUpdateManyWithWhereWithoutProductInput | ServiceDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
  }

  export type ProductDetailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput> | ProductDetailCreateWithoutProductInput[] | ProductDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutProductInput | ProductDetailCreateOrConnectWithoutProductInput[]
    upsert?: ProductDetailUpsertWithWhereUniqueWithoutProductInput | ProductDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductDetailCreateManyProductInputEnvelope
    set?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    disconnect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    delete?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    update?: ProductDetailUpdateWithWhereUniqueWithoutProductInput | ProductDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductDetailUpdateManyWithWhereWithoutProductInput | ProductDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
  }

  export type ServiceDetailUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ServiceDetailCreateWithoutProductInput, ServiceDetailUncheckedCreateWithoutProductInput> | ServiceDetailCreateWithoutProductInput[] | ServiceDetailUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutProductInput | ServiceDetailCreateOrConnectWithoutProductInput[]
    upsert?: ServiceDetailUpsertWithWhereUniqueWithoutProductInput | ServiceDetailUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ServiceDetailCreateManyProductInputEnvelope
    set?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    disconnect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    delete?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    update?: ServiceDetailUpdateWithWhereUniqueWithoutProductInput | ServiceDetailUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ServiceDetailUpdateManyWithWhereWithoutProductInput | ServiceDetailUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
  }

  export type ProductDetailCreateNestedManyWithoutDetailTypeInput = {
    create?: XOR<ProductDetailCreateWithoutDetailTypeInput, ProductDetailUncheckedCreateWithoutDetailTypeInput> | ProductDetailCreateWithoutDetailTypeInput[] | ProductDetailUncheckedCreateWithoutDetailTypeInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutDetailTypeInput | ProductDetailCreateOrConnectWithoutDetailTypeInput[]
    createMany?: ProductDetailCreateManyDetailTypeInputEnvelope
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
  }

  export type ProductDetailUncheckedCreateNestedManyWithoutDetailTypeInput = {
    create?: XOR<ProductDetailCreateWithoutDetailTypeInput, ProductDetailUncheckedCreateWithoutDetailTypeInput> | ProductDetailCreateWithoutDetailTypeInput[] | ProductDetailUncheckedCreateWithoutDetailTypeInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutDetailTypeInput | ProductDetailCreateOrConnectWithoutDetailTypeInput[]
    createMany?: ProductDetailCreateManyDetailTypeInputEnvelope
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
  }

  export type ProductDetailUpdateManyWithoutDetailTypeNestedInput = {
    create?: XOR<ProductDetailCreateWithoutDetailTypeInput, ProductDetailUncheckedCreateWithoutDetailTypeInput> | ProductDetailCreateWithoutDetailTypeInput[] | ProductDetailUncheckedCreateWithoutDetailTypeInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutDetailTypeInput | ProductDetailCreateOrConnectWithoutDetailTypeInput[]
    upsert?: ProductDetailUpsertWithWhereUniqueWithoutDetailTypeInput | ProductDetailUpsertWithWhereUniqueWithoutDetailTypeInput[]
    createMany?: ProductDetailCreateManyDetailTypeInputEnvelope
    set?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    disconnect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    delete?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    update?: ProductDetailUpdateWithWhereUniqueWithoutDetailTypeInput | ProductDetailUpdateWithWhereUniqueWithoutDetailTypeInput[]
    updateMany?: ProductDetailUpdateManyWithWhereWithoutDetailTypeInput | ProductDetailUpdateManyWithWhereWithoutDetailTypeInput[]
    deleteMany?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
  }

  export type ProductDetailUncheckedUpdateManyWithoutDetailTypeNestedInput = {
    create?: XOR<ProductDetailCreateWithoutDetailTypeInput, ProductDetailUncheckedCreateWithoutDetailTypeInput> | ProductDetailCreateWithoutDetailTypeInput[] | ProductDetailUncheckedCreateWithoutDetailTypeInput[]
    connectOrCreate?: ProductDetailCreateOrConnectWithoutDetailTypeInput | ProductDetailCreateOrConnectWithoutDetailTypeInput[]
    upsert?: ProductDetailUpsertWithWhereUniqueWithoutDetailTypeInput | ProductDetailUpsertWithWhereUniqueWithoutDetailTypeInput[]
    createMany?: ProductDetailCreateManyDetailTypeInputEnvelope
    set?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    disconnect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    delete?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    connect?: ProductDetailWhereUniqueInput | ProductDetailWhereUniqueInput[]
    update?: ProductDetailUpdateWithWhereUniqueWithoutDetailTypeInput | ProductDetailUpdateWithWhereUniqueWithoutDetailTypeInput[]
    updateMany?: ProductDetailUpdateManyWithWhereWithoutDetailTypeInput | ProductDetailUpdateManyWithWhereWithoutDetailTypeInput[]
    deleteMany?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductDetailsInput = {
    create?: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductDetailsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductDetailTypeCreateNestedOneWithoutProductDetailsInput = {
    create?: XOR<ProductDetailTypeCreateWithoutProductDetailsInput, ProductDetailTypeUncheckedCreateWithoutProductDetailsInput>
    connectOrCreate?: ProductDetailTypeCreateOrConnectWithoutProductDetailsInput
    connect?: ProductDetailTypeWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutProductDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductDetailsInput
    upsert?: ProductUpsertWithoutProductDetailsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductDetailsInput, ProductUpdateWithoutProductDetailsInput>, ProductUncheckedUpdateWithoutProductDetailsInput>
  }

  export type ProductDetailTypeUpdateOneRequiredWithoutProductDetailsNestedInput = {
    create?: XOR<ProductDetailTypeCreateWithoutProductDetailsInput, ProductDetailTypeUncheckedCreateWithoutProductDetailsInput>
    connectOrCreate?: ProductDetailTypeCreateOrConnectWithoutProductDetailsInput
    upsert?: ProductDetailTypeUpsertWithoutProductDetailsInput
    connect?: ProductDetailTypeWhereUniqueInput
    update?: XOR<XOR<ProductDetailTypeUpdateToOneWithWhereWithoutProductDetailsInput, ProductDetailTypeUpdateWithoutProductDetailsInput>, ProductDetailTypeUncheckedUpdateWithoutProductDetailsInput>
  }

  export type CountryDepartmentCreateNestedManyWithoutCountryInput = {
    create?: XOR<CountryDepartmentCreateWithoutCountryInput, CountryDepartmentUncheckedCreateWithoutCountryInput> | CountryDepartmentCreateWithoutCountryInput[] | CountryDepartmentUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryDepartmentCreateOrConnectWithoutCountryInput | CountryDepartmentCreateOrConnectWithoutCountryInput[]
    createMany?: CountryDepartmentCreateManyCountryInputEnvelope
    connect?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
  }

  export type CountryDepartmentUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<CountryDepartmentCreateWithoutCountryInput, CountryDepartmentUncheckedCreateWithoutCountryInput> | CountryDepartmentCreateWithoutCountryInput[] | CountryDepartmentUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryDepartmentCreateOrConnectWithoutCountryInput | CountryDepartmentCreateOrConnectWithoutCountryInput[]
    createMany?: CountryDepartmentCreateManyCountryInputEnvelope
    connect?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
  }

  export type CountryDepartmentUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CountryDepartmentCreateWithoutCountryInput, CountryDepartmentUncheckedCreateWithoutCountryInput> | CountryDepartmentCreateWithoutCountryInput[] | CountryDepartmentUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryDepartmentCreateOrConnectWithoutCountryInput | CountryDepartmentCreateOrConnectWithoutCountryInput[]
    upsert?: CountryDepartmentUpsertWithWhereUniqueWithoutCountryInput | CountryDepartmentUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CountryDepartmentCreateManyCountryInputEnvelope
    set?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    disconnect?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    delete?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    connect?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    update?: CountryDepartmentUpdateWithWhereUniqueWithoutCountryInput | CountryDepartmentUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CountryDepartmentUpdateManyWithWhereWithoutCountryInput | CountryDepartmentUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CountryDepartmentScalarWhereInput | CountryDepartmentScalarWhereInput[]
  }

  export type CountryDepartmentUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<CountryDepartmentCreateWithoutCountryInput, CountryDepartmentUncheckedCreateWithoutCountryInput> | CountryDepartmentCreateWithoutCountryInput[] | CountryDepartmentUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: CountryDepartmentCreateOrConnectWithoutCountryInput | CountryDepartmentCreateOrConnectWithoutCountryInput[]
    upsert?: CountryDepartmentUpsertWithWhereUniqueWithoutCountryInput | CountryDepartmentUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: CountryDepartmentCreateManyCountryInputEnvelope
    set?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    disconnect?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    delete?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    connect?: CountryDepartmentWhereUniqueInput | CountryDepartmentWhereUniqueInput[]
    update?: CountryDepartmentUpdateWithWhereUniqueWithoutCountryInput | CountryDepartmentUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: CountryDepartmentUpdateManyWithWhereWithoutCountryInput | CountryDepartmentUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: CountryDepartmentScalarWhereInput | CountryDepartmentScalarWhereInput[]
  }

  export type CountryCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<CountryCreateWithoutDepartmentsInput, CountryUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDepartmentsInput
    connect?: CountryWhereUniqueInput
  }

  export type MunicipalityCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type MunicipalityUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
  }

  export type CountryUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<CountryCreateWithoutDepartmentsInput, CountryUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutDepartmentsInput
    upsert?: CountryUpsertWithoutDepartmentsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutDepartmentsInput, CountryUpdateWithoutDepartmentsInput>, CountryUncheckedUpdateWithoutDepartmentsInput>
  }

  export type MunicipalityUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput | MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput | MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutDepartmentInput | MunicipalityUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type MunicipalityUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput> | MunicipalityCreateWithoutDepartmentInput[] | MunicipalityUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: MunicipalityCreateOrConnectWithoutDepartmentInput | MunicipalityCreateOrConnectWithoutDepartmentInput[]
    upsert?: MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput | MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: MunicipalityCreateManyDepartmentInputEnvelope
    set?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    disconnect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    delete?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    connect?: MunicipalityWhereUniqueInput | MunicipalityWhereUniqueInput[]
    update?: MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput | MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: MunicipalityUpdateManyWithWhereWithoutDepartmentInput | MunicipalityUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
  }

  export type CountryDepartmentCreateNestedOneWithoutMunicipalitiesInput = {
    create?: XOR<CountryDepartmentCreateWithoutMunicipalitiesInput, CountryDepartmentUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: CountryDepartmentCreateOrConnectWithoutMunicipalitiesInput
    connect?: CountryDepartmentWhereUniqueInput
  }

  export type ZoneCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<ZoneCreateWithoutMunicipalityInput, ZoneUncheckedCreateWithoutMunicipalityInput> | ZoneCreateWithoutMunicipalityInput[] | ZoneUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutMunicipalityInput | ZoneCreateOrConnectWithoutMunicipalityInput[]
    createMany?: ZoneCreateManyMunicipalityInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutMunicipalityInput = {
    create?: XOR<ZoneCreateWithoutMunicipalityInput, ZoneUncheckedCreateWithoutMunicipalityInput> | ZoneCreateWithoutMunicipalityInput[] | ZoneUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutMunicipalityInput | ZoneCreateOrConnectWithoutMunicipalityInput[]
    createMany?: ZoneCreateManyMunicipalityInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type CountryDepartmentUpdateOneRequiredWithoutMunicipalitiesNestedInput = {
    create?: XOR<CountryDepartmentCreateWithoutMunicipalitiesInput, CountryDepartmentUncheckedCreateWithoutMunicipalitiesInput>
    connectOrCreate?: CountryDepartmentCreateOrConnectWithoutMunicipalitiesInput
    upsert?: CountryDepartmentUpsertWithoutMunicipalitiesInput
    connect?: CountryDepartmentWhereUniqueInput
    update?: XOR<XOR<CountryDepartmentUpdateToOneWithWhereWithoutMunicipalitiesInput, CountryDepartmentUpdateWithoutMunicipalitiesInput>, CountryDepartmentUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type ZoneUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<ZoneCreateWithoutMunicipalityInput, ZoneUncheckedCreateWithoutMunicipalityInput> | ZoneCreateWithoutMunicipalityInput[] | ZoneUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutMunicipalityInput | ZoneCreateOrConnectWithoutMunicipalityInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutMunicipalityInput | ZoneUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: ZoneCreateManyMunicipalityInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutMunicipalityInput | ZoneUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutMunicipalityInput | ZoneUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutMunicipalityNestedInput = {
    create?: XOR<ZoneCreateWithoutMunicipalityInput, ZoneUncheckedCreateWithoutMunicipalityInput> | ZoneCreateWithoutMunicipalityInput[] | ZoneUncheckedCreateWithoutMunicipalityInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutMunicipalityInput | ZoneCreateOrConnectWithoutMunicipalityInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutMunicipalityInput | ZoneUpsertWithWhereUniqueWithoutMunicipalityInput[]
    createMany?: ZoneCreateManyMunicipalityInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutMunicipalityInput | ZoneUpdateWithWhereUniqueWithoutMunicipalityInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutMunicipalityInput | ZoneUpdateManyWithWhereWithoutMunicipalityInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type MunicipalityCreateNestedOneWithoutZonesInput = {
    create?: XOR<MunicipalityCreateWithoutZonesInput, MunicipalityUncheckedCreateWithoutZonesInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutZonesInput
    connect?: MunicipalityWhereUniqueInput
  }

  export type AddressCreateNestedManyWithoutZoneInput = {
    create?: XOR<AddressCreateWithoutZoneInput, AddressUncheckedCreateWithoutZoneInput> | AddressCreateWithoutZoneInput[] | AddressUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutZoneInput | AddressCreateOrConnectWithoutZoneInput[]
    createMany?: AddressCreateManyZoneInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<AddressCreateWithoutZoneInput, AddressUncheckedCreateWithoutZoneInput> | AddressCreateWithoutZoneInput[] | AddressUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutZoneInput | AddressCreateOrConnectWithoutZoneInput[]
    createMany?: AddressCreateManyZoneInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type MunicipalityUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<MunicipalityCreateWithoutZonesInput, MunicipalityUncheckedCreateWithoutZonesInput>
    connectOrCreate?: MunicipalityCreateOrConnectWithoutZonesInput
    upsert?: MunicipalityUpsertWithoutZonesInput
    connect?: MunicipalityWhereUniqueInput
    update?: XOR<XOR<MunicipalityUpdateToOneWithWhereWithoutZonesInput, MunicipalityUpdateWithoutZonesInput>, MunicipalityUncheckedUpdateWithoutZonesInput>
  }

  export type AddressUpdateManyWithoutZoneNestedInput = {
    create?: XOR<AddressCreateWithoutZoneInput, AddressUncheckedCreateWithoutZoneInput> | AddressCreateWithoutZoneInput[] | AddressUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutZoneInput | AddressCreateOrConnectWithoutZoneInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutZoneInput | AddressUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: AddressCreateManyZoneInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutZoneInput | AddressUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutZoneInput | AddressUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<AddressCreateWithoutZoneInput, AddressUncheckedCreateWithoutZoneInput> | AddressCreateWithoutZoneInput[] | AddressUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutZoneInput | AddressCreateOrConnectWithoutZoneInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutZoneInput | AddressUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: AddressCreateManyZoneInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutZoneInput | AddressUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutZoneInput | AddressUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ZoneCreateWithoutAddressesInput, ZoneUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutAddressesInput
    connect?: ZoneWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutAddressInput = {
    create?: XOR<ServiceCreateWithoutAddressInput, ServiceUncheckedCreateWithoutAddressInput> | ServiceCreateWithoutAddressInput[] | ServiceUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAddressInput | ServiceCreateOrConnectWithoutAddressInput[]
    createMany?: ServiceCreateManyAddressInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<ServiceCreateWithoutAddressInput, ServiceUncheckedCreateWithoutAddressInput> | ServiceCreateWithoutAddressInput[] | ServiceUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAddressInput | ServiceCreateOrConnectWithoutAddressInput[]
    createMany?: ServiceCreateManyAddressInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type ZoneUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<ZoneCreateWithoutAddressesInput, ZoneUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutAddressesInput
    upsert?: ZoneUpsertWithoutAddressesInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutAddressesInput, ZoneUpdateWithoutAddressesInput>, ZoneUncheckedUpdateWithoutAddressesInput>
  }

  export type ServiceUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ServiceCreateWithoutAddressInput, ServiceUncheckedCreateWithoutAddressInput> | ServiceCreateWithoutAddressInput[] | ServiceUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAddressInput | ServiceCreateOrConnectWithoutAddressInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutAddressInput | ServiceUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ServiceCreateManyAddressInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutAddressInput | ServiceUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutAddressInput | ServiceUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ServiceCreateWithoutAddressInput, ServiceUncheckedCreateWithoutAddressInput> | ServiceCreateWithoutAddressInput[] | ServiceUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutAddressInput | ServiceCreateOrConnectWithoutAddressInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutAddressInput | ServiceUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ServiceCreateManyAddressInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutAddressInput | ServiceUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutAddressInput | ServiceUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutServiceStatusInput = {
    create?: XOR<ServiceCreateWithoutServiceStatusInput, ServiceUncheckedCreateWithoutServiceStatusInput> | ServiceCreateWithoutServiceStatusInput[] | ServiceUncheckedCreateWithoutServiceStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceStatusInput | ServiceCreateOrConnectWithoutServiceStatusInput[]
    createMany?: ServiceCreateManyServiceStatusInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutServiceStatusInput = {
    create?: XOR<ServiceCreateWithoutServiceStatusInput, ServiceUncheckedCreateWithoutServiceStatusInput> | ServiceCreateWithoutServiceStatusInput[] | ServiceUncheckedCreateWithoutServiceStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceStatusInput | ServiceCreateOrConnectWithoutServiceStatusInput[]
    createMany?: ServiceCreateManyServiceStatusInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutServiceStatusNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceStatusInput, ServiceUncheckedCreateWithoutServiceStatusInput> | ServiceCreateWithoutServiceStatusInput[] | ServiceUncheckedCreateWithoutServiceStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceStatusInput | ServiceCreateOrConnectWithoutServiceStatusInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceStatusInput | ServiceUpsertWithWhereUniqueWithoutServiceStatusInput[]
    createMany?: ServiceCreateManyServiceStatusInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceStatusInput | ServiceUpdateWithWhereUniqueWithoutServiceStatusInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceStatusInput | ServiceUpdateManyWithWhereWithoutServiceStatusInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutServiceStatusNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceStatusInput, ServiceUncheckedCreateWithoutServiceStatusInput> | ServiceCreateWithoutServiceStatusInput[] | ServiceUncheckedCreateWithoutServiceStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceStatusInput | ServiceCreateOrConnectWithoutServiceStatusInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutServiceStatusInput | ServiceUpsertWithWhereUniqueWithoutServiceStatusInput[]
    createMany?: ServiceCreateManyServiceStatusInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutServiceStatusInput | ServiceUpdateWithWhereUniqueWithoutServiceStatusInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutServiceStatusInput | ServiceUpdateManyWithWhereWithoutServiceStatusInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutPaymentStatusInput = {
    create?: XOR<ServiceCreateWithoutPaymentStatusInput, ServiceUncheckedCreateWithoutPaymentStatusInput> | ServiceCreateWithoutPaymentStatusInput[] | ServiceUncheckedCreateWithoutPaymentStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentStatusInput | ServiceCreateOrConnectWithoutPaymentStatusInput[]
    createMany?: ServiceCreateManyPaymentStatusInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutPaymentStatusInput = {
    create?: XOR<ServiceCreateWithoutPaymentStatusInput, ServiceUncheckedCreateWithoutPaymentStatusInput> | ServiceCreateWithoutPaymentStatusInput[] | ServiceUncheckedCreateWithoutPaymentStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentStatusInput | ServiceCreateOrConnectWithoutPaymentStatusInput[]
    createMany?: ServiceCreateManyPaymentStatusInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutPaymentStatusNestedInput = {
    create?: XOR<ServiceCreateWithoutPaymentStatusInput, ServiceUncheckedCreateWithoutPaymentStatusInput> | ServiceCreateWithoutPaymentStatusInput[] | ServiceUncheckedCreateWithoutPaymentStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentStatusInput | ServiceCreateOrConnectWithoutPaymentStatusInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutPaymentStatusInput | ServiceUpsertWithWhereUniqueWithoutPaymentStatusInput[]
    createMany?: ServiceCreateManyPaymentStatusInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutPaymentStatusInput | ServiceUpdateWithWhereUniqueWithoutPaymentStatusInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutPaymentStatusInput | ServiceUpdateManyWithWhereWithoutPaymentStatusInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutPaymentStatusNestedInput = {
    create?: XOR<ServiceCreateWithoutPaymentStatusInput, ServiceUncheckedCreateWithoutPaymentStatusInput> | ServiceCreateWithoutPaymentStatusInput[] | ServiceUncheckedCreateWithoutPaymentStatusInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutPaymentStatusInput | ServiceCreateOrConnectWithoutPaymentStatusInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutPaymentStatusInput | ServiceUpsertWithWhereUniqueWithoutPaymentStatusInput[]
    createMany?: ServiceCreateManyPaymentStatusInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutPaymentStatusInput | ServiceUpdateWithWhereUniqueWithoutPaymentStatusInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutPaymentStatusInput | ServiceUpdateManyWithWhereWithoutPaymentStatusInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    connect?: UserWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutServicesInput = {
    create?: XOR<AddressCreateWithoutServicesInput, AddressUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AddressCreateOrConnectWithoutServicesInput
    connect?: AddressWhereUniqueInput
  }

  export type UserPhoneCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserPhoneCreateWithoutServicesInput, UserPhoneUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutServicesInput
    connect?: UserPhoneWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutServicesInput = {
    create?: XOR<CurrencyCreateWithoutServicesInput, CurrencyUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutServicesInput
    connect?: CurrencyWhereUniqueInput
  }

  export type ServiceStatusCreateNestedOneWithoutServicesInput = {
    create?: XOR<ServiceStatusCreateWithoutServicesInput, ServiceStatusUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceStatusCreateOrConnectWithoutServicesInput
    connect?: ServiceStatusWhereUniqueInput
  }

  export type PaymentStatusCreateNestedOneWithoutServicesInput = {
    create?: XOR<PaymentStatusCreateWithoutServicesInput, PaymentStatusUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PaymentStatusCreateOrConnectWithoutServicesInput
    connect?: PaymentStatusWhereUniqueInput
  }

  export type ServiceDetailCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceDetailCreateWithoutServiceInput, ServiceDetailUncheckedCreateWithoutServiceInput> | ServiceDetailCreateWithoutServiceInput[] | ServiceDetailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutServiceInput | ServiceDetailCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceDetailCreateManyServiceInputEnvelope
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
  }

  export type ServiceExtraCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceExtraCreateWithoutServiceInput, ServiceExtraUncheckedCreateWithoutServiceInput> | ServiceExtraCreateWithoutServiceInput[] | ServiceExtraUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutServiceInput | ServiceExtraCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceExtraCreateManyServiceInputEnvelope
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
  }

  export type ServiceDetailUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceDetailCreateWithoutServiceInput, ServiceDetailUncheckedCreateWithoutServiceInput> | ServiceDetailCreateWithoutServiceInput[] | ServiceDetailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutServiceInput | ServiceDetailCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceDetailCreateManyServiceInputEnvelope
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
  }

  export type ServiceExtraUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceExtraCreateWithoutServiceInput, ServiceExtraUncheckedCreateWithoutServiceInput> | ServiceExtraCreateWithoutServiceInput[] | ServiceExtraUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutServiceInput | ServiceExtraCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceExtraCreateManyServiceInputEnvelope
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    upsert?: UserUpsertWithoutServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>, UserUncheckedUpdateWithoutServicesInput>
  }

  export type AddressUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<AddressCreateWithoutServicesInput, AddressUncheckedCreateWithoutServicesInput>
    connectOrCreate?: AddressCreateOrConnectWithoutServicesInput
    upsert?: AddressUpsertWithoutServicesInput
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutServicesInput, AddressUpdateWithoutServicesInput>, AddressUncheckedUpdateWithoutServicesInput>
  }

  export type UserPhoneUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<UserPhoneCreateWithoutServicesInput, UserPhoneUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutServicesInput
    upsert?: UserPhoneUpsertWithoutServicesInput
    connect?: UserPhoneWhereUniqueInput
    update?: XOR<XOR<UserPhoneUpdateToOneWithWhereWithoutServicesInput, UserPhoneUpdateWithoutServicesInput>, UserPhoneUncheckedUpdateWithoutServicesInput>
  }

  export type CurrencyUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<CurrencyCreateWithoutServicesInput, CurrencyUncheckedCreateWithoutServicesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutServicesInput
    upsert?: CurrencyUpsertWithoutServicesInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutServicesInput, CurrencyUpdateWithoutServicesInput>, CurrencyUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceStatusUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ServiceStatusCreateWithoutServicesInput, ServiceStatusUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ServiceStatusCreateOrConnectWithoutServicesInput
    upsert?: ServiceStatusUpsertWithoutServicesInput
    connect?: ServiceStatusWhereUniqueInput
    update?: XOR<XOR<ServiceStatusUpdateToOneWithWhereWithoutServicesInput, ServiceStatusUpdateWithoutServicesInput>, ServiceStatusUncheckedUpdateWithoutServicesInput>
  }

  export type PaymentStatusUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<PaymentStatusCreateWithoutServicesInput, PaymentStatusUncheckedCreateWithoutServicesInput>
    connectOrCreate?: PaymentStatusCreateOrConnectWithoutServicesInput
    upsert?: PaymentStatusUpsertWithoutServicesInput
    connect?: PaymentStatusWhereUniqueInput
    update?: XOR<XOR<PaymentStatusUpdateToOneWithWhereWithoutServicesInput, PaymentStatusUpdateWithoutServicesInput>, PaymentStatusUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceDetailUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceDetailCreateWithoutServiceInput, ServiceDetailUncheckedCreateWithoutServiceInput> | ServiceDetailCreateWithoutServiceInput[] | ServiceDetailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutServiceInput | ServiceDetailCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceDetailUpsertWithWhereUniqueWithoutServiceInput | ServiceDetailUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceDetailCreateManyServiceInputEnvelope
    set?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    disconnect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    delete?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    update?: ServiceDetailUpdateWithWhereUniqueWithoutServiceInput | ServiceDetailUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceDetailUpdateManyWithWhereWithoutServiceInput | ServiceDetailUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
  }

  export type ServiceExtraUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceExtraCreateWithoutServiceInput, ServiceExtraUncheckedCreateWithoutServiceInput> | ServiceExtraCreateWithoutServiceInput[] | ServiceExtraUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutServiceInput | ServiceExtraCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceExtraUpsertWithWhereUniqueWithoutServiceInput | ServiceExtraUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceExtraCreateManyServiceInputEnvelope
    set?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    disconnect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    delete?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    update?: ServiceExtraUpdateWithWhereUniqueWithoutServiceInput | ServiceExtraUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceExtraUpdateManyWithWhereWithoutServiceInput | ServiceExtraUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceExtraScalarWhereInput | ServiceExtraScalarWhereInput[]
  }

  export type ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceDetailCreateWithoutServiceInput, ServiceDetailUncheckedCreateWithoutServiceInput> | ServiceDetailCreateWithoutServiceInput[] | ServiceDetailUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceDetailCreateOrConnectWithoutServiceInput | ServiceDetailCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceDetailUpsertWithWhereUniqueWithoutServiceInput | ServiceDetailUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceDetailCreateManyServiceInputEnvelope
    set?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    disconnect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    delete?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    connect?: ServiceDetailWhereUniqueInput | ServiceDetailWhereUniqueInput[]
    update?: ServiceDetailUpdateWithWhereUniqueWithoutServiceInput | ServiceDetailUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceDetailUpdateManyWithWhereWithoutServiceInput | ServiceDetailUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
  }

  export type ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceExtraCreateWithoutServiceInput, ServiceExtraUncheckedCreateWithoutServiceInput> | ServiceExtraCreateWithoutServiceInput[] | ServiceExtraUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceExtraCreateOrConnectWithoutServiceInput | ServiceExtraCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceExtraUpsertWithWhereUniqueWithoutServiceInput | ServiceExtraUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceExtraCreateManyServiceInputEnvelope
    set?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    disconnect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    delete?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    connect?: ServiceExtraWhereUniqueInput | ServiceExtraWhereUniqueInput[]
    update?: ServiceExtraUpdateWithWhereUniqueWithoutServiceInput | ServiceExtraUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceExtraUpdateManyWithWhereWithoutServiceInput | ServiceExtraUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceExtraScalarWhereInput | ServiceExtraScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutServiceDetailsInput = {
    create?: XOR<ServiceCreateWithoutServiceDetailsInput, ServiceUncheckedCreateWithoutServiceDetailsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceDetailsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutServiceDetailsInput = {
    create?: XOR<ProductCreateWithoutServiceDetailsInput, ProductUncheckedCreateWithoutServiceDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutServiceDetailsInput
    connect?: ProductWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutServiceDetailsInput = {
    create?: XOR<CurrencyCreateWithoutServiceDetailsInput, CurrencyUncheckedCreateWithoutServiceDetailsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutServiceDetailsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutServiceDetailsNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceDetailsInput, ServiceUncheckedCreateWithoutServiceDetailsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceDetailsInput
    upsert?: ServiceUpsertWithoutServiceDetailsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceDetailsInput, ServiceUpdateWithoutServiceDetailsInput>, ServiceUncheckedUpdateWithoutServiceDetailsInput>
  }

  export type ProductUpdateOneRequiredWithoutServiceDetailsNestedInput = {
    create?: XOR<ProductCreateWithoutServiceDetailsInput, ProductUncheckedCreateWithoutServiceDetailsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutServiceDetailsInput
    upsert?: ProductUpsertWithoutServiceDetailsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutServiceDetailsInput, ProductUpdateWithoutServiceDetailsInput>, ProductUncheckedUpdateWithoutServiceDetailsInput>
  }

  export type CurrencyUpdateOneRequiredWithoutServiceDetailsNestedInput = {
    create?: XOR<CurrencyCreateWithoutServiceDetailsInput, CurrencyUncheckedCreateWithoutServiceDetailsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutServiceDetailsInput
    upsert?: CurrencyUpsertWithoutServiceDetailsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutServiceDetailsInput, CurrencyUpdateWithoutServiceDetailsInput>, CurrencyUncheckedUpdateWithoutServiceDetailsInput>
  }

  export type ServiceCreateNestedOneWithoutServiceExtrasInput = {
    create?: XOR<ServiceCreateWithoutServiceExtrasInput, ServiceUncheckedCreateWithoutServiceExtrasInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceExtrasInput
    connect?: ServiceWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutServiceExtrasInput = {
    create?: XOR<CurrencyCreateWithoutServiceExtrasInput, CurrencyUncheckedCreateWithoutServiceExtrasInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutServiceExtrasInput
    connect?: CurrencyWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutServiceExtrasNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceExtrasInput, ServiceUncheckedCreateWithoutServiceExtrasInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceExtrasInput
    upsert?: ServiceUpsertWithoutServiceExtrasInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceExtrasInput, ServiceUpdateWithoutServiceExtrasInput>, ServiceUncheckedUpdateWithoutServiceExtrasInput>
  }

  export type CurrencyUpdateOneWithoutServiceExtrasNestedInput = {
    create?: XOR<CurrencyCreateWithoutServiceExtrasInput, CurrencyUncheckedCreateWithoutServiceExtrasInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutServiceExtrasInput
    upsert?: CurrencyUpsertWithoutServiceExtrasInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutServiceExtrasInput, CurrencyUpdateWithoutServiceExtrasInput>, CurrencyUncheckedUpdateWithoutServiceExtrasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserCreateWithoutRoleInput = {
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    fullNameKms?: StringNullableFilter<"User"> | string | null
    emailSha?: StringNullableFilter<"User"> | string | null
    emailKms?: StringFilter<"User"> | string
    roleId?: IntFilter<"User"> | number
    passwordSha?: StringFilter<"User"> | string
    passwordKms?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserRoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUsersInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
  }

  export type BlacklistCreateWithoutUserInput = {
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklistType: BlacklistTypeCreateNestedOneWithoutBlacklistsInput
  }

  export type BlacklistUncheckedCreateWithoutUserInput = {
    id?: number
    blacklistTypeId: number
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistCreateOrConnectWithoutUserInput = {
    where: BlacklistWhereUniqueInput
    create: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput>
  }

  export type BlacklistCreateManyUserInputEnvelope = {
    data: BlacklistCreateManyUserInput | BlacklistCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPhoneCreateWithoutUserInput = {
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    phoneType: UserPhoneTypeCreateNestedOneWithoutUserPhonesInput
    services?: ServiceCreateNestedManyWithoutUserPhoneInput
  }

  export type UserPhoneUncheckedCreateWithoutUserInput = {
    id?: number
    userPhoneTypeId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutUserPhoneInput
  }

  export type UserPhoneCreateOrConnectWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type UserPhoneCreateManyUserInputEnvelope = {
    data: UserPhoneCreateManyUserInput | UserPhoneCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutUserInput = {
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    zone: ZoneCreateNestedOneWithoutAddressesInput
    services?: ServiceCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: number
    zoneId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: AddressCreateManyUserInput | AddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutUserInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUserInput = {
    id?: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUserInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceCreateManyUserInputEnvelope = {
    data: ServiceCreateManyUserInput | ServiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithoutUsersInput = {
    update: XOR<UserRoleUpdateWithoutUsersInput, UserRoleUncheckedUpdateWithoutUsersInput>
    create: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
    where?: UserRoleWhereInput
  }

  export type UserRoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: UserRoleWhereInput
    data: XOR<UserRoleUpdateWithoutUsersInput, UserRoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserRoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistUpsertWithWhereUniqueWithoutUserInput = {
    where: BlacklistWhereUniqueInput
    update: XOR<BlacklistUpdateWithoutUserInput, BlacklistUncheckedUpdateWithoutUserInput>
    create: XOR<BlacklistCreateWithoutUserInput, BlacklistUncheckedCreateWithoutUserInput>
  }

  export type BlacklistUpdateWithWhereUniqueWithoutUserInput = {
    where: BlacklistWhereUniqueInput
    data: XOR<BlacklistUpdateWithoutUserInput, BlacklistUncheckedUpdateWithoutUserInput>
  }

  export type BlacklistUpdateManyWithWhereWithoutUserInput = {
    where: BlacklistScalarWhereInput
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyWithoutUserInput>
  }

  export type BlacklistScalarWhereInput = {
    AND?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
    OR?: BlacklistScalarWhereInput[]
    NOT?: BlacklistScalarWhereInput | BlacklistScalarWhereInput[]
    id?: IntFilter<"Blacklist"> | number
    userId?: IntFilter<"Blacklist"> | number
    blacklistTypeId?: IntFilter<"Blacklist"> | number
    reason?: StringFilter<"Blacklist"> | string
    isActive?: BoolFilter<"Blacklist"> | boolean
    updatedAt?: DateTimeNullableFilter<"Blacklist"> | Date | string | null
    createdAt?: DateTimeFilter<"Blacklist"> | Date | string
  }

  export type UserPhoneUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    update: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type UserPhoneUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    data: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type UserPhoneUpdateManyWithWhereWithoutUserInput = {
    where: UserPhoneScalarWhereInput
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPhoneScalarWhereInput = {
    AND?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
    OR?: UserPhoneScalarWhereInput[]
    NOT?: UserPhoneScalarWhereInput | UserPhoneScalarWhereInput[]
    id?: IntFilter<"UserPhone"> | number
    userId?: IntFilter<"UserPhone"> | number
    userPhoneTypeId?: IntFilter<"UserPhone"> | number
    phoneNumberKms?: StringFilter<"UserPhone"> | string
    isPrincipal?: BoolFilter<"UserPhone"> | boolean
    isActive?: BoolFilter<"UserPhone"> | boolean
    updatedAt?: DateTimeNullableFilter<"UserPhone"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPhone"> | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    userId?: IntFilter<"Address"> | number
    zoneId?: IntFilter<"Address"> | number
    addressKms?: StringFilter<"Address"> | string
    coordsKms?: StringNullableFilter<"Address"> | string | null
    instructionsKms?: StringNullableFilter<"Address"> | string | null
    domicilePrice?: DecimalNullableFilter<"Address"> | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: IntNullableFilter<"Address"> | number | null
    isActive?: BoolFilter<"Address"> | boolean
    updatedAt?: DateTimeNullableFilter<"Address"> | Date | string | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
  }

  export type ServiceUpdateManyWithWhereWithoutUserInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: IntFilter<"Service"> | number
    userId?: IntFilter<"Service"> | number
    deliveryNameKms?: StringFilter<"Service"> | string
    addressId?: IntFilter<"Service"> | number
    userPhoneId?: IntFilter<"Service"> | number
    description?: StringNullableFilter<"Service"> | string | null
    serviceStart?: DateTimeFilter<"Service"> | Date | string
    serviceEnd?: DateTimeFilter<"Service"> | Date | string
    totalAmount?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntFilter<"Service"> | number
    serviceStatusId?: IntFilter<"Service"> | number
    paymentStatusId?: IntFilter<"Service"> | number
    comment?: StringNullableFilter<"Service"> | string | null
    invoiceNumberKms?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    updatedAt?: DateTimeNullableFilter<"Service"> | Date | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type BlacklistCreateWithoutBlacklistTypeInput = {
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBlacklistsInput
  }

  export type BlacklistUncheckedCreateWithoutBlacklistTypeInput = {
    id?: number
    userId: number
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistCreateOrConnectWithoutBlacklistTypeInput = {
    where: BlacklistWhereUniqueInput
    create: XOR<BlacklistCreateWithoutBlacklistTypeInput, BlacklistUncheckedCreateWithoutBlacklistTypeInput>
  }

  export type BlacklistCreateManyBlacklistTypeInputEnvelope = {
    data: BlacklistCreateManyBlacklistTypeInput | BlacklistCreateManyBlacklistTypeInput[]
    skipDuplicates?: boolean
  }

  export type BlacklistUpsertWithWhereUniqueWithoutBlacklistTypeInput = {
    where: BlacklistWhereUniqueInput
    update: XOR<BlacklistUpdateWithoutBlacklistTypeInput, BlacklistUncheckedUpdateWithoutBlacklistTypeInput>
    create: XOR<BlacklistCreateWithoutBlacklistTypeInput, BlacklistUncheckedCreateWithoutBlacklistTypeInput>
  }

  export type BlacklistUpdateWithWhereUniqueWithoutBlacklistTypeInput = {
    where: BlacklistWhereUniqueInput
    data: XOR<BlacklistUpdateWithoutBlacklistTypeInput, BlacklistUncheckedUpdateWithoutBlacklistTypeInput>
  }

  export type BlacklistUpdateManyWithWhereWithoutBlacklistTypeInput = {
    where: BlacklistScalarWhereInput
    data: XOR<BlacklistUpdateManyMutationInput, BlacklistUncheckedUpdateManyWithoutBlacklistTypeInput>
  }

  export type UserCreateWithoutBlacklistsInput = {
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    role: UserRoleCreateNestedOneWithoutUsersInput
    userPhones?: UserPhoneCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlacklistsInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    userPhones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlacklistsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlacklistsInput, UserUncheckedCreateWithoutBlacklistsInput>
  }

  export type BlacklistTypeCreateWithoutBlacklistsInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistTypeUncheckedCreateWithoutBlacklistsInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistTypeCreateOrConnectWithoutBlacklistsInput = {
    where: BlacklistTypeWhereUniqueInput
    create: XOR<BlacklistTypeCreateWithoutBlacklistsInput, BlacklistTypeUncheckedCreateWithoutBlacklistsInput>
  }

  export type UserUpsertWithoutBlacklistsInput = {
    update: XOR<UserUpdateWithoutBlacklistsInput, UserUncheckedUpdateWithoutBlacklistsInput>
    create: XOR<UserCreateWithoutBlacklistsInput, UserUncheckedCreateWithoutBlacklistsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlacklistsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlacklistsInput, UserUncheckedUpdateWithoutBlacklistsInput>
  }

  export type UserUpdateWithoutBlacklistsInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: UserRoleUpdateOneRequiredWithoutUsersNestedInput
    userPhones?: UserPhoneUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlacklistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPhones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlacklistTypeUpsertWithoutBlacklistsInput = {
    update: XOR<BlacklistTypeUpdateWithoutBlacklistsInput, BlacklistTypeUncheckedUpdateWithoutBlacklistsInput>
    create: XOR<BlacklistTypeCreateWithoutBlacklistsInput, BlacklistTypeUncheckedCreateWithoutBlacklistsInput>
    where?: BlacklistTypeWhereInput
  }

  export type BlacklistTypeUpdateToOneWithWhereWithoutBlacklistsInput = {
    where?: BlacklistTypeWhereInput
    data: XOR<BlacklistTypeUpdateWithoutBlacklistsInput, BlacklistTypeUncheckedUpdateWithoutBlacklistsInput>
  }

  export type BlacklistTypeUpdateWithoutBlacklistsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistTypeUncheckedUpdateWithoutBlacklistsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateWithoutPhoneTypeInput = {
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhonesInput
    services?: ServiceCreateNestedManyWithoutUserPhoneInput
  }

  export type UserPhoneUncheckedCreateWithoutPhoneTypeInput = {
    id?: number
    userId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutUserPhoneInput
  }

  export type UserPhoneCreateOrConnectWithoutPhoneTypeInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutPhoneTypeInput, UserPhoneUncheckedCreateWithoutPhoneTypeInput>
  }

  export type UserPhoneCreateManyPhoneTypeInputEnvelope = {
    data: UserPhoneCreateManyPhoneTypeInput | UserPhoneCreateManyPhoneTypeInput[]
    skipDuplicates?: boolean
  }

  export type UserPhoneUpsertWithWhereUniqueWithoutPhoneTypeInput = {
    where: UserPhoneWhereUniqueInput
    update: XOR<UserPhoneUpdateWithoutPhoneTypeInput, UserPhoneUncheckedUpdateWithoutPhoneTypeInput>
    create: XOR<UserPhoneCreateWithoutPhoneTypeInput, UserPhoneUncheckedCreateWithoutPhoneTypeInput>
  }

  export type UserPhoneUpdateWithWhereUniqueWithoutPhoneTypeInput = {
    where: UserPhoneWhereUniqueInput
    data: XOR<UserPhoneUpdateWithoutPhoneTypeInput, UserPhoneUncheckedUpdateWithoutPhoneTypeInput>
  }

  export type UserPhoneUpdateManyWithWhereWithoutPhoneTypeInput = {
    where: UserPhoneScalarWhereInput
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyWithoutPhoneTypeInput>
  }

  export type UserCreateWithoutUserPhonesInput = {
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    role: UserRoleCreateNestedOneWithoutUsersInput
    blacklists?: BlacklistCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPhonesInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPhonesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPhonesInput, UserUncheckedCreateWithoutUserPhonesInput>
  }

  export type UserPhoneTypeCreateWithoutUserPhonesInput = {
    type: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneTypeUncheckedCreateWithoutUserPhonesInput = {
    id?: number
    type: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneTypeCreateOrConnectWithoutUserPhonesInput = {
    where: UserPhoneTypeWhereUniqueInput
    create: XOR<UserPhoneTypeCreateWithoutUserPhonesInput, UserPhoneTypeUncheckedCreateWithoutUserPhonesInput>
  }

  export type ServiceCreateWithoutUserPhoneInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUserPhoneInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUserPhoneInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUserPhoneInput, ServiceUncheckedCreateWithoutUserPhoneInput>
  }

  export type ServiceCreateManyUserPhoneInputEnvelope = {
    data: ServiceCreateManyUserPhoneInput | ServiceCreateManyUserPhoneInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserPhonesInput = {
    update: XOR<UserUpdateWithoutUserPhonesInput, UserUncheckedUpdateWithoutUserPhonesInput>
    create: XOR<UserCreateWithoutUserPhonesInput, UserUncheckedCreateWithoutUserPhonesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPhonesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPhonesInput, UserUncheckedUpdateWithoutUserPhonesInput>
  }

  export type UserUpdateWithoutUserPhonesInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: UserRoleUpdateOneRequiredWithoutUsersNestedInput
    blacklists?: BlacklistUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPhonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserPhoneTypeUpsertWithoutUserPhonesInput = {
    update: XOR<UserPhoneTypeUpdateWithoutUserPhonesInput, UserPhoneTypeUncheckedUpdateWithoutUserPhonesInput>
    create: XOR<UserPhoneTypeCreateWithoutUserPhonesInput, UserPhoneTypeUncheckedCreateWithoutUserPhonesInput>
    where?: UserPhoneTypeWhereInput
  }

  export type UserPhoneTypeUpdateToOneWithWhereWithoutUserPhonesInput = {
    where?: UserPhoneTypeWhereInput
    data: XOR<UserPhoneTypeUpdateWithoutUserPhonesInput, UserPhoneTypeUncheckedUpdateWithoutUserPhonesInput>
  }

  export type UserPhoneTypeUpdateWithoutUserPhonesInput = {
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneTypeUncheckedUpdateWithoutUserPhonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutUserPhoneInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutUserPhoneInput, ServiceUncheckedUpdateWithoutUserPhoneInput>
    create: XOR<ServiceCreateWithoutUserPhoneInput, ServiceUncheckedCreateWithoutUserPhoneInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutUserPhoneInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutUserPhoneInput, ServiceUncheckedUpdateWithoutUserPhoneInput>
  }

  export type ServiceUpdateManyWithWhereWithoutUserPhoneInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutUserPhoneInput>
  }

  export type ProductCreateWithoutCurrencyInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    businessType: ProductBusinessTypeCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCurrencyInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCurrencyInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCurrencyInput, ProductUncheckedCreateWithoutCurrencyInput>
  }

  export type ProductCreateManyCurrencyInputEnvelope = {
    data: ProductCreateManyCurrencyInput | ProductCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutCurrencyInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCurrencyInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCurrencyInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCurrencyInput, ServiceUncheckedCreateWithoutCurrencyInput>
  }

  export type ServiceCreateManyCurrencyInputEnvelope = {
    data: ServiceCreateManyCurrencyInput | ServiceCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceDetailCreateWithoutCurrencyInput = {
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutServiceDetailsInput
    product: ProductCreateNestedOneWithoutServiceDetailsInput
  }

  export type ServiceDetailUncheckedCreateWithoutCurrencyInput = {
    id?: number
    serviceId: number
    productId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailCreateOrConnectWithoutCurrencyInput = {
    where: ServiceDetailWhereUniqueInput
    create: XOR<ServiceDetailCreateWithoutCurrencyInput, ServiceDetailUncheckedCreateWithoutCurrencyInput>
  }

  export type ServiceDetailCreateManyCurrencyInputEnvelope = {
    data: ServiceDetailCreateManyCurrencyInput | ServiceDetailCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ServiceExtraCreateWithoutCurrencyInput = {
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutServiceExtrasInput
  }

  export type ServiceExtraUncheckedCreateWithoutCurrencyInput = {
    id?: number
    serviceId: number
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceExtraCreateOrConnectWithoutCurrencyInput = {
    where: ServiceExtraWhereUniqueInput
    create: XOR<ServiceExtraCreateWithoutCurrencyInput, ServiceExtraUncheckedCreateWithoutCurrencyInput>
  }

  export type ServiceExtraCreateManyCurrencyInputEnvelope = {
    data: ServiceExtraCreateManyCurrencyInput | ServiceExtraCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCurrencyInput, ProductUncheckedUpdateWithoutCurrencyInput>
    create: XOR<ProductCreateWithoutCurrencyInput, ProductUncheckedCreateWithoutCurrencyInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCurrencyInput, ProductUncheckedUpdateWithoutCurrencyInput>
  }

  export type ProductUpdateManyWithWhereWithoutCurrencyInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    productBusinessTypeId?: IntFilter<"Product"> | number
    productCategoryId?: IntFilter<"Product"> | number
    rentPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    sellPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFilter<"Product"> | number
    quantity?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCurrencyInput, ServiceUncheckedUpdateWithoutCurrencyInput>
    create: XOR<ServiceCreateWithoutCurrencyInput, ServiceUncheckedCreateWithoutCurrencyInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCurrencyInput, ServiceUncheckedUpdateWithoutCurrencyInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCurrencyInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ServiceDetailUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: ServiceDetailWhereUniqueInput
    update: XOR<ServiceDetailUpdateWithoutCurrencyInput, ServiceDetailUncheckedUpdateWithoutCurrencyInput>
    create: XOR<ServiceDetailCreateWithoutCurrencyInput, ServiceDetailUncheckedCreateWithoutCurrencyInput>
  }

  export type ServiceDetailUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: ServiceDetailWhereUniqueInput
    data: XOR<ServiceDetailUpdateWithoutCurrencyInput, ServiceDetailUncheckedUpdateWithoutCurrencyInput>
  }

  export type ServiceDetailUpdateManyWithWhereWithoutCurrencyInput = {
    where: ServiceDetailScalarWhereInput
    data: XOR<ServiceDetailUpdateManyMutationInput, ServiceDetailUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ServiceDetailScalarWhereInput = {
    AND?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
    OR?: ServiceDetailScalarWhereInput[]
    NOT?: ServiceDetailScalarWhereInput | ServiceDetailScalarWhereInput[]
    id?: IntFilter<"ServiceDetail"> | number
    serviceId?: IntFilter<"ServiceDetail"> | number
    productId?: IntFilter<"ServiceDetail"> | number
    quantity?: IntFilter<"ServiceDetail"> | number
    unitaryPrice?: DecimalFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFilter<"ServiceDetail"> | Decimal | DecimalJsLike | number | string
    currencyId?: IntFilter<"ServiceDetail"> | number
    isActive?: BoolFilter<"ServiceDetail"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceDetail"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceDetail"> | Date | string
  }

  export type ServiceExtraUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: ServiceExtraWhereUniqueInput
    update: XOR<ServiceExtraUpdateWithoutCurrencyInput, ServiceExtraUncheckedUpdateWithoutCurrencyInput>
    create: XOR<ServiceExtraCreateWithoutCurrencyInput, ServiceExtraUncheckedCreateWithoutCurrencyInput>
  }

  export type ServiceExtraUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: ServiceExtraWhereUniqueInput
    data: XOR<ServiceExtraUpdateWithoutCurrencyInput, ServiceExtraUncheckedUpdateWithoutCurrencyInput>
  }

  export type ServiceExtraUpdateManyWithWhereWithoutCurrencyInput = {
    where: ServiceExtraScalarWhereInput
    data: XOR<ServiceExtraUpdateManyMutationInput, ServiceExtraUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ServiceExtraScalarWhereInput = {
    AND?: ServiceExtraScalarWhereInput | ServiceExtraScalarWhereInput[]
    OR?: ServiceExtraScalarWhereInput[]
    NOT?: ServiceExtraScalarWhereInput | ServiceExtraScalarWhereInput[]
    id?: IntFilter<"ServiceExtra"> | number
    serviceId?: IntFilter<"ServiceExtra"> | number
    name?: StringFilter<"ServiceExtra"> | string
    description?: StringNullableFilter<"ServiceExtra"> | string | null
    quantity?: IntNullableFilter<"ServiceExtra"> | number | null
    unitaryPrice?: DecimalNullableFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: DecimalNullableFilter<"ServiceExtra"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntNullableFilter<"ServiceExtra"> | number | null
    isActive?: BoolFilter<"ServiceExtra"> | boolean
    updatedAt?: DateTimeNullableFilter<"ServiceExtra"> | Date | string | null
    createdAt?: DateTimeFilter<"ServiceExtra"> | Date | string
  }

  export type ProductCreateWithoutBusinessTypeInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    currency: CurrencyCreateNestedOneWithoutProductsInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBusinessTypeInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBusinessTypeInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBusinessTypeInput, ProductUncheckedCreateWithoutBusinessTypeInput>
  }

  export type ProductCreateManyBusinessTypeInputEnvelope = {
    data: ProductCreateManyBusinessTypeInput | ProductCreateManyBusinessTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutBusinessTypeInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBusinessTypeInput, ProductUncheckedUpdateWithoutBusinessTypeInput>
    create: XOR<ProductCreateWithoutBusinessTypeInput, ProductUncheckedCreateWithoutBusinessTypeInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBusinessTypeInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBusinessTypeInput, ProductUncheckedUpdateWithoutBusinessTypeInput>
  }

  export type ProductUpdateManyWithWhereWithoutBusinessTypeInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBusinessTypeInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    businessType: ProductBusinessTypeCreateNestedOneWithoutProductsInput
    currency: CurrencyCreateNestedOneWithoutProductsInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductBusinessTypeCreateWithoutProductsInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductBusinessTypeUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductBusinessTypeCreateOrConnectWithoutProductsInput = {
    where: ProductBusinessTypeWhereUniqueInput
    create: XOR<ProductBusinessTypeCreateWithoutProductsInput, ProductBusinessTypeUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type CurrencyCreateWithoutProductsInput = {
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutProductsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutProductsInput, CurrencyUncheckedCreateWithoutProductsInput>
  }

  export type ProductDetailCreateWithoutProductInput = {
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    detailType: ProductDetailTypeCreateNestedOneWithoutProductDetailsInput
  }

  export type ProductDetailUncheckedCreateWithoutProductInput = {
    id?: number
    productDetailTypeId: number
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailCreateOrConnectWithoutProductInput = {
    where: ProductDetailWhereUniqueInput
    create: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput>
  }

  export type ProductDetailCreateManyProductInputEnvelope = {
    data: ProductDetailCreateManyProductInput | ProductDetailCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ServiceDetailCreateWithoutProductInput = {
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    service: ServiceCreateNestedOneWithoutServiceDetailsInput
    currency: CurrencyCreateNestedOneWithoutServiceDetailsInput
  }

  export type ServiceDetailUncheckedCreateWithoutProductInput = {
    id?: number
    serviceId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    currencyId: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailCreateOrConnectWithoutProductInput = {
    where: ServiceDetailWhereUniqueInput
    create: XOR<ServiceDetailCreateWithoutProductInput, ServiceDetailUncheckedCreateWithoutProductInput>
  }

  export type ServiceDetailCreateManyProductInputEnvelope = {
    data: ServiceDetailCreateManyProductInput | ServiceDetailCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductBusinessTypeUpsertWithoutProductsInput = {
    update: XOR<ProductBusinessTypeUpdateWithoutProductsInput, ProductBusinessTypeUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductBusinessTypeCreateWithoutProductsInput, ProductBusinessTypeUncheckedCreateWithoutProductsInput>
    where?: ProductBusinessTypeWhereInput
  }

  export type ProductBusinessTypeUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductBusinessTypeWhereInput
    data: XOR<ProductBusinessTypeUpdateWithoutProductsInput, ProductBusinessTypeUncheckedUpdateWithoutProductsInput>
  }

  export type ProductBusinessTypeUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBusinessTypeUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUpsertWithoutProductsInput = {
    update: XOR<CurrencyUpdateWithoutProductsInput, CurrencyUncheckedUpdateWithoutProductsInput>
    create: XOR<CurrencyCreateWithoutProductsInput, CurrencyUncheckedCreateWithoutProductsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutProductsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutProductsInput, CurrencyUncheckedUpdateWithoutProductsInput>
  }

  export type CurrencyUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type ProductDetailUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductDetailWhereUniqueInput
    update: XOR<ProductDetailUpdateWithoutProductInput, ProductDetailUncheckedUpdateWithoutProductInput>
    create: XOR<ProductDetailCreateWithoutProductInput, ProductDetailUncheckedCreateWithoutProductInput>
  }

  export type ProductDetailUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductDetailWhereUniqueInput
    data: XOR<ProductDetailUpdateWithoutProductInput, ProductDetailUncheckedUpdateWithoutProductInput>
  }

  export type ProductDetailUpdateManyWithWhereWithoutProductInput = {
    where: ProductDetailScalarWhereInput
    data: XOR<ProductDetailUpdateManyMutationInput, ProductDetailUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductDetailScalarWhereInput = {
    AND?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
    OR?: ProductDetailScalarWhereInput[]
    NOT?: ProductDetailScalarWhereInput | ProductDetailScalarWhereInput[]
    id?: IntFilter<"ProductDetail"> | number
    productId?: IntFilter<"ProductDetail"> | number
    productDetailTypeId?: IntFilter<"ProductDetail"> | number
    detail?: StringFilter<"ProductDetail"> | string
    isActive?: BoolFilter<"ProductDetail"> | boolean
    updatedAt?: DateTimeNullableFilter<"ProductDetail"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductDetail"> | Date | string
  }

  export type ServiceDetailUpsertWithWhereUniqueWithoutProductInput = {
    where: ServiceDetailWhereUniqueInput
    update: XOR<ServiceDetailUpdateWithoutProductInput, ServiceDetailUncheckedUpdateWithoutProductInput>
    create: XOR<ServiceDetailCreateWithoutProductInput, ServiceDetailUncheckedCreateWithoutProductInput>
  }

  export type ServiceDetailUpdateWithWhereUniqueWithoutProductInput = {
    where: ServiceDetailWhereUniqueInput
    data: XOR<ServiceDetailUpdateWithoutProductInput, ServiceDetailUncheckedUpdateWithoutProductInput>
  }

  export type ServiceDetailUpdateManyWithWhereWithoutProductInput = {
    where: ServiceDetailScalarWhereInput
    data: XOR<ServiceDetailUpdateManyMutationInput, ServiceDetailUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductDetailCreateWithoutDetailTypeInput = {
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutProductDetailsInput
  }

  export type ProductDetailUncheckedCreateWithoutDetailTypeInput = {
    id?: number
    productId: number
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailCreateOrConnectWithoutDetailTypeInput = {
    where: ProductDetailWhereUniqueInput
    create: XOR<ProductDetailCreateWithoutDetailTypeInput, ProductDetailUncheckedCreateWithoutDetailTypeInput>
  }

  export type ProductDetailCreateManyDetailTypeInputEnvelope = {
    data: ProductDetailCreateManyDetailTypeInput | ProductDetailCreateManyDetailTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProductDetailUpsertWithWhereUniqueWithoutDetailTypeInput = {
    where: ProductDetailWhereUniqueInput
    update: XOR<ProductDetailUpdateWithoutDetailTypeInput, ProductDetailUncheckedUpdateWithoutDetailTypeInput>
    create: XOR<ProductDetailCreateWithoutDetailTypeInput, ProductDetailUncheckedCreateWithoutDetailTypeInput>
  }

  export type ProductDetailUpdateWithWhereUniqueWithoutDetailTypeInput = {
    where: ProductDetailWhereUniqueInput
    data: XOR<ProductDetailUpdateWithoutDetailTypeInput, ProductDetailUncheckedUpdateWithoutDetailTypeInput>
  }

  export type ProductDetailUpdateManyWithWhereWithoutDetailTypeInput = {
    where: ProductDetailScalarWhereInput
    data: XOR<ProductDetailUpdateManyMutationInput, ProductDetailUncheckedUpdateManyWithoutDetailTypeInput>
  }

  export type ProductCreateWithoutProductDetailsInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    businessType: ProductBusinessTypeCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    currency: CurrencyCreateNestedOneWithoutProductsInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductDetailsInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
  }

  export type ProductDetailTypeCreateWithoutProductDetailsInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailTypeUncheckedCreateWithoutProductDetailsInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailTypeCreateOrConnectWithoutProductDetailsInput = {
    where: ProductDetailTypeWhereUniqueInput
    create: XOR<ProductDetailTypeCreateWithoutProductDetailsInput, ProductDetailTypeUncheckedCreateWithoutProductDetailsInput>
  }

  export type ProductUpsertWithoutProductDetailsInput = {
    update: XOR<ProductUpdateWithoutProductDetailsInput, ProductUncheckedUpdateWithoutProductDetailsInput>
    create: XOR<ProductCreateWithoutProductDetailsInput, ProductUncheckedCreateWithoutProductDetailsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductDetailsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductDetailsInput, ProductUncheckedUpdateWithoutProductDetailsInput>
  }

  export type ProductUpdateWithoutProductDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: ProductBusinessTypeUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutProductsNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductDetailTypeUpsertWithoutProductDetailsInput = {
    update: XOR<ProductDetailTypeUpdateWithoutProductDetailsInput, ProductDetailTypeUncheckedUpdateWithoutProductDetailsInput>
    create: XOR<ProductDetailTypeCreateWithoutProductDetailsInput, ProductDetailTypeUncheckedCreateWithoutProductDetailsInput>
    where?: ProductDetailTypeWhereInput
  }

  export type ProductDetailTypeUpdateToOneWithWhereWithoutProductDetailsInput = {
    where?: ProductDetailTypeWhereInput
    data: XOR<ProductDetailTypeUpdateWithoutProductDetailsInput, ProductDetailTypeUncheckedUpdateWithoutProductDetailsInput>
  }

  export type ProductDetailTypeUpdateWithoutProductDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailTypeUncheckedUpdateWithoutProductDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryDepartmentCreateWithoutCountryInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    municipalities?: MunicipalityCreateNestedManyWithoutDepartmentInput
  }

  export type CountryDepartmentUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    municipalities?: MunicipalityUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type CountryDepartmentCreateOrConnectWithoutCountryInput = {
    where: CountryDepartmentWhereUniqueInput
    create: XOR<CountryDepartmentCreateWithoutCountryInput, CountryDepartmentUncheckedCreateWithoutCountryInput>
  }

  export type CountryDepartmentCreateManyCountryInputEnvelope = {
    data: CountryDepartmentCreateManyCountryInput | CountryDepartmentCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type CountryDepartmentUpsertWithWhereUniqueWithoutCountryInput = {
    where: CountryDepartmentWhereUniqueInput
    update: XOR<CountryDepartmentUpdateWithoutCountryInput, CountryDepartmentUncheckedUpdateWithoutCountryInput>
    create: XOR<CountryDepartmentCreateWithoutCountryInput, CountryDepartmentUncheckedCreateWithoutCountryInput>
  }

  export type CountryDepartmentUpdateWithWhereUniqueWithoutCountryInput = {
    where: CountryDepartmentWhereUniqueInput
    data: XOR<CountryDepartmentUpdateWithoutCountryInput, CountryDepartmentUncheckedUpdateWithoutCountryInput>
  }

  export type CountryDepartmentUpdateManyWithWhereWithoutCountryInput = {
    where: CountryDepartmentScalarWhereInput
    data: XOR<CountryDepartmentUpdateManyMutationInput, CountryDepartmentUncheckedUpdateManyWithoutCountryInput>
  }

  export type CountryDepartmentScalarWhereInput = {
    AND?: CountryDepartmentScalarWhereInput | CountryDepartmentScalarWhereInput[]
    OR?: CountryDepartmentScalarWhereInput[]
    NOT?: CountryDepartmentScalarWhereInput | CountryDepartmentScalarWhereInput[]
    id?: IntFilter<"CountryDepartment"> | number
    name?: StringFilter<"CountryDepartment"> | string
    countryId?: IntFilter<"CountryDepartment"> | number
    description?: StringNullableFilter<"CountryDepartment"> | string | null
    isActive?: BoolFilter<"CountryDepartment"> | boolean
    updatedAt?: DateTimeNullableFilter<"CountryDepartment"> | Date | string | null
    createdAt?: DateTimeFilter<"CountryDepartment"> | Date | string
  }

  export type CountryCreateWithoutDepartmentsInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CountryUncheckedCreateWithoutDepartmentsInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CountryCreateOrConnectWithoutDepartmentsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutDepartmentsInput, CountryUncheckedCreateWithoutDepartmentsInput>
  }

  export type MunicipalityCreateWithoutDepartmentInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    zones?: ZoneCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    zones?: ZoneUncheckedCreateNestedManyWithoutMunicipalityInput
  }

  export type MunicipalityCreateOrConnectWithoutDepartmentInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput>
  }

  export type MunicipalityCreateManyDepartmentInputEnvelope = {
    data: MunicipalityCreateManyDepartmentInput | MunicipalityCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutDepartmentsInput = {
    update: XOR<CountryUpdateWithoutDepartmentsInput, CountryUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<CountryCreateWithoutDepartmentsInput, CountryUncheckedCreateWithoutDepartmentsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutDepartmentsInput, CountryUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CountryUpdateWithoutDepartmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: MunicipalityWhereUniqueInput
    update: XOR<MunicipalityUpdateWithoutDepartmentInput, MunicipalityUncheckedUpdateWithoutDepartmentInput>
    create: XOR<MunicipalityCreateWithoutDepartmentInput, MunicipalityUncheckedCreateWithoutDepartmentInput>
  }

  export type MunicipalityUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: MunicipalityWhereUniqueInput
    data: XOR<MunicipalityUpdateWithoutDepartmentInput, MunicipalityUncheckedUpdateWithoutDepartmentInput>
  }

  export type MunicipalityUpdateManyWithWhereWithoutDepartmentInput = {
    where: MunicipalityScalarWhereInput
    data: XOR<MunicipalityUpdateManyMutationInput, MunicipalityUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type MunicipalityScalarWhereInput = {
    AND?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    OR?: MunicipalityScalarWhereInput[]
    NOT?: MunicipalityScalarWhereInput | MunicipalityScalarWhereInput[]
    id?: IntFilter<"Municipality"> | number
    name?: StringFilter<"Municipality"> | string
    departmentId?: IntFilter<"Municipality"> | number
    description?: StringNullableFilter<"Municipality"> | string | null
    isActive?: BoolFilter<"Municipality"> | boolean
    updatedAt?: DateTimeNullableFilter<"Municipality"> | Date | string | null
    createdAt?: DateTimeFilter<"Municipality"> | Date | string
  }

  export type CountryDepartmentCreateWithoutMunicipalitiesInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    country: CountryCreateNestedOneWithoutDepartmentsInput
  }

  export type CountryDepartmentUncheckedCreateWithoutMunicipalitiesInput = {
    id?: number
    name: string
    countryId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CountryDepartmentCreateOrConnectWithoutMunicipalitiesInput = {
    where: CountryDepartmentWhereUniqueInput
    create: XOR<CountryDepartmentCreateWithoutMunicipalitiesInput, CountryDepartmentUncheckedCreateWithoutMunicipalitiesInput>
  }

  export type ZoneCreateWithoutMunicipalityInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutMunicipalityInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutMunicipalityInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutMunicipalityInput, ZoneUncheckedCreateWithoutMunicipalityInput>
  }

  export type ZoneCreateManyMunicipalityInputEnvelope = {
    data: ZoneCreateManyMunicipalityInput | ZoneCreateManyMunicipalityInput[]
    skipDuplicates?: boolean
  }

  export type CountryDepartmentUpsertWithoutMunicipalitiesInput = {
    update: XOR<CountryDepartmentUpdateWithoutMunicipalitiesInput, CountryDepartmentUncheckedUpdateWithoutMunicipalitiesInput>
    create: XOR<CountryDepartmentCreateWithoutMunicipalitiesInput, CountryDepartmentUncheckedCreateWithoutMunicipalitiesInput>
    where?: CountryDepartmentWhereInput
  }

  export type CountryDepartmentUpdateToOneWithWhereWithoutMunicipalitiesInput = {
    where?: CountryDepartmentWhereInput
    data: XOR<CountryDepartmentUpdateWithoutMunicipalitiesInput, CountryDepartmentUncheckedUpdateWithoutMunicipalitiesInput>
  }

  export type CountryDepartmentUpdateWithoutMunicipalitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: CountryUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type CountryDepartmentUncheckedUpdateWithoutMunicipalitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUpsertWithWhereUniqueWithoutMunicipalityInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutMunicipalityInput, ZoneUncheckedUpdateWithoutMunicipalityInput>
    create: XOR<ZoneCreateWithoutMunicipalityInput, ZoneUncheckedCreateWithoutMunicipalityInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutMunicipalityInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutMunicipalityInput, ZoneUncheckedUpdateWithoutMunicipalityInput>
  }

  export type ZoneUpdateManyWithWhereWithoutMunicipalityInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutMunicipalityInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: IntFilter<"Zone"> | number
    name?: StringFilter<"Zone"> | string
    municipalityId?: IntFilter<"Zone"> | number
    description?: StringNullableFilter<"Zone"> | string | null
    isActive?: BoolFilter<"Zone"> | boolean
    updatedAt?: DateTimeNullableFilter<"Zone"> | Date | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
  }

  export type MunicipalityCreateWithoutZonesInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    department: CountryDepartmentCreateNestedOneWithoutMunicipalitiesInput
  }

  export type MunicipalityUncheckedCreateWithoutZonesInput = {
    id?: number
    name: string
    departmentId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MunicipalityCreateOrConnectWithoutZonesInput = {
    where: MunicipalityWhereUniqueInput
    create: XOR<MunicipalityCreateWithoutZonesInput, MunicipalityUncheckedCreateWithoutZonesInput>
  }

  export type AddressCreateWithoutZoneInput = {
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    services?: ServiceCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutZoneInput = {
    id?: number
    userId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutZoneInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutZoneInput, AddressUncheckedCreateWithoutZoneInput>
  }

  export type AddressCreateManyZoneInputEnvelope = {
    data: AddressCreateManyZoneInput | AddressCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type MunicipalityUpsertWithoutZonesInput = {
    update: XOR<MunicipalityUpdateWithoutZonesInput, MunicipalityUncheckedUpdateWithoutZonesInput>
    create: XOR<MunicipalityCreateWithoutZonesInput, MunicipalityUncheckedCreateWithoutZonesInput>
    where?: MunicipalityWhereInput
  }

  export type MunicipalityUpdateToOneWithWhereWithoutZonesInput = {
    where?: MunicipalityWhereInput
    data: XOR<MunicipalityUpdateWithoutZonesInput, MunicipalityUncheckedUpdateWithoutZonesInput>
  }

  export type MunicipalityUpdateWithoutZonesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: CountryDepartmentUpdateOneRequiredWithoutMunicipalitiesNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutZonesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutZoneInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutZoneInput, AddressUncheckedUpdateWithoutZoneInput>
    create: XOR<AddressCreateWithoutZoneInput, AddressUncheckedCreateWithoutZoneInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutZoneInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutZoneInput, AddressUncheckedUpdateWithoutZoneInput>
  }

  export type AddressUpdateManyWithWhereWithoutZoneInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutZoneInput>
  }

  export type UserCreateWithoutAddressesInput = {
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    role: UserRoleCreateNestedOneWithoutUsersInput
    blacklists?: BlacklistCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneCreateNestedManyWithoutUserInput
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type ZoneCreateWithoutAddressesInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    municipality: MunicipalityCreateNestedOneWithoutZonesInput
  }

  export type ZoneUncheckedCreateWithoutAddressesInput = {
    id?: number
    name: string
    municipalityId: number
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ZoneCreateOrConnectWithoutAddressesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutAddressesInput, ZoneUncheckedCreateWithoutAddressesInput>
  }

  export type ServiceCreateWithoutAddressInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAddressInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAddressInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAddressInput, ServiceUncheckedCreateWithoutAddressInput>
  }

  export type ServiceCreateManyAddressInputEnvelope = {
    data: ServiceCreateManyAddressInput | ServiceCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: UserRoleUpdateOneRequiredWithoutUsersNestedInput
    blacklists?: BlacklistUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ZoneUpsertWithoutAddressesInput = {
    update: XOR<ZoneUpdateWithoutAddressesInput, ZoneUncheckedUpdateWithoutAddressesInput>
    create: XOR<ZoneCreateWithoutAddressesInput, ZoneUncheckedCreateWithoutAddressesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutAddressesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutAddressesInput, ZoneUncheckedUpdateWithoutAddressesInput>
  }

  export type ZoneUpdateWithoutAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipality?: MunicipalityUpdateOneRequiredWithoutZonesNestedInput
  }

  export type ZoneUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    municipalityId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutAddressInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutAddressInput, ServiceUncheckedUpdateWithoutAddressInput>
    create: XOR<ServiceCreateWithoutAddressInput, ServiceUncheckedCreateWithoutAddressInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutAddressInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutAddressInput, ServiceUncheckedUpdateWithoutAddressInput>
  }

  export type ServiceUpdateManyWithWhereWithoutAddressInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutAddressInput>
  }

  export type ServiceCreateWithoutServiceStatusInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceStatusInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceStatusInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceStatusInput, ServiceUncheckedCreateWithoutServiceStatusInput>
  }

  export type ServiceCreateManyServiceStatusInputEnvelope = {
    data: ServiceCreateManyServiceStatusInput | ServiceCreateManyServiceStatusInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutServiceStatusInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutServiceStatusInput, ServiceUncheckedUpdateWithoutServiceStatusInput>
    create: XOR<ServiceCreateWithoutServiceStatusInput, ServiceUncheckedCreateWithoutServiceStatusInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutServiceStatusInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutServiceStatusInput, ServiceUncheckedUpdateWithoutServiceStatusInput>
  }

  export type ServiceUpdateManyWithWhereWithoutServiceStatusInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutServiceStatusInput>
  }

  export type ServiceCreateWithoutPaymentStatusInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPaymentStatusInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPaymentStatusInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPaymentStatusInput, ServiceUncheckedCreateWithoutPaymentStatusInput>
  }

  export type ServiceCreateManyPaymentStatusInputEnvelope = {
    data: ServiceCreateManyPaymentStatusInput | ServiceCreateManyPaymentStatusInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutPaymentStatusInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutPaymentStatusInput, ServiceUncheckedUpdateWithoutPaymentStatusInput>
    create: XOR<ServiceCreateWithoutPaymentStatusInput, ServiceUncheckedCreateWithoutPaymentStatusInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutPaymentStatusInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutPaymentStatusInput, ServiceUncheckedUpdateWithoutPaymentStatusInput>
  }

  export type ServiceUpdateManyWithWhereWithoutPaymentStatusInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutPaymentStatusInput>
  }

  export type UserCreateWithoutServicesInput = {
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    role: UserRoleCreateNestedOneWithoutUsersInput
    blacklists?: BlacklistCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneCreateNestedManyWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    roleId: number
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    blacklists?: BlacklistUncheckedCreateNestedManyWithoutUserInput
    userPhones?: UserPhoneUncheckedCreateNestedManyWithoutUserInput
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
  }

  export type AddressCreateWithoutServicesInput = {
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    zone: ZoneCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutServicesInput = {
    id?: number
    userId: number
    zoneId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutServicesInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutServicesInput, AddressUncheckedCreateWithoutServicesInput>
  }

  export type UserPhoneCreateWithoutServicesInput = {
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserPhonesInput
    phoneType: UserPhoneTypeCreateNestedOneWithoutUserPhonesInput
  }

  export type UserPhoneUncheckedCreateWithoutServicesInput = {
    id?: number
    userId: number
    userPhoneTypeId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneCreateOrConnectWithoutServicesInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutServicesInput, UserPhoneUncheckedCreateWithoutServicesInput>
  }

  export type CurrencyCreateWithoutServicesInput = {
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutServicesInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutServicesInput, CurrencyUncheckedCreateWithoutServicesInput>
  }

  export type ServiceStatusCreateWithoutServicesInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceStatusUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceStatusCreateOrConnectWithoutServicesInput = {
    where: ServiceStatusWhereUniqueInput
    create: XOR<ServiceStatusCreateWithoutServicesInput, ServiceStatusUncheckedCreateWithoutServicesInput>
  }

  export type PaymentStatusCreateWithoutServicesInput = {
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentStatusUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PaymentStatusCreateOrConnectWithoutServicesInput = {
    where: PaymentStatusWhereUniqueInput
    create: XOR<PaymentStatusCreateWithoutServicesInput, PaymentStatusUncheckedCreateWithoutServicesInput>
  }

  export type ServiceDetailCreateWithoutServiceInput = {
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutServiceDetailsInput
    currency: CurrencyCreateNestedOneWithoutServiceDetailsInput
  }

  export type ServiceDetailUncheckedCreateWithoutServiceInput = {
    id?: number
    productId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    currencyId: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailCreateOrConnectWithoutServiceInput = {
    where: ServiceDetailWhereUniqueInput
    create: XOR<ServiceDetailCreateWithoutServiceInput, ServiceDetailUncheckedCreateWithoutServiceInput>
  }

  export type ServiceDetailCreateManyServiceInputEnvelope = {
    data: ServiceDetailCreateManyServiceInput | ServiceDetailCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceExtraCreateWithoutServiceInput = {
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    currency?: CurrencyCreateNestedOneWithoutServiceExtrasInput
  }

  export type ServiceExtraUncheckedCreateWithoutServiceInput = {
    id?: number
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceExtraCreateOrConnectWithoutServiceInput = {
    where: ServiceExtraWhereUniqueInput
    create: XOR<ServiceExtraCreateWithoutServiceInput, ServiceExtraUncheckedCreateWithoutServiceInput>
  }

  export type ServiceExtraCreateManyServiceInputEnvelope = {
    data: ServiceExtraCreateManyServiceInput | ServiceExtraCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateWithoutServicesInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: UserRoleUpdateOneRequiredWithoutUsersNestedInput
    blacklists?: BlacklistUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AddressUpsertWithoutServicesInput = {
    update: XOR<AddressUpdateWithoutServicesInput, AddressUncheckedUpdateWithoutServicesInput>
    create: XOR<AddressCreateWithoutServicesInput, AddressUncheckedCreateWithoutServicesInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutServicesInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutServicesInput, AddressUncheckedUpdateWithoutServicesInput>
  }

  export type AddressUpdateWithoutServicesInput = {
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUpsertWithoutServicesInput = {
    update: XOR<UserPhoneUpdateWithoutServicesInput, UserPhoneUncheckedUpdateWithoutServicesInput>
    create: XOR<UserPhoneCreateWithoutServicesInput, UserPhoneUncheckedCreateWithoutServicesInput>
    where?: UserPhoneWhereInput
  }

  export type UserPhoneUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserPhoneWhereInput
    data: XOR<UserPhoneUpdateWithoutServicesInput, UserPhoneUncheckedUpdateWithoutServicesInput>
  }

  export type UserPhoneUpdateWithoutServicesInput = {
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhonesNestedInput
    phoneType?: UserPhoneTypeUpdateOneRequiredWithoutUserPhonesNestedInput
  }

  export type UserPhoneUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    userPhoneTypeId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUpsertWithoutServicesInput = {
    update: XOR<CurrencyUpdateWithoutServicesInput, CurrencyUncheckedUpdateWithoutServicesInput>
    create: XOR<CurrencyCreateWithoutServicesInput, CurrencyUncheckedCreateWithoutServicesInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutServicesInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutServicesInput, CurrencyUncheckedUpdateWithoutServicesInput>
  }

  export type CurrencyUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type ServiceStatusUpsertWithoutServicesInput = {
    update: XOR<ServiceStatusUpdateWithoutServicesInput, ServiceStatusUncheckedUpdateWithoutServicesInput>
    create: XOR<ServiceStatusCreateWithoutServicesInput, ServiceStatusUncheckedCreateWithoutServicesInput>
    where?: ServiceStatusWhereInput
  }

  export type ServiceStatusUpdateToOneWithWhereWithoutServicesInput = {
    where?: ServiceStatusWhereInput
    data: XOR<ServiceStatusUpdateWithoutServicesInput, ServiceStatusUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceStatusUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceStatusUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentStatusUpsertWithoutServicesInput = {
    update: XOR<PaymentStatusUpdateWithoutServicesInput, PaymentStatusUncheckedUpdateWithoutServicesInput>
    create: XOR<PaymentStatusCreateWithoutServicesInput, PaymentStatusUncheckedCreateWithoutServicesInput>
    where?: PaymentStatusWhereInput
  }

  export type PaymentStatusUpdateToOneWithWhereWithoutServicesInput = {
    where?: PaymentStatusWhereInput
    data: XOR<PaymentStatusUpdateWithoutServicesInput, PaymentStatusUncheckedUpdateWithoutServicesInput>
  }

  export type PaymentStatusUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentStatusUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceDetailWhereUniqueInput
    update: XOR<ServiceDetailUpdateWithoutServiceInput, ServiceDetailUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceDetailCreateWithoutServiceInput, ServiceDetailUncheckedCreateWithoutServiceInput>
  }

  export type ServiceDetailUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceDetailWhereUniqueInput
    data: XOR<ServiceDetailUpdateWithoutServiceInput, ServiceDetailUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceDetailUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceDetailScalarWhereInput
    data: XOR<ServiceDetailUpdateManyMutationInput, ServiceDetailUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceExtraUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceExtraWhereUniqueInput
    update: XOR<ServiceExtraUpdateWithoutServiceInput, ServiceExtraUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceExtraCreateWithoutServiceInput, ServiceExtraUncheckedCreateWithoutServiceInput>
  }

  export type ServiceExtraUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceExtraWhereUniqueInput
    data: XOR<ServiceExtraUpdateWithoutServiceInput, ServiceExtraUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceExtraUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceExtraScalarWhereInput
    data: XOR<ServiceExtraUpdateManyMutationInput, ServiceExtraUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCreateWithoutServiceDetailsInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceDetailsInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceDetailsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceDetailsInput, ServiceUncheckedCreateWithoutServiceDetailsInput>
  }

  export type ProductCreateWithoutServiceDetailsInput = {
    name: string
    description?: string | null
    imageUrl?: string | null
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    businessType: ProductBusinessTypeCreateNestedOneWithoutProductsInput
    category: ProductCategoryCreateNestedOneWithoutProductsInput
    currency: CurrencyCreateNestedOneWithoutProductsInput
    productDetails?: ProductDetailCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutServiceDetailsInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    productDetails?: ProductDetailUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutServiceDetailsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServiceDetailsInput, ProductUncheckedCreateWithoutServiceDetailsInput>
  }

  export type CurrencyCreateWithoutServiceDetailsInput = {
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutCurrencyInput
    services?: ServiceCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutServiceDetailsInput = {
    id?: number
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCurrencyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCurrencyInput
    serviceExtras?: ServiceExtraUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutServiceDetailsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutServiceDetailsInput, CurrencyUncheckedCreateWithoutServiceDetailsInput>
  }

  export type ServiceUpsertWithoutServiceDetailsInput = {
    update: XOR<ServiceUpdateWithoutServiceDetailsInput, ServiceUncheckedUpdateWithoutServiceDetailsInput>
    create: XOR<ServiceCreateWithoutServiceDetailsInput, ServiceUncheckedCreateWithoutServiceDetailsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceDetailsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceDetailsInput, ServiceUncheckedUpdateWithoutServiceDetailsInput>
  }

  export type ServiceUpdateWithoutServiceDetailsInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProductUpsertWithoutServiceDetailsInput = {
    update: XOR<ProductUpdateWithoutServiceDetailsInput, ProductUncheckedUpdateWithoutServiceDetailsInput>
    create: XOR<ProductCreateWithoutServiceDetailsInput, ProductUncheckedCreateWithoutServiceDetailsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutServiceDetailsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutServiceDetailsInput, ProductUncheckedUpdateWithoutServiceDetailsInput>
  }

  export type ProductUpdateWithoutServiceDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: ProductBusinessTypeUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutProductsNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutServiceDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CurrencyUpsertWithoutServiceDetailsInput = {
    update: XOR<CurrencyUpdateWithoutServiceDetailsInput, CurrencyUncheckedUpdateWithoutServiceDetailsInput>
    create: XOR<CurrencyCreateWithoutServiceDetailsInput, CurrencyUncheckedCreateWithoutServiceDetailsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutServiceDetailsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutServiceDetailsInput, CurrencyUncheckedUpdateWithoutServiceDetailsInput>
  }

  export type CurrencyUpdateWithoutServiceDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCurrencyNestedInput
    services?: ServiceUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutServiceDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCurrencyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type ServiceCreateWithoutServiceExtrasInput = {
    deliveryNameKms: string
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutServicesInput
    address: AddressCreateNestedOneWithoutServicesInput
    userPhone: UserPhoneCreateNestedOneWithoutServicesInput
    currency: CurrencyCreateNestedOneWithoutServicesInput
    serviceStatus: ServiceStatusCreateNestedOneWithoutServicesInput
    paymentStatus: PaymentStatusCreateNestedOneWithoutServicesInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceExtrasInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceExtrasInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceExtrasInput, ServiceUncheckedCreateWithoutServiceExtrasInput>
  }

  export type CurrencyCreateWithoutServiceExtrasInput = {
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutCurrencyInput
    services?: ServiceCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutServiceExtrasInput = {
    id?: number
    name: string
    description?: string | null
    symbol: string
    iso4217Code: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCurrencyInput
    services?: ServiceUncheckedCreateNestedManyWithoutCurrencyInput
    serviceDetails?: ServiceDetailUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutServiceExtrasInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutServiceExtrasInput, CurrencyUncheckedCreateWithoutServiceExtrasInput>
  }

  export type ServiceUpsertWithoutServiceExtrasInput = {
    update: XOR<ServiceUpdateWithoutServiceExtrasInput, ServiceUncheckedUpdateWithoutServiceExtrasInput>
    create: XOR<ServiceCreateWithoutServiceExtrasInput, ServiceUncheckedCreateWithoutServiceExtrasInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceExtrasInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceExtrasInput, ServiceUncheckedUpdateWithoutServiceExtrasInput>
  }

  export type ServiceUpdateWithoutServiceExtrasInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceExtrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type CurrencyUpsertWithoutServiceExtrasInput = {
    update: XOR<CurrencyUpdateWithoutServiceExtrasInput, CurrencyUncheckedUpdateWithoutServiceExtrasInput>
    create: XOR<CurrencyCreateWithoutServiceExtrasInput, CurrencyUncheckedCreateWithoutServiceExtrasInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutServiceExtrasInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutServiceExtrasInput, CurrencyUncheckedUpdateWithoutServiceExtrasInput>
  }

  export type CurrencyUpdateWithoutServiceExtrasInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCurrencyNestedInput
    services?: ServiceUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutServiceExtrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: StringFieldUpdateOperationsInput | string
    iso4217Code?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCurrencyNestedInput
    services?: ServiceUncheckedUpdateManyWithoutCurrencyNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type UserCreateManyRoleInput = {
    id?: number
    fullNameKms?: string | null
    emailSha?: string | null
    emailKms: string
    passwordSha: string
    passwordKms: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUpdateManyWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklists?: BlacklistUncheckedUpdateManyWithoutUserNestedInput
    userPhones?: UserPhoneUncheckedUpdateManyWithoutUserNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullNameKms?: NullableStringFieldUpdateOperationsInput | string | null
    emailSha?: NullableStringFieldUpdateOperationsInput | string | null
    emailKms?: StringFieldUpdateOperationsInput | string
    passwordSha?: StringFieldUpdateOperationsInput | string
    passwordKms?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistCreateManyUserInput = {
    id?: number
    blacklistTypeId: number
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneCreateManyUserInput = {
    id?: number
    userPhoneTypeId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AddressCreateManyUserInput = {
    id?: number
    zoneId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceCreateManyUserInput = {
    id?: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistUpdateWithoutUserInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklistType?: BlacklistTypeUpdateOneRequiredWithoutBlacklistsNestedInput
  }

  export type BlacklistUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    blacklistTypeId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    blacklistTypeId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneUpdateWithoutUserInput = {
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneType?: UserPhoneTypeUpdateOneRequiredWithoutUserPhonesNestedInput
    services?: ServiceUpdateManyWithoutUserPhoneNestedInput
  }

  export type UserPhoneUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPhoneTypeId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutUserPhoneNestedInput
  }

  export type UserPhoneUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    userPhoneTypeId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneRequiredWithoutAddressesNestedInput
    services?: ServiceUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    zoneId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutUserInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistCreateManyBlacklistTypeInput = {
    id?: number
    userId: number
    reason: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BlacklistUpdateWithoutBlacklistTypeInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBlacklistsNestedInput
  }

  export type BlacklistUncheckedUpdateWithoutBlacklistTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistUncheckedUpdateManyWithoutBlacklistTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPhoneCreateManyPhoneTypeInput = {
    id?: number
    userId: number
    phoneNumberKms: string
    isPrincipal: boolean
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserPhoneUpdateWithoutPhoneTypeInput = {
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPhonesNestedInput
    services?: ServiceUpdateManyWithoutUserPhoneNestedInput
  }

  export type UserPhoneUncheckedUpdateWithoutPhoneTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutUserPhoneNestedInput
  }

  export type UserPhoneUncheckedUpdateManyWithoutPhoneTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    phoneNumberKms?: StringFieldUpdateOperationsInput | string
    isPrincipal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyUserPhoneInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceUpdateWithoutUserPhoneInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUserPhoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutUserPhoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCurrencyInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceCreateManyCurrencyInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailCreateManyCurrencyInput = {
    id?: number
    serviceId: number
    productId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceExtraCreateManyCurrencyInput = {
    id?: number
    serviceId: number
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductUpdateWithoutCurrencyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: ProductBusinessTypeUpdateOneRequiredWithoutProductsNestedInput
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpdateWithoutCurrencyInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUpdateWithoutCurrencyInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServiceDetailsNestedInput
    product?: ProductUpdateOneRequiredWithoutServiceDetailsNestedInput
  }

  export type ServiceDetailUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraUpdateWithoutCurrencyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServiceExtrasNestedInput
  }

  export type ServiceExtraUncheckedUpdateWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraUncheckedUpdateManyWithoutCurrencyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyBusinessTypeInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productCategoryId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductUpdateWithoutBusinessTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutProductsNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBusinessTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBusinessTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productCategoryId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    name: string
    description?: string | null
    imageUrl?: string | null
    productBusinessTypeId: number
    rentPrice?: Decimal | DecimalJsLike | number | string | null
    sellPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId: number
    quantity: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessType?: ProductBusinessTypeUpdateOneRequiredWithoutProductsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutProductsNestedInput
    productDetails?: ProductDetailUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productDetails?: ProductDetailUncheckedUpdateManyWithoutProductNestedInput
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    productBusinessTypeId?: IntFieldUpdateOperationsInput | number
    rentPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailCreateManyProductInput = {
    id?: number
    productDetailTypeId: number
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailCreateManyProductInput = {
    id?: number
    serviceId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    currencyId: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailUpdateWithoutProductInput = {
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailType?: ProductDetailTypeUpdateOneRequiredWithoutProductDetailsNestedInput
  }

  export type ProductDetailUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDetailTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    productDetailTypeId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServiceDetailsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServiceDetailsNestedInput
  }

  export type ServiceDetailUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailCreateManyDetailTypeInput = {
    id?: number
    productId: number
    detail: string
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductDetailUpdateWithoutDetailTypeInput = {
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductDetailsNestedInput
  }

  export type ProductDetailUncheckedUpdateWithoutDetailTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDetailUncheckedUpdateManyWithoutDetailTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    detail?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryDepartmentCreateManyCountryInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type CountryDepartmentUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalities?: MunicipalityUpdateManyWithoutDepartmentNestedInput
  }

  export type CountryDepartmentUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    municipalities?: MunicipalityUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type CountryDepartmentUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MunicipalityCreateManyDepartmentInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MunicipalityUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zones?: ZoneUncheckedUpdateManyWithoutMunicipalityNestedInput
  }

  export type MunicipalityUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateManyMunicipalityInput = {
    id?: number
    name: string
    description?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ZoneUpdateWithoutMunicipalityInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutMunicipalityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutMunicipalityInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyZoneInput = {
    id?: number
    userId: number
    addressKms: string
    coordsKms?: string | null
    instructionsKms?: string | null
    domicilePrice?: Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AddressUpdateWithoutZoneInput = {
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    services?: ServiceUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    addressKms?: StringFieldUpdateOperationsInput | string
    coordsKms?: NullableStringFieldUpdateOperationsInput | string | null
    instructionsKms?: NullableStringFieldUpdateOperationsInput | string | null
    domicilePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deliveryTimeMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyAddressInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceUpdateWithoutAddressInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyServiceStatusInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    paymentStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceUpdateWithoutServiceStatusInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    paymentStatus?: PaymentStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutServiceStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    paymentStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyPaymentStatusInput = {
    id?: number
    userId: number
    deliveryNameKms: string
    addressId: number
    userPhoneId: number
    description?: string | null
    serviceStart: Date | string
    serviceEnd: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    currencyId: number
    serviceStatusId: number
    comment?: string | null
    invoiceNumberKms?: string | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceUpdateWithoutPaymentStatusInput = {
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutServicesNestedInput
    address?: AddressUpdateOneRequiredWithoutServicesNestedInput
    userPhone?: UserPhoneUpdateOneRequiredWithoutServicesNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServicesNestedInput
    serviceStatus?: ServiceStatusUpdateOneRequiredWithoutServicesNestedInput
    serviceDetails?: ServiceDetailUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPaymentStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceDetails?: ServiceDetailUncheckedUpdateManyWithoutServiceNestedInput
    serviceExtras?: ServiceExtraUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutPaymentStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    deliveryNameKms?: StringFieldUpdateOperationsInput | string
    addressId?: IntFieldUpdateOperationsInput | number
    userPhoneId?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    serviceStart?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    serviceStatusId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumberKms?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailCreateManyServiceInput = {
    id?: number
    productId: number
    quantity: number
    unitaryPrice: Decimal | DecimalJsLike | number | string
    parcialPrice: Decimal | DecimalJsLike | number | string
    currencyId: number
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceExtraCreateManyServiceInput = {
    id?: number
    name: string
    description?: string | null
    quantity?: number | null
    unitaryPrice?: Decimal | DecimalJsLike | number | string | null
    parcialPrice?: Decimal | DecimalJsLike | number | string | null
    currencyId?: number | null
    isActive?: boolean
    updatedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ServiceDetailUpdateWithoutServiceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutServiceDetailsNestedInput
    currency?: CurrencyUpdateOneRequiredWithoutServiceDetailsNestedInput
  }

  export type ServiceDetailUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceDetailUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitaryPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    parcialPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraUpdateWithoutServiceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneWithoutServiceExtrasNestedInput
  }

  export type ServiceExtraUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceExtraUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    unitaryPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    parcialPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}